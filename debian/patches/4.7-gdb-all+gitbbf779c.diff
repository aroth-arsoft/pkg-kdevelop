diff --git a/debuggers/gdb/DESIGN.txt b/debuggers/gdb/DESIGN.txt
index ddefb70..2ee03ba 100644
--- a/debuggers/gdb/DESIGN.txt
+++ b/debuggers/gdb/DESIGN.txt
@@ -65,7 +65,7 @@ predefined set of steps:
 
    - Once there are no commands in queue, and "reload_program_state" flag is
      set, we raise the 'program_state_changed' event. All widgets react to
-     that by queueing commands for realoding their state.
+     that by queueing commands for reloading their state.
 
      
 
diff --git a/debuggers/gdb/breakpointcontroller.cpp b/debuggers/gdb/breakpointcontroller.cpp
index 744e750..ca58192 100644
--- a/debuggers/gdb/breakpointcontroller.cpp
+++ b/debuggers/gdb/breakpointcontroller.cpp
@@ -57,10 +57,21 @@ QString unquoteExpression(QString expr)
 struct Handler : public GDBCommandHandler
 {
     Handler(BreakpointController *c, KDevelop::Breakpoint *b)
-        : controller(c), breakpoint(b) {}
+        : controller(c)
+        , breakpointIndex(c->breakpointModel()->breakpointIndex(b, 0))
+    {
+    }
+
+    Breakpoint * breakpoint()
+    {
+        if (breakpointIndex.isValid()) {
+            return controller->breakpointModel()->breakpoint(breakpointIndex.row());
+        }
+        return nullptr;
+    }
 
     BreakpointController *controller;
-    KDevelop::Breakpoint *breakpoint;
+    QPersistentModelIndex breakpointIndex;
 };
 
 struct UpdateHandler : public Handler
@@ -70,6 +81,10 @@ struct UpdateHandler : public Handler
 
     void handle(const GDBMI::ResultRecord &r)
     {
+        Breakpoint * breakpoint = this->breakpoint();
+        if (!breakpoint)
+            return;
+
         if (r.reason == "error") {
             controller->error(breakpoint, r["msg"].literal(), m_column);
             kWarning() << r["msg"].literal();
@@ -92,39 +107,55 @@ struct InsertedHandler : public Handler
 
     virtual void handle(const GDBMI::ResultRecord &r)
     {
-        kDebug() << controller->m_dirty[breakpoint];
+        Breakpoint * breakpoint = this->breakpoint();
 
         if (r.reason == "error") {
-            controller->error(breakpoint, r["msg"].literal(), KDevelop::Breakpoint::LocationColumn);
-            kWarning() << r["msg"].literal();
+            if (breakpoint) {
+                controller->error(breakpoint, r["msg"].literal(), KDevelop::Breakpoint::LocationColumn);
+                kWarning() << r["msg"].literal();
+            }
         } else {
-            controller->m_errors[breakpoint].remove(KDevelop::Breakpoint::LocationColumn);
-            if (r.hasField("bkpt")) {
-                controller->update(breakpoint, r["bkpt"]);
-            } else if (r.hasField("wpt")) {
-                // For watchpoint creation, GDB basically does not say
-                // anything.  Just record id.
-                controller->m_ids[breakpoint] = r["wpt"]["number"].literal();
-            } else if (r.hasField("hw-rwpt")) {
-                controller->m_ids[breakpoint] = r["hw-rwpt"]["number"].literal();
-            } else if (r.hasField("hw-awpt")) {
-                controller->m_ids[breakpoint] = r["hw-awpt"]["number"].literal();
+            QString id;
+
+            for (auto kind : {"bkpt", "wpt", "hw-rwpt", "hw-awpt"}) {
+                if (r.hasField(kind)) {
+                    id = r[kind]["number"].literal();
+                    break;
+                }
+            }
+            Q_ASSERT(!id.isEmpty());
+
+            if (breakpoint) {
+                controller->m_errors[breakpoint].remove(KDevelop::Breakpoint::LocationColumn);
+                controller->m_ids[breakpoint] = id;
+                if (r.hasField("bkpt")) {
+                    controller->update(breakpoint, r["bkpt"]);
+                }
+                kDebug() << "breakpoint id" << breakpoint << controller->m_ids[breakpoint];
+            } else {
+                // breakpoint was deleted while insertion was in flight
+                controller->debugSession()->addCommandToFront(
+                    new GDBCommand(BreakDelete, id));
             }
-            Q_ASSERT(!controller->m_ids[breakpoint].isEmpty());
-            kDebug() << "breakpoint id" << breakpoint << controller->m_ids[breakpoint];
         }
-        controller->m_dirty[breakpoint].remove(KDevelop::Breakpoint::LocationColumn);
-        controller->breakpointStateChanged(breakpoint);
-        controller->sendMaybe(breakpoint);
+
+        if (breakpoint) {
+            controller->m_dirty[breakpoint].remove(KDevelop::Breakpoint::LocationColumn);
+            controller->breakpointStateChanged(breakpoint);
+            controller->sendMaybe(breakpoint);
+        }
     }
 
     virtual bool handlesError() { return true; }
 };
 
-struct DeletedHandler : public Handler
+struct DeletedHandler : public GDBCommandHandler
 {
     DeletedHandler(BreakpointController *c, KDevelop::Breakpoint *b)
-        : Handler(c, b) {}
+        : controller(c)
+        , breakpoint(b)
+    {
+    }
 
     void handle(const GDBMI::ResultRecord &r)
     {
@@ -137,6 +168,9 @@ struct DeletedHandler : public Handler
             delete breakpoint;
         }
     }
+
+    BreakpointController * controller;
+    Breakpoint * breakpoint;
 };
 
 
@@ -148,7 +182,7 @@ BreakpointController::BreakpointController(DebugSession* parent)
     // a base class that does this connect.
     connect(debugSession(),     SIGNAL(event(IDebugSession::event_t)),
             this,       SLOT(slotEvent(IDebugSession::event_t)));
-    connect(parent, SIGNAL(programStopped(GDBMI::ResultRecord)), SLOT(programStopped(GDBMI::ResultRecord)));
+    connect(parent, SIGNAL(programStopped(GDBMI::AsyncRecord)), SLOT(programStopped(GDBMI::AsyncRecord)));
 }
 
 DebugSession *BreakpointController::debugSession() const
@@ -300,13 +334,16 @@ void BreakpointController::sendMaybe(KDevelop::Breakpoint* breakpoint)
         kDebug() << "deleted";
         m_dirty.remove(breakpoint);
         m_errors.remove(breakpoint);
-        if (m_ids.contains(breakpoint)) { //if id is 0 breakpoint insertion is still pending, InsertedHandler will call sendMaybe again and delete it
+        if (m_ids.contains(breakpoint)) {
             kDebug() << "breakpoint id" << m_ids[breakpoint];
             if (!m_ids[breakpoint].isEmpty()) {
                 debugSession()->addCommandToFront(
                     new GDBCommand(BreakDelete, m_ids[breakpoint],
                                 new DeletedHandler(this, breakpoint)));
                 addedCommand = true;
+            } else {
+                kDebug() << "insertion is still in flight, just delete it";
+                delete breakpoint;
             }
         } else {
             kDebug() << "breakpoint doesn't have yet an id, just delete it";
@@ -459,41 +496,36 @@ void BreakpointController::handleBreakpointList(const GDBMI::ResultRecord &r)
 void BreakpointController::update(KDevelop::Breakpoint *breakpoint, const GDBMI::Value &b)
 {
     m_dontSendChanges++;
-    
+
     m_ids[breakpoint] = b["number"].literal();
 
-    if (b.hasField("original-location")) {
-        if (breakpoint->address().isEmpty()) {
-            /* If the address is not empty, it means that the breakpoint
-               is set by KDevelop, not by the user, and that we want to
-               show the original expression, not the address, in the table.
-               TODO: this also means that if used added a watchpoint in gdb
-               like "watch foo", then we'll show it in the breakpoint table
-               just fine, but after KDevelop restart, we'll try to add the
-               breakpoint using basically "watch *&(foo)".  I'm not sure if
-               that's a problem or not.  */
-            QString location = b["original-location"].literal();
-            kDebug() << "location" << location;
-            if (breakpoint->kind() == KDevelop::Breakpoint::CodeBreakpoint) {
-                QRegExp rx("^(.+):(\\d+)$");
-                if (rx.indexIn(location) != -1) {
-                    breakpoint->setLocation(KUrl(unquoteExpression(rx.cap(1))), rx.cap(2).toInt()-1);
-                } else {
-                    //for regular expression breakpoints and not only...
-                    if(b.hasField("fullname") && b.hasField("line")){
-                        breakpoint->setLocation(KUrl(unquoteExpression(b["fullname"].literal())), b["line"].toInt()-1);
-                    }else{
-                        breakpoint->setData(KDevelop::Breakpoint::LocationColumn, unquoteExpression(location));
-                    }
-                }
-            } else {
-                breakpoint->setData(KDevelop::Breakpoint::LocationColumn, unquoteExpression(location));
-            }
+    /* If the address is not empty, it means that the breakpoint
+        is set by KDevelop, not by the user, and that we want to
+        show the original expression, not the address, in the table.
+        TODO: this also means that if used added a watchpoint in gdb
+        like "watch foo", then we'll show it in the breakpoint table
+        just fine, but after KDevelop restart, we'll try to add the
+        breakpoint using basically "watch *&(foo)".  I'm not sure if
+        that's a problem or not.  */
+    const bool emptyAddress = breakpoint->address().isEmpty();
+    const bool isCodeBreakpoint = breakpoint->kind() == KDevelop::Breakpoint::CodeBreakpoint;
+
+    if (emptyAddress && isCodeBreakpoint && b.hasField("fullname") && b.hasField("line")){
+        breakpoint->setLocation(QUrl::fromLocalFile(unquoteExpression(b["fullname"].literal())),
+                                b["line"].toInt()-1);
+    } else if (emptyAddress && isCodeBreakpoint && b.hasField("original-location")) {
+        QRegExp rx("^(.+):(\\d+)$");
+        QString location = b["original-location"].literal();
+        kDebug() << "location" << location;
+        if (rx.indexIn(location) != -1) {
+            breakpoint->setLocation(KUrl(unquoteExpression(rx.cap(1))), rx.cap(2).toInt()-1);
+        } else {
+            breakpoint->setData(KDevelop::Breakpoint::LocationColumn, unquoteExpression(location));
         }
     } else if (b.hasField("what") && b["what"].literal() == "exception throw") {
         breakpoint->setExpression("catch throw");
     } else {
-        kWarning() << "That's too bad, breakpoint doesn't contain \"original-location\" field ";
+        kWarning() << "Breakpoint doesn't contain required location/expression data: " << m_ids[breakpoint];
     }
 
     if (!m_dirty[breakpoint].contains(KDevelop::Breakpoint::ConditionColumn)
@@ -525,7 +557,7 @@ void BreakpointController::update(KDevelop::Breakpoint *breakpoint, const GDBMI:
     m_dontSendChanges--;
 }
 
-void BreakpointController::programStopped(const GDBMI::ResultRecord& r)
+void BreakpointController::programStopped(const GDBMI::AsyncRecord& r)
 {
     QString reason;
     if (r.hasField("reason")) {
diff --git a/debuggers/gdb/breakpointcontroller.h b/debuggers/gdb/breakpointcontroller.h
index 1b8ae0e..f415922 100644
--- a/debuggers/gdb/breakpointcontroller.h
+++ b/debuggers/gdb/breakpointcontroller.h
@@ -32,6 +32,7 @@
 class QModelIndex;
 
 namespace GDBMI {
+struct AsyncRecord;
 struct ResultRecord;
 struct Value;
 }
@@ -56,9 +57,11 @@ class BreakpointController : public IBreakpointController
 public:
     BreakpointController(DebugSession* parent);
 
-private slots:
+    using IBreakpointController::breakpointModel;
+
+private Q_SLOTS:
     void slotEvent(IDebugSession::event_t);
-    void programStopped(const GDBMI::ResultRecord &r);
+    void programStopped(const GDBMI::AsyncRecord &r);
 
 private:
     DebugSession* debugSession() const;
diff --git a/debuggers/gdb/debuggerplugin.cpp b/debuggers/gdb/debuggerplugin.cpp
index ca2bbaf..a920e55 100644
--- a/debuggers/gdb/debuggerplugin.cpp
+++ b/debuggers/gdb/debuggerplugin.cpp
@@ -137,7 +137,7 @@ private:
 
 CppDebuggerPlugin::CppDebuggerPlugin( QObject *parent, const QVariantList & ) :
     KDevelop::IPlugin( CppDebuggerFactory::componentData(), parent ),
-    m_config(KGlobal::config(), "GDB Debugger"), m_session(0)
+    m_config(KGlobal::config(), "GDB Debugger")
 {
     KDEV_USE_EXTENSION_INTERFACE( KDevelop::IStatus )
     
@@ -177,13 +177,6 @@ CppDebuggerPlugin::CppDebuggerPlugin( QObject *parent, const QVariantList & ) :
         Q_ASSERT(type);
         type->addLauncher( new GdbLauncher( this, iface ) );
     }
-    // The output from tracepoints goes to "application" window, because
-    // we don't have any better alternative, and using yet another window
-    // is undesirable. Besides, this makes tracepoint look even more similar
-    // to printf debugging.
-// PORTING TODO broken - need intermediate signal?
-//     connect( gdbBreakpointWidget,   SIGNAL(tracingOutput(QByteArray)),
-//              procLineMaker,         SLOT(slotReceivedStdout(QByteArray)));
 }
 
 void CppDebuggerPlugin::unload()
@@ -302,16 +295,6 @@ KDevelop::ContextMenuExtension CppDebuggerPlugin::contextMenuExtension( KDevelop
 
     m_contextIdent = econtext->currentWord();
 
-    //bool running = m_session && m_session->isRunning();
-
-    // If debugger is running, we insert items at the top.
-    // The reason is user has explicitly run the debugger, so he's
-    // surely debugging, not editing code or something. So, first
-    // menu items should be about debugging, not some copy/paste/cut
-    // things.
-    //if (!running)
-        //popup->addSeparator();
-
     if (!m_contextIdent.isEmpty())
     {
         // PORTING TODO
diff --git a/debuggers/gdb/debuggerplugin.h b/debuggers/gdb/debuggerplugin.h
index 0ec300a..27c0a93 100644
--- a/debuggers/gdb/debuggerplugin.h
+++ b/debuggers/gdb/debuggerplugin.h
@@ -51,7 +51,6 @@ class ProcessLineMaker;
 
 namespace GDBDebugger
 {
-class GDBBreakpointWidget;
 class FramestackWidget;
 class DisassembleWidget;
 class Breakpoint;
@@ -140,14 +139,8 @@ private:
 
     QString m_contextIdent;
 
-    // Set to true after each debugger restart
-    // Currently used to auto-show variables view
-    // on the first pause.
-    bool justRestarted_;
-
     KConfigGroup m_config;
 
-    DebugSession* m_session;
     DebuggerToolFactory< DisassembleWidget >* disassemblefactory;
     DebuggerToolFactory< GDBOutputWidget >* gdbfactory;
     DebuggerToolFactory< MemoryViewerWidget >* memoryviewerfactory;
diff --git a/debuggers/gdb/debugjob.cpp b/debuggers/gdb/debugjob.cpp
index 2807484..e6d7c8a 100644
--- a/debuggers/gdb/debugjob.cpp
+++ b/debuggers/gdb/debugjob.cpp
@@ -102,7 +102,9 @@ void DebugJob::start()
 
     startOutput();
 
-    m_session->startProgram( m_launchcfg, m_execute );
+    if (!m_session->startProgram( m_launchcfg, m_execute )) {
+        done();
+    }
 }
 
 bool DebugJob::doKill()
diff --git a/debuggers/gdb/debugsession.cpp b/debuggers/gdb/debugsession.cpp
index edc0d34..330d5a7 100644
--- a/debuggers/gdb/debugsession.cpp
+++ b/debuggers/gdb/debugsession.cpp
@@ -28,6 +28,7 @@
 #include <typeinfo>
 
 #include <QtCore/QFileInfo>
+#include <QtCore/QDir>
 #include <QtGui/QApplication>
 #include <QRegExp>
 
@@ -65,8 +66,8 @@ namespace GDBDebugger {
 DebugSession::DebugSession()
     : KDevelop::IDebugSession(),
       m_sessionState(NotStartedState),
-      justRestarted_(false),
       m_config(KGlobal::config(), "GDB Debugger"),
+      m_testing(false),
       commandQueue_(new CommandQueue),
       m_tty(0),
       state_(s_dbgNotStarted|s_appNotStarted),
@@ -107,6 +108,11 @@ DebugSession::~DebugSession()
     delete commandQueue_;
 }
 
+void DebugSession::setTesting(bool testing)
+{
+    m_testing = testing;
+}
+
 KDevelop::IDebugSession::DebuggerState DebugSession::state() const {
     return m_sessionState;
 }
@@ -128,10 +134,6 @@ KDevelop::IFrameStackModel* DebugSession::createFrameStackModel()
 
 void DebugSession::setupController()
 {
-    // variableTree -> gdbBreakpointWidget
-//     connect( variableTree,          SIGNAL(toggleWatchpoint(QString)),
-//              gdbBreakpointWidget,   SLOT(slotToggleWatchpoint(QString)));
-
     // controller -> procLineMaker
     connect( this,            SIGNAL(ttyStdout(QByteArray)),
              m_procLineMaker,         SLOT(slotReceivedStdout(QByteArray)));
@@ -150,73 +152,46 @@ void DebugSession::_gdbStateChanged(DBGStateFlags oldState, DBGStateFlags newSta
 {
     QString message;
 
+    DebuggerState oldSessionState = state();
+    DebuggerState newSessionState = oldSessionState;
     DBGStateFlags changedState = oldState ^ newState;
 
-    if (changedState & s_dbgNotStarted) {
-        if (newState & s_dbgNotStarted) {
+    if (newState & s_dbgNotStarted) {
+        if (changedState & s_dbgNotStarted) {
             message = i18n("Debugger stopped");
-
-        } else {
-            setSessionState(StartingState);
+            emit finished();
         }
-
-        //core()->running(this, false);
-        // TODO enable/disable tool views as applicable
-    }
-
-    // As soon as debugger clears 's_appNotStarted' flag, we
-    // set 'justRestarted' variable.
-    // The other approach would be to set justRestarted in slotRun, slotCore
-    // and slotAttach.
-    // Note that setting this var in startDebugger is not OK, because the
-    // initial state of debugger is exactly the same as state after pause,
-    // so we'll always show varaibles view.
-    if (changedState & s_appNotStarted) {
+        if (oldSessionState != NotStartedState) {
+            newSessionState = EndedState;
+        }
+    } else {
         if (newState & s_appNotStarted) {
-            setSessionState(StoppedState);
-            justRestarted_ = false;
-
+            if (oldSessionState == NotStartedState || oldSessionState == StartingState) {
+                newSessionState = StartingState;
+            } else {
+                newSessionState = StoppedState;
+            }
+        } else if (newState & s_programExited) {
+            if (changedState & s_programExited) {
+                message = i18n("Process exited");
+            }
+            newSessionState = StoppedState;
+        } else if (newState & s_appRunning) {
+            if (changedState & s_appRunning) {
+                message = i18n("Application is running");
+            }
+            newSessionState = ActiveState;
         } else {
-            justRestarted_ = true;
+            if (changedState & s_appRunning) {
+                message = i18n("Application is paused");
+            }
+            newSessionState = PausedState;
         }
     }
 
-    if (changedState & s_explicitBreakInto)
+    if (changedState & s_explicitBreakInto) {
         if (!(newState & s_explicitBreakInto))
             message = i18n("Application interrupted");
-
-    if (changedState & s_programExited) {
-        if (newState & s_programExited) {
-            message = i18n("Process exited");
-            setSessionState(StoppedState);
-        }
-    }
-
-    if (changedState & s_appRunning) {
-        if (newState & s_appRunning) {
-            message = i18n("Application is running");
-            setSessionState(ActiveState);
-        }
-        else
-        {
-            if (!(newState & s_appNotStarted)) {
-                message = i18n("Application is paused");
-                setSessionState(PausedState);
-
-                // On the first stop, show the variables view.
-                // We do it on first stop, and not at debugger start, because
-                // a program might just successfully run till completion. If we show
-                // the var views on start and hide on stop, this will look like flicker.
-                // On the other hand, if application is paused, it's very
-                // likely that the user wants to see variables.
-                if (justRestarted_)
-                {
-                    justRestarted_ = false;
-                    //mainWindow()->setViewAvailable(variableWidget, true);
-                    //FIXME: emit raiseVariableViews();
-                }
-            }
-        }
     }
 
     // And now? :-)
@@ -225,44 +200,55 @@ void DebugSession::_gdbStateChanged(DBGStateFlags oldState, DBGStateFlags newSta
     if (!message.isEmpty())
         emit showMessage(message, 3000);
 
-    if (!(oldState & s_dbgNotStarted) && (newState & s_dbgNotStarted))
-    {
-        emit finished();
-        setSessionState(EndedState); //this will delete the DebugSession, so do it last
-    }
-
     emit gdbStateChanged(oldState, newState);
+
+    // must be last, since it can lead to deletion of the DebugSession
+    if (newSessionState != oldSessionState) {
+        setSessionState(newSessionState);
+    }
 }
 
 void DebugSession::examineCoreFile(const KUrl& debugee, const KUrl& coreFile)
 {
-    setStateOff(s_programExited|s_appNotStarted);
-    setStateOn(s_core);
-
     if (stateIsOn(s_dbgNotStarted))
       startDebugger(0);
 
     // TODO support non-local URLs
     queueCmd(new GDBCommand(GDBMI::FileExecAndSymbols, debugee.toLocalFile()));
-    queueCmd(new GDBCommand(GDBMI::NonMI, "core " + coreFile.toLocalFile()));
+    queueCmd(new GDBCommand(GDBMI::NonMI, "core " + coreFile.toLocalFile(), this, &DebugSession::handleCoreFile, true));
 
     raiseEvent(connected_to_program);
     raiseEvent(program_state_changed);
 }
 
+void DebugSession::handleCoreFile(const GDBMI::ResultRecord& r)
+{
+    if (r.reason != "error") {
+        setStateOn(s_programExited|s_core);
+    } else {
+        KMessageBox::information(
+            qApp->activeWindow(),
+            i18n("<b>Failed to load core file</b>"
+                "<p>Debugger reported the following error:"
+                "<p><tt>%1", r["msg"].literal()),
+            i18n("Debugger error"));
+
+        // How should we proceed at this point? Stop the debugger?
+    }
+}
+
 void DebugSession::attachToProcess(int pid)
 {
     kDebug() << pid;
 
-    setStateOff(s_appNotStarted|s_programExited);
+    if (stateIsOn(s_dbgNotStarted))
+      startDebugger(0);
+
     setStateOn(s_attached);
 
     //set current state to running, after attaching we will get *stopped response
     setStateOn(s_appRunning);
 
-    if (stateIsOn(s_dbgNotStarted))
-      startDebugger(0);
-
     // Currently, we always start debugger with a name of binary,
     // we might be connecting to a different binary completely,
     // so cancel all symbol tables gdb has.
@@ -528,11 +514,6 @@ void DebugSession::addCommandToFront(GDBCommand* cmd)
     queueCmd(cmd, QueueAtFront);
 }
 
-void DebugSession::addCommandBeforeRun(GDBCommand* cmd)
-{
-    queueCmd(cmd, QueueWhileInterrupted);
-}
-
 // Fairly obvious that we'll add whatever command you give me to a queue
 // If you tell me to, I'll put it at the head of the queue so it'll run ASAP
 // Not quite so obvious though is that if we are going to run again. then any
@@ -556,7 +537,7 @@ void DebugSession::queueCmd(GDBCommand *cmd, QueuePosition queue_where)
 
     commandQueue_->enqueue(cmd, queue_where);
 
-    kDebug(9012) << "QUEUE: " << cmd->initialString() << (stateReloadInProgress_ ? "(state reloading)" : "");
+    kDebug(9012) << "QUEUE: " << cmd->initialString() << (stateReloadInProgress_ ? "(state reloading)" : "") << commandQueue_->count() << "pending";
 
     bool varCommandWithContext= (cmd->type() >= GDBMI::VarAssign
                                  && cmd->type() <= GDBMI::VarUpdate
@@ -661,7 +642,7 @@ void DebugSession::destroyCmds()
 }
 
 
-void DebugSession::slotProgramStopped(const GDBMI::ResultRecord& r)
+void DebugSession::slotProgramStopped(const GDBMI::AsyncRecord& r)
 {
     /* By default, reload all state on program stop.  */
     state_reload_needed = true;
@@ -776,6 +757,19 @@ void DebugSession::slotProgramStopped(const GDBMI::ResultRecord& r)
 }
 
 
+void DebugSession::processNotification(const GDBMI::AsyncRecord & async)
+{
+    if (async.reason == "thread-group-started") {
+        setStateOff(s_appNotStarted | s_programExited);
+    } else if (async.reason == "thread-group-exited") {
+        setStateOn(s_programExited);
+    } else if (async.reason == "library-loaded") {
+        // do nothing
+    } else {
+        kDebug(9012) << "Unhandled notification: " << async.reason;
+    }
+}
+
 void DebugSession::reloadProgramState()
 {
     raiseEvent(program_state_changed);
@@ -836,25 +830,6 @@ void DebugSession::programFinished(const QString& msg)
 }
 
 
-void DebugSession::parseStreamRecord(const GDBMI::StreamRecord& s)
-{
-    if (s.reason == '~')
-    {
-        QString line = s.message;
-        if (line.startsWith("Program terminated")) {
-            //when examining core file
-            setStateOff(s_appRunning);
-            setStateOn(s_appNotStarted|s_programExited);
-        } else if (line.startsWith("The program no longer exists")
-                   || line.startsWith("Program exited")) {
-            programNoApp(line);
-        } else if (!line.isEmpty() && line.at(0) == '[' && line.contains(QRegExp("^\\[Inferior \\d+ \\(.*process|target.*\\) exited .*\\]"))) {
-            m_inferiorExitCode = line;
-            addCommand(new CliCommand(GDBMI::NonMI, "info inferiors", this,  &DebugSession::lastInferiorHandler));
-        }
-    }
-}
-
 bool DebugSession::startDebugger(KDevelop::ILaunchConfiguration* cfg)
 {
     kDebug(9012) << "Starting debugger controller";
@@ -886,31 +861,35 @@ bool DebugSession::startDebugger(KDevelop::ILaunchConfiguration* cfg)
 
     connect(gdb, SIGNAL(ready()), this, SLOT(gdbReady()));
     connect(gdb, SIGNAL(gdbExited()), this, SLOT(gdbExited()));
-    connect(gdb, SIGNAL(programStopped(GDBMI::ResultRecord)),
-            this, SLOT(slotProgramStopped(GDBMI::ResultRecord)));
-    connect(gdb, SIGNAL(programStopped(GDBMI::ResultRecord)),
-            this, SIGNAL(programStopped(GDBMI::ResultRecord)));
+    connect(gdb, SIGNAL(programStopped(GDBMI::AsyncRecord)),
+            this, SLOT(slotProgramStopped(GDBMI::AsyncRecord)));
+    connect(gdb, SIGNAL(programStopped(GDBMI::AsyncRecord)),
+            this, SIGNAL(programStopped(GDBMI::AsyncRecord)));
     connect(gdb, SIGNAL(programRunning()),
             this, SLOT(programRunning()));
-
-    connect(gdb, SIGNAL(streamRecord(GDBMI::StreamRecord)),
-            this, SLOT(parseStreamRecord(GDBMI::StreamRecord)));
+    connect(gdb, SIGNAL(notification(GDBMI::AsyncRecord)),
+            this, SLOT(processNotification(GDBMI::AsyncRecord)));
 
     // Start gdb. Do this after connecting all signals so that initial
     // GDB output, and important events like "GDB died" are reported.
 
-
-    if (cfg)
     {
-        KConfigGroup config = cfg->config();
-        m_gdb.data()->start(config);
-    }
-    else
-    {
-        // FIXME: this is hack, I am not sure there's any way presently
-        // to edit this via GUI.
-        KConfigGroup config(KGlobal::config(), "GDB Debugger");
-        m_gdb.data()->start(config);
+        QStringList extraArguments;
+        if (m_testing)
+            extraArguments << "--nx"; // do not load any .gdbinit files
+
+        if (cfg)
+        {
+            KConfigGroup config = cfg->config();
+            m_gdb.data()->start(config, extraArguments);
+        }
+        else
+        {
+            // FIXME: this is hack, I am not sure there's any way presently
+            // to edit this via GUI.
+        	KConfigGroup config(KGlobal::config(), "GDB Debugger");
+            m_gdb.data()->start(config, extraArguments);
+        }
     }
 
     setStateOff(s_dbgNotStarted);
@@ -938,6 +917,10 @@ bool DebugSession::startDebugger(KDevelop::ILaunchConfiguration* cfg)
 
     QString fileName = KStandardDirs::locate("data", "kdevgdb/printers/gdbinit");
     if (!fileName.isEmpty()) {
+        QFileInfo fileInfo(fileName);
+        QString quotedPrintersPath = fileInfo.dir().path().replace('\\', "\\\\").replace('"', "\\\"");
+        queueCmd(new GDBCommand(GDBMI::NonMI,
+            QString("python sys.path.insert(0, \"%0\")").arg(quotedPrintersPath)));
         queueCmd(new GDBCommand(GDBMI::NonMI, "source " + fileName));
     }
 
@@ -951,9 +934,10 @@ bool DebugSession::startProgram(KDevelop::ILaunchConfiguration* cfg, IExecutePlu
         emit showMessage(i18n("Running program"), 1000);
     }
 
-    if (stateIsOn(s_dbgNotStarted))
+    if (stateIsOn(s_dbgNotStarted)) {
         if (!startDebugger(cfg))
             return false;
+    }
 
     if (stateIsOn(s_shuttingDown)) {
         kDebug() << "Tried to run when debugger shutting down";
@@ -1102,8 +1086,6 @@ bool DebugSession::startProgram(KDevelop::ILaunchConfiguration* cfg, IExecutePlu
         queueCmd(new GDBCommand(GDBMI::ExecRun));
     }
 
-    setStateOff(s_appNotStarted|s_programExited);
-
     {
         QString startWith = grp.readEntry(GDBDebugger::startWithEntry, QString("ApplicationOutput"));
         if (startWith == "GdbConsole") {
@@ -1155,8 +1137,6 @@ void DebugSession::slotKill()
     // The -exec-abort is not implemented in gdb
     // queueCmd(new GDBCommand(GDBMI::ExecAbort));
     queueCmd(new GDBCommand(GDBMI::NonMI, "kill"));
-
-    setStateOn(s_appNotStarted);
 }
 
 // **************************************************************************
@@ -1474,22 +1454,6 @@ void DebugSession::handleTargetAttach(const GDBMI::ResultRecord& r)
     }
 }
 
-void DebugSession::lastInferiorHandler(const QStringList& l)
-{
-    //* 1    <null>
-    QRegExp rx("^\\*?\\s+\\d+\\s+\\<null\\>\\s.*$");
-
-    for (int i = 2 ; i < l.size(); i++) {
-        if (!rx.exactMatch(l[i])) {
-            kDebug() << "Still running: " << l[i];
-            return;
-        }
-    }
-    kDebug() << "Exiting";
-    programNoApp(m_inferiorExitCode);
-    state_reload_needed = false;
-}
-
 }
 
 
diff --git a/debuggers/gdb/debugsession.h b/debuggers/gdb/debugsession.h
index 7a1a3d9..146900f 100644
--- a/debuggers/gdb/debugsession.h
+++ b/debuggers/gdb/debugsession.h
@@ -83,7 +83,7 @@ Q_SIGNALS:
     void applicationStandardErrorLines(const QStringList& lines);
     void showMessage(const QString& message, int timeout);
     void reset();
-    void programStopped(const GDBMI::ResultRecord& mi_record);
+    void programStopped(const GDBMI::AsyncRecord& mi_record);
 
 public Q_SLOTS:
     /**
@@ -112,6 +112,13 @@ public Q_SLOTS:
      */
     void attachToProcess(int pid);
 
+protected:
+    /**
+     * Testing mode affects a (very!) limited number of settings in an attempt to create
+     * a cleaner and more reproducible environment for unit tests.
+     */
+    void setTesting(bool testing);
+
 Q_SIGNALS:
     void raiseGdbConsoleViews();
 
@@ -128,11 +135,9 @@ private:
     KDevelop::ProcessLineMaker *m_procLineMaker;
     KDevelop::ProcessLineMaker *m_gdbLineMaker;
     DebuggerState m_sessionState;
-    bool justRestarted_;
     KConfigGroup m_config;
     QWeakPointer<GDB> m_gdb;
-
-
+    bool m_testing;
 
 
 public:
@@ -194,12 +199,6 @@ public:
     */
     void addCommandToFront(GDBCommand* cmd);
 
-    /* If current command queue has any command
-       for which isRun is true, inserts 'cmd'
-       before the first such command. Otherwise,
-       works the same as addCommand. */
-    void addCommandBeforeRun(GDBCommand* cmd);
-
     bool stateIsOn(DBGStateFlags state) const;
     DBGStateFlags debuggerState() const;
 
@@ -244,25 +243,13 @@ private:
 
     bool startDebugger(KDevelop::ILaunchConfiguration* cfg);
 
-    ///Checks if exited inferior is the last one, if so ends the debug session.
-    void lastInferiorHandler(const QStringList& l);
-
 private Q_SLOTS:
 
     void gdbReady();
 
     void gdbExited();
 
-    void slotProgramStopped(const GDBMI::ResultRecord& mi_record);
-
-    /** Parses the CLI output line, and catches interesting messages
-        like "Program exited". This is intended to allow using console
-        commands in the gdb window despite the fact that GDB does not
-        produce right MI notification for CLI commands. I.e. if you
-        run "continue" there will be no MI message if the application has
-        exited.
-    */
-    void parseStreamRecord(const GDBMI::StreamRecord& s);
+    void slotProgramStopped(const GDBMI::AsyncRecord& mi_record);
 
     /** Default handler for errors.
         Tries to guess is the error message is telling that target is
@@ -273,6 +260,9 @@ private Q_SLOTS:
     /**Triggered every time program begins/continues it's execution.*/
     void programRunning();
 
+    /** Handle MI async notifications. */
+    void processNotification(const GDBMI::AsyncRecord& n);
+
     // All of these slots are entered in the controller's thread, as they use queued connections or are called internally
     void queueCmd(GDBCommand *cmd, QueuePosition queue_where = QueueAtEnd);
 
@@ -290,6 +280,7 @@ private Q_SLOTS:
     void handleVersion(const QStringList& s);
     void handleFileExecAndSymbols(const GDBMI::ResultRecord& r);
     void handleTargetAttach(const GDBMI::ResultRecord& r);
+    void handleCoreFile(const GDBMI::ResultRecord& r);
 
 public Q_SLOTS:
     void slotKill();
diff --git a/debuggers/gdb/disassemblewidget.cpp b/debuggers/gdb/disassemblewidget.cpp
index 91194ed..a000f1e 100644
--- a/debuggers/gdb/disassemblewidget.cpp
+++ b/debuggers/gdb/disassemblewidget.cpp
@@ -108,12 +108,50 @@ DisassembleWindow::DisassembleWindow(QWidget *parent, DisassembleWidget* widget)
     connect(m_selectAddrAction, SIGNAL(triggered()), widget, SLOT(slotChangeAddress()));
 
     m_jumpToLocation = new QAction(KIcon("debug-execute-to-cursor"), i18n("&Jump to Cursor"), this);
-    m_jumpToLocation->setWhatsThis(i18n("Sets the execution pointer to the current cursor position."));
+    m_jumpToLocation->setToolTip(i18n("Sets the execution pointer to the current cursor position."));
     connect(m_jumpToLocation,SIGNAL(triggered()), widget, SLOT(jumpToCursor()));
 
     m_runUntilCursor = new QAction(KIcon("debug-run-cursor"), i18n("&Run to Cursor"), this);
-    m_runUntilCursor->setWhatsThis(i18n("Continues execution until the cursor position is reached."));
+    m_runUntilCursor->setToolTip(i18n("Continues execution until the cursor position is reached."));
     connect(m_runUntilCursor,SIGNAL(triggered()), widget, SLOT(runToCursor()));
+
+    m_disassemblyFlavorAtt = new QAction(i18n("&AT&&T"), this);
+    m_disassemblyFlavorAtt->setToolTip(i18n("GDB will use the AT&T disassembly flavor (e.g. mov 0xc(%ebp),%eax)."));
+    m_disassemblyFlavorAtt->setData(DisassemblyFlavorATT);
+    m_disassemblyFlavorAtt->setCheckable(true);
+
+    m_disassemblyFlavorIntel = new QAction(i18n("&Intel"), this);
+    m_disassemblyFlavorIntel->setToolTip(i18n("GDB will use the Intel disassembly flavor (e.g. mov eax, DWORD PTR [ebp+0xc])."));
+    m_disassemblyFlavorIntel->setData(DisassemblyFlavorIntel);
+    m_disassemblyFlavorIntel->setCheckable(true);
+
+    m_disassemblyFlavorActionGroup = new QActionGroup(this);
+    m_disassemblyFlavorActionGroup->setExclusive(true);
+    m_disassemblyFlavorActionGroup->addAction(m_disassemblyFlavorAtt);
+    m_disassemblyFlavorActionGroup->addAction(m_disassemblyFlavorIntel);
+
+    connect(m_disassemblyFlavorActionGroup, SIGNAL(triggered(QAction*)),
+            widget, SLOT(setDisassemblyFlavor(QAction*)));
+    }
+}
+
+void DisassembleWindow::setDisassemblyFlavor(DisassemblyFlavor flavor)
+{
+    switch(flavor)
+    {
+    default:
+    case DisassemblyFlavorUnknown:
+        m_disassemblyFlavorAtt->setChecked(false);
+        m_disassemblyFlavorIntel->setChecked(false);
+        break;
+    case DisassemblyFlavorATT:
+        m_disassemblyFlavorAtt->setChecked(true);
+        m_disassemblyFlavorIntel->setChecked(false);
+        break;
+    case DisassemblyFlavorIntel:
+        m_disassemblyFlavorAtt->setChecked(false);
+        m_disassemblyFlavorIntel->setChecked(true);
+        break;
     }
 }
 
@@ -123,6 +161,9 @@ void DisassembleWindow::contextMenuEvent(QContextMenuEvent *e)
         popup.addAction(m_selectAddrAction);
         popup.addAction(m_jumpToLocation);
         popup.addAction(m_runUntilCursor);
+        QMenu* disassemblyFlavorMenu = popup.addMenu(i18n("Disassembly flavor"));
+        disassemblyFlavorMenu->addAction(m_disassemblyFlavorAtt);
+        disassemblyFlavorMenu->addAction(m_disassemblyFlavorIntel);
         popup.exec(e->globalPos());
 }
 /***************************************************************************/
@@ -284,6 +325,7 @@ void DisassembleWidget::slotActivate(bool activate)
         active_ = activate;
         if (active_)
         {
+            updateDisassemblyFlavor();
             m_registersManager->updateRegisters();
             if (!displayCurrent())
                 disassembleMemoryRegion();
@@ -321,17 +363,16 @@ void DisassembleWidget::disassembleMemoryRegion(const QString& from, const QStri
 
     //only get $pc
     if (from.isEmpty()){
-        s->addCommandToFront(
+        s->addCommand(
                     new GDBCommand(DataDisassemble, "-s \"$pc\" -e \"$pc+1\" -- 0", this, &DisassembleWidget::updateExecutionAddressHandler ) );
     }else{
 
         QString cmd = (to.isEmpty())?
         QString("-s %1 -e \"%1 + 256\" -- 0").arg(from ):
         QString("-s %1 -e %2+1 -- 0").arg(from).arg(to); // if both addr set
-        
-        s->addCommandToFront(
-        new GDBCommand(DataDisassemble, cmd, this, &DisassembleWidget::disassembleMemoryHandler ) );
 
+        s->addCommand(
+            new GDBCommand(DataDisassemble, cmd, this, &DisassembleWidget::disassembleMemoryHandler ) );
    }
 }
 
@@ -405,7 +446,9 @@ void DisassembleWidget::enableControls(bool enabled)
 
 void DisassembleWidget::slotChangeAddress()
 {
-    if(!m_dlg) return;
+    if(!m_dlg) {
+        return;
+    }
     m_dlg->updateOkState();
     
     if (!m_disassembleWindow->selectedItems().isEmpty()) {
@@ -438,6 +481,70 @@ void DisassembleWidget::update(const QString &address)
     m_registersManager->updateRegisters();
 }
 
+void DisassembleWidget::setDisassemblyFlavor(QAction* action)
+{
+    DebugSession* s = qobject_cast<DebugSession*>(KDevelop::ICore::
+            self()->debugController()->currentSession());
+    if(!s || !s->isRunning()) {
+        return;
+    }
+
+    DisassemblyFlavor disassemblyFlavor = static_cast<DisassemblyFlavor>(action->data().toInt());
+    QString cmd;
+    switch(disassemblyFlavor)
+    {
+    default:
+        // unknown flavor, do not build a GDB command
+        break;
+    case DisassemblyFlavorATT:
+        cmd = "disassembly-flavor att";
+        break;
+    case DisassemblyFlavorIntel:
+        cmd = "disassembly-flavor intel";
+        break;
+    }
+    kDebug(9012) << "Disassemble widget set " << cmd;
+
+    if (!cmd.isEmpty()) {
+        s->addCommand(
+                new GDBCommand(GdbSet, cmd, this, &DisassembleWidget::setDisassemblyFlavorHandler));
+    }
+}
+
+void DisassembleWidget::setDisassemblyFlavorHandler(const GDBMI::ResultRecord& r)
+{
+    if (r.reason == "done" && active_) {
+        disassembleMemoryRegion();
+    }
+}
+
+void DisassembleWidget::updateDisassemblyFlavor()
+{
+    DebugSession* s = qobject_cast<DebugSession*>(KDevelop::ICore::
+            self()->debugController()->currentSession());
+    if(!s || !s->isRunning()) {
+        return;
+    }
+
+    s->addCommand(
+                new GDBCommand(GdbShow, "disassembly-flavor", this, &DisassembleWidget::showDisassemblyFlavorHandler));
+}
+
+void DisassembleWidget::showDisassemblyFlavorHandler(const GDBMI::ResultRecord& r)
+{
+    const GDBMI::Value& value = r["value"];
+    kDebug(9012) << "Disassemble widget disassembly flavor" << value.literal();
+
+    DisassemblyFlavor disassemblyFlavor = DisassemblyFlavorUnknown;
+    if (value.literal() == "att") {
+        disassemblyFlavor = DisassemblyFlavorATT;
+    } else if (value.literal() == "intel") {
+        disassemblyFlavor = DisassemblyFlavorIntel;
+    }
+    m_disassembleWindow->setDisassemblyFlavor(disassemblyFlavor);
+}
+
+
 }
 
 #include "disassemblewidget.moc"
diff --git a/debuggers/gdb/disassemblewidget.h b/debuggers/gdb/disassemblewidget.h
index ccffc2f..c4f86dd 100644
--- a/debuggers/gdb/disassemblewidget.h
+++ b/debuggers/gdb/disassemblewidget.h
@@ -75,11 +75,19 @@ private:
 
 class DisassembleWidget;
 
+enum DisassemblyFlavor {
+    DisassemblyFlavorUnknown = -1,
+    DisassemblyFlavorATT = 0,
+    DisassemblyFlavorIntel,
+};
+
 class DisassembleWindow : public QTreeWidget
 {
 public:
     DisassembleWindow(QWidget *parent, DisassembleWidget* widget);
 
+    void setDisassemblyFlavor(DisassemblyFlavor flavor);
+
 protected:
    virtual void contextMenuEvent(QContextMenuEvent *e);
 
@@ -87,6 +95,9 @@ private:
     QAction* m_selectAddrAction;
     QAction* m_jumpToLocation;
     QAction* m_runUntilCursor;
+    QAction* m_disassemblyFlavorAtt;
+    QAction* m_disassemblyFlavorIntel;
+    QActionGroup* m_disassemblyFlavorActionGroup;
 };
 
 class Breakpoint;
@@ -125,6 +136,7 @@ private Q_SLOTS:
     void currentSessionChanged(KDevelop::IDebugSession* session);
     void jumpToCursor();
     void runToCursor();
+    void setDisassemblyFlavor(QAction* action);
 
 protected:
     virtual void showEvent(QShowEvent*);
@@ -133,6 +145,7 @@ protected:
 
 private:
     bool displayCurrent();
+    void updateDisassemblyFlavor();
     
     /// Disassembles memory region from..to
     /// if from is empty current execution position is used
@@ -143,6 +156,8 @@ private:
     /// callbacks for GDBCommands
     void disassembleMemoryHandler(const GDBMI::ResultRecord& r);
     void updateExecutionAddressHandler(const GDBMI::ResultRecord& r);
+    void setDisassemblyFlavorHandler(const GDBMI::ResultRecord& r);
+    void showDisassemblyFlavorHandler(const GDBMI::ResultRecord& r);
 
     //for str to uint conversion.
     bool ok;
@@ -151,10 +166,9 @@ private:
     unsigned long    upper_;
     unsigned long    address_;
 
-    RegistersManager* m_registersManager ;
+    RegistersManager* m_registersManager;
+    DisassembleWindow* m_disassembleWindow;
 
-    DisassembleWindow * m_disassembleWindow;
-    
     static const KIcon icon_;
     SelectAddrDialog* m_dlg;
 
diff --git a/debuggers/gdb/gdb.cpp b/debuggers/gdb/gdb.cpp
index 4642087..3ea9ede 100644
--- a/debuggers/gdb/gdb.cpp
+++ b/debuggers/gdb/gdb.cpp
@@ -44,7 +44,7 @@
 using namespace GDBDebugger;
 
 GDB::GDB(QObject* parent)
-: QObject(parent), process_(0), sawPrompt_(false), currentCmd_(0), receivedReply_(false), isRunning_(false), childPid_(0)
+: QObject(parent), process_(0), currentCmd_(0), isRunning_(false)
 {
 }
 
@@ -59,7 +59,7 @@ GDB::~GDB()
     }
 }
 
-void GDB::start(KConfigGroup& config)
+void GDB::start(KConfigGroup& config, const QStringList& extraArguments)
 {
     // FIXME: verify that default value leads to something sensible
     KUrl gdbUrl = config.readEntry(GDBDebugger::gdbPathEntry, KUrl());
@@ -82,7 +82,7 @@ void GDB::start(KConfigGroup& config)
             SLOT(processErrored(QProcess::ProcessError)));
 
 
-    QStringList arguments;
+    QStringList arguments = extraArguments;
     arguments << "--interpreter=mi2" << "-quiet";
 
     KUrl shell = config.readEntry(GDBDebugger::debuggerShellEntry, KUrl());
@@ -132,11 +132,11 @@ void GDB::execute(GDBCommand* command)
     kDebug(9012) << "SEND:" << commandText;
     
     isRunning_ = false;
-    receivedReply_ = false;
 
     QByteArray commandUtf8 = commandText.toUtf8();
 
     process_->write(commandUtf8, commandUtf8.length());
+    command->markAsSubmitted();
 
     QString prettyCmd = currentCmd_->cmdToSend();
     prettyCmd.remove( QRegExp("set prompt \032.\n") );
@@ -157,9 +157,7 @@ void GDB::interrupt()
 {
     //TODO:win32 Porting needed
     int pid = process_->pid();
-    if (childPid_) {
-        ::kill(childPid_, SIGINT);
-    } else if (pid != 0) {
+    if (pid != 0) {
         ::kill(pid, SIGINT);
     }
 }
@@ -202,11 +200,6 @@ void GDB::readyReadStandardError()
 void GDB::processLine(const QByteArray& line)
 {
     kDebug(9012) << "GDB output: " << line;
-    if(!currentCmd_)
-    {
-        kDebug(9012) << "No current command\n";
-        return;
-    }
 
     FileSymbol file;
     file.contents = line;
@@ -227,145 +220,136 @@ void GDB::processLine(const QByteArray& line)
         return;
     }
 
-   if (!sawPrompt_)
-   {
-       if (r->kind == GDBMI::Record::Stream)
-       {
-           GDBMI::StreamRecord& s = dynamic_cast<GDBMI::StreamRecord&>(*r);
-           emit userCommandOutput(s.message);
-       }
-       else if (r->kind == GDBMI::Record::Prompt)
-       {
-           sawPrompt_ = true;
-       }
-   }
-   else
-   {
-       
-       #ifndef DEBUG_NO_TRY
-       try
-       {
-       #endif
-           switch(r->kind)
-           {
-           case GDBMI::Record::Result: {
-
-               GDBMI::ResultRecord& result = static_cast<GDBMI::ResultRecord&>(*r);
-
-               emit internalCommandOutput(QString::fromUtf8(line) + '\n');
-
-               if (result.reason == "thread-group-started") {
-                   receivedReply_ = true;
-                   //     (gdb) -exec-run
-                   //     =thread-group-started,id="i1",pid="16768"
-                   if (line.contains("pid=\"")) {
-                       QList<QByteArray> splitLine = line.split(',');
-                       if (splitLine.size() > 2) {
-                           QByteArray pidStr = splitLine[2];
-                           pidStr.chop(1);
-                           childPid_ = pidStr.mid(5).toULong();
-                           if (childPid_ == 0) {
-                               kDebug() << "line=" << line << "pidStr=" << pidStr << pidStr.mid(5) << "pid=" << childPid_;
-                           }
-                       }
-                   }
-               }
-
-               // FIXME: the code below should be reviewed to consider result record
-               // subtype when doing all decisions.
-               
-               if (result.subkind == GDBMI::ResultRecord::GeneralNotification)
-               {
-                   kDebug(9012) << "General notification";
-                   emit notification(result);
-                   return;
-               }
-               
-               if (result.reason == "stopped")
-               {
-                   //stopped is *not* a reply, wait for ^running or ^done (running before stopped, done after stopped)
-                   isRunning_ = false;
-                   emit programStopped(result);
-               }
-               else if (result.reason == "running")
-               {
-                   receivedReply_ = true;
-                   isRunning_ = true;
-                   emit programRunning();
-               }
-               else
-               {
-                   receivedReply_ = true;
-               }
-
-               if (result.reason == "done")
-               {
-                   currentCmd_->invokeHandler(result);
-                   emit resultRecord(result);
-               }
-               else if (result.reason == "error")
-               {
-                   kDebug(9012) << "Handling error";
-                   // Some commands want to handle errors themself.
-                   if (currentCmd_->handlesError() &&
-                       currentCmd_->invokeHandler(result))
-                   {
-                       kDebug(9012) << "Invoked custom handler\n";
-                       // Done, nothing more needed
-                   }
-                   else
-                       emit error(result);
-               }
-
-               break;
-           }
-
-           case GDBMI::Record::Stream: {
-
-               GDBMI::StreamRecord& s = dynamic_cast<GDBMI::StreamRecord&>(*r);
-
-               if (s.reason == '@')
-                   emit applicationOutput(s.message);
-
-               if (currentCmd_->isUserCommand())
-                   emit userCommandOutput(s.message);
-               else
-                   emit internalCommandOutput(s.message);
-
-               currentCmd_->newOutput(s.message);
-
-               emit streamRecord(s);
-
-               break;
-           }
-           case GDBMI::Record::Prompt:
-               break;
-           }
-       #ifndef DEBUG_NO_TRY
-       }
-       catch(const std::exception& e)
-       {
-           KMessageBox::detailedSorry(
-               qApp->activeWindow(),
-               i18nc("<b>Internal debugger error</b>",
-                     "<p>The debugger component encountered internal error while "
-                     "processing reply from gdb. Please submit a bug report."),
-               i18n("The exception is: %1\n"
-                    "The MI response is: %2", e.what(),
-                    QString::fromLatin1(line)),
-               i18n("Internal debugger error"));
-            isRunning_ = false;
-            receivedReply_ = true;
-       }
-       #endif
-
-       if (receivedReply_ && !isRunning_)
-       {
-           delete currentCmd_;
-           currentCmd_ = 0;
-           emit ready();
-       }
+    #ifndef DEBUG_NO_TRY
+    try
+    {
+    #endif
+        switch(r->kind)
+        {
+        case GDBMI::Record::Result: {
+            GDBMI::ResultRecord& result = static_cast<GDBMI::ResultRecord&>(*r);
+
+            emit internalCommandOutput(QString::fromUtf8(line) + '\n');
+
+            // GDB doc: "running" and "exit" are status codes equivalent to "done"
+            if (result.reason == "done" || result.reason == "running" || result.reason == "exit")
+            {
+                if (!currentCmd_) {
+                    kDebug(9012) << "Received a result without a pending command";
+                } else {
+                    Q_ASSERT(currentCmd_->token() == result.token);
+                    currentCmd_->markAsCompleted();
+                    kDebug(9012) << "Command successful, times" << currentCmd_->totalProcessingTime() << currentCmd_->queueTime() << currentCmd_->gdbProcessingTime();
+                    currentCmd_->invokeHandler(result);
+                }
+            }
+            else if (result.reason == "error")
+            {
+                kDebug(9012) << "Handling error";
+                currentCmd_->markAsCompleted();
+                kDebug(9012) << "Command error, times" << currentCmd_->totalProcessingTime() << currentCmd_->queueTime() << currentCmd_->gdbProcessingTime();
+                // Some commands want to handle errors themself.
+                if (currentCmd_->handlesError() &&
+                    currentCmd_->invokeHandler(result))
+                {
+                    kDebug(9012) << "Invoked custom handler\n";
+                    // Done, nothing more needed
+                }
+                else
+                    emit error(result);
+            }
+            else
+            {
+                kDebug(9012) << "Unhandled result code: " << result.reason;
+            }
+
+            delete currentCmd_;
+            currentCmd_ = nullptr;
+            emit ready();
+            break;
+        }
+
+        case GDBMI::Record::Async: {
+            GDBMI::AsyncRecord& async = dynamic_cast<GDBMI::AsyncRecord&>(*r);
+
+            switch (async.subkind) {
+            case GDBMI::AsyncRecord::Exec: {
+                // Prefix '*'; asynchronous state changes of the target
+                if (async.reason == "stopped")
+                {
+                    isRunning_ = false;
+                    emit programStopped(async);
+                }
+                else if (async.reason == "running")
+                {
+                    isRunning_ = true;
+                    emit programRunning();
+                }
+                else
+                {
+                    kDebug(9012) << "Unhandled exec notification: " << async.reason;
+                }
+                break;
+            }
+
+            case GDBMI::AsyncRecord::Notify: {
+                // Prefix '='; supplementary information that we should handle (new breakpoint etc.)
+                emit notification(async);
+                break;
+            }
+
+            case GDBMI::AsyncRecord::Status: {
+                // Prefix '+'; GDB documentation:
+                // On-going status information about progress of a slow operation; may be ignored
+                break;
+            }
+
+            default:
+                Q_ASSERT(false);
+            }
+            break;
+        }
+
+        case GDBMI::Record::Stream: {
+
+            GDBMI::StreamRecord& s = dynamic_cast<GDBMI::StreamRecord&>(*r);
+
+            if (s.subkind == GDBMI::StreamRecord::Target) {
+                emit applicationOutput(s.message);
+            } else {
+                if (currentCmd_ && currentCmd_->isUserCommand())
+                    emit userCommandOutput(s.message);
+                else
+                    emit internalCommandOutput(s.message);
+
+                if (currentCmd_)
+                    currentCmd_->newOutput(s.message);
+            }
+
+            emit streamRecord(s);
+
+            break;
+        }
+
+        case GDBMI::Record::Prompt:
+            break;
+        }
+    #ifndef DEBUG_NO_TRY
+    }
+    catch(const std::exception& e)
+    {
+        KMessageBox::detailedSorry(
+            qApp->activeWindow(),
+            i18nc("<b>Internal debugger error</b>",
+                    "<p>The debugger component encountered internal error while "
+                    "processing reply from gdb. Please submit a bug report."),
+            i18n("The exception is: %1\n"
+                "The MI response is: %2", e.what(),
+                QString::fromLatin1(line)),
+            i18n("Internal debugger error"));
+        isRunning_ = false;
     }
+    #endif
 }
 
 // **************************************************************************
diff --git a/debuggers/gdb/gdb.h b/debuggers/gdb/gdb.h
index 31688cd..6c7193b 100644
--- a/debuggers/gdb/gdb.h
+++ b/debuggers/gdb/gdb.h
@@ -45,7 +45,7 @@ public:
 
     /** Starts GDB.  This should be done after connecting to all
         signals the client is interested in.  */
-    void start(KConfigGroup& config);
+    void start(KConfigGroup& config, const QStringList& extraArguments = {});
 
     /** Executes a command.  This method may be called at
         most once each time 'ready' is emitted.  When the
@@ -82,7 +82,7 @@ Q_SIGNALS:
 
     /** Emitted when GDB reports stop, with 'r' being the
         data provided by GDB. */
-    void programStopped(const GDBMI::ResultRecord& r);
+    void programStopped(const GDBMI::AsyncRecord& r);
     
     /** Emitted when GDB believes that the program is running.  */
     void programRunning();
@@ -94,11 +94,8 @@ Q_SIGNALS:
     */
     void streamRecord(const GDBMI::StreamRecord& s);
 
-    /** FIXME: temporary, to be eliminated.  */
-    void resultRecord(const GDBMI::ResultRecord& s);
-    
-    /** Reports a general MI notification.  */
-    void notification(const GDBMI::ResultRecord& n);
+    /** Reports an async notification record.  */
+    void notification(const GDBMI::AsyncRecord& n);
     
     /** Emitted for error that is not handled by the
         command being executed. */
@@ -132,7 +129,6 @@ private:
 private:
     QString gdbBinary_;
     KProcess* process_;
-    bool sawPrompt_;
 
     GDBCommand* currentCmd_;
 
@@ -141,10 +137,8 @@ private:
     /** The unprocessed output from gdb. Output is
         processed as soon as we see newline. */
     QByteArray buffer_;
-    
-    bool receivedReply_;
+
     bool isRunning_;
-    unsigned long childPid_;
 };
 }
 
diff --git a/debuggers/gdb/gdbcommand.cpp b/debuggers/gdb/gdbcommand.cpp
index 67abbd8..817962a 100644
--- a/debuggers/gdb/gdbcommand.cpp
+++ b/debuggers/gdb/gdbcommand.cpp
@@ -14,6 +14,7 @@
  ***************************************************************************/
 
 #include "gdbcommand.h"
+#include <QtCore/QDateTime>
 
 using namespace GDBMI;
 
@@ -21,20 +22,46 @@ namespace GDBDebugger
 {
 
 GDBCommand::GDBCommand(GDBMI::CommandType type, const QString &command)
-: type_(type), command_(command), handler_method(0), commandHandler_(0),
-  run(false), stateReloading_(false), handlesError_(false), m_thread(-1), m_frame(-1)
+    : type_(type)
+    , command_(command)
+    , handler_method(0)
+    , commandHandler_(0)
+    , stateReloading_(false)
+    , handlesError_(false)
+    , m_thread(-1)
+    , m_frame(-1)
+    , m_enqueueTimestamp(0)
+    , m_submitTimestamp(0)
+    , m_completeTimestamp(0)
 {
 }
 
 GDBCommand::GDBCommand(GDBMI::CommandType type, int index)
-: type_(type), command_(QString::number(index)), handler_method(0), commandHandler_(0),
-  run(false), stateReloading_(false), handlesError_(false), m_thread(-1), m_frame(-1)
+    : type_(type)
+    , command_(QString::number(index))
+    , handler_method(0)
+    , commandHandler_(0)
+    , stateReloading_(false)
+    , handlesError_(false)
+    , m_thread(-1)
+    , m_frame(-1)
+    , m_enqueueTimestamp(0)
+    , m_submitTimestamp(0)
+    , m_completeTimestamp(0)
 {
 }
 
 GDBCommand::GDBCommand(CommandType type, const QString& arguments, GDBCommandHandler* handler)
-: type_(type), command_(arguments), handler_method(0), commandHandler_(handler),
-  run(false), stateReloading_(false), m_thread(-1), m_frame(-1)
+    : type_(type)
+    , command_(arguments)
+    , handler_method(0)
+    , commandHandler_(handler)
+    , stateReloading_(false)
+    , m_thread(-1)
+    , m_frame(-1)
+    , m_enqueueTimestamp(0)
+    , m_submitTimestamp(0)
+    , m_completeTimestamp(0)
 {
     handlesError_ = handler->handlesError();
 }
@@ -46,11 +73,13 @@ QString GDBCommand::cmdToSend()
 
 QString GDBCommand::initialString() const
 {
-    if (type() == NonMI)
-        return command_;
-    else
+    QString result = QString::number(token());
+
+    if (type() == NonMI) {
+        result += command_;
+    } else
     {
-        QString result = gdbCommand();
+        result += gdbCommand();
 
         if (m_thread != -1)
             result = result + QString(" --thread %1").arg(m_thread);
@@ -59,9 +88,9 @@ QString GDBCommand::initialString() const
 
         if (!command_.isEmpty())
             result += ' ' + command_;
-        
-        return result;
     }
+
+    return result;
 }
 
 bool GDBCommand::isUserCommand() const
@@ -107,16 +136,6 @@ GDBCommand::~GDBCommand()
 {
 }
 
-bool GDBCommand::isRun() const
-{
-    return run;
-}
-
-void GDBCommand::setRun(bool run)
-{
-    this->run = run;
-}
-
 
 UserCommand::UserCommand(GDBMI::CommandType type, const QString& s)
 : GDBCommand(type, s)
@@ -607,5 +626,34 @@ bool GDBCommand::stateReloading() const
     return stateReloading_;
 }
 
+void GDBCommand::markAsEnqueued()
+{
+    m_enqueueTimestamp = QDateTime::currentMSecsSinceEpoch();
+}
+
+void GDBCommand::markAsSubmitted()
+{
+    m_submitTimestamp = QDateTime::currentMSecsSinceEpoch();
+}
+
+void GDBCommand::markAsCompleted()
+{
+    m_completeTimestamp = QDateTime::currentMSecsSinceEpoch();
+}
+
+qint64 GDBCommand::gdbProcessingTime() const
+{
+    return m_completeTimestamp - m_submitTimestamp;
+}
+
+qint64 GDBCommand::queueTime() const
+{
+    return m_submitTimestamp - m_enqueueTimestamp;
+}
+
+qint64 GDBCommand::totalProcessingTime() const
+{
+    return m_completeTimestamp - m_enqueueTimestamp;
+}
 
 }
diff --git a/debuggers/gdb/gdbcommand.h b/debuggers/gdb/gdbcommand.h
index e1ebc69..aa5e437 100644
--- a/debuggers/gdb/gdbcommand.h
+++ b/debuggers/gdb/gdbcommand.h
@@ -72,6 +72,17 @@ public:
     QString gdbCommand() const;
 
     /**
+     * Returns the MI token with which the command is sent, allowing the parser to match up
+     * the result message with the command.
+     */
+    uint32_t token() const {return token_;}
+
+    /**
+     * Set the MI token. This is done by \ref GDBCommandQueue.
+     */
+    void setToken(uint32_t token) {token_ = token;}
+
+    /**
      * Returns the thread that needs to be currently selected when this command is executed,
      * or -1 if there is no requirement.
      */
@@ -135,28 +146,41 @@ public:
 
     const QStringList& allStreamOutput() const;
 
-    // True if this command run then target for
-    // unspecified period of time -- that is either 'run' or
-    // 'continue'.
-    bool isRun() const;
-
-    void setRun(bool run);
-
     QString command() const;
 
     void setStateReloading(bool f);
 
     bool stateReloading() const;
 
+    /// Called when the command has been enqueued in the debug session
+    /// and the command is wait for being submitted to GDB.
+    void markAsEnqueued();
+
+    /// Called when the command has been submitted to GDB and the command
+    /// waits for completion by GDB.
+    void markAsSubmitted();
+
+    /// Called when the command has been completed and the response has arrived.
+    void markAsCompleted();
+
+    /// returns the amount of time (in ms) passed between submission and completion.
+    qint64 gdbProcessingTime() const;
+
+    /// returns the amount of time (in ms) passed between enqueuing and submission.
+    qint64 queueTime() const;
+
+    /// returns the amount of time (in ms) passed between enqueuing and completion.
+    qint64 totalProcessingTime() const;
+
 private:
     GDBMI::CommandType type_;
+    uint32_t token_;
     QString command_;
     QWeakPointer<QObject> handler_this;
     typedef void (QObject::* handler_t)(const GDBMI::ResultRecord&);
     handler_t handler_method;
     GDBCommandHandler *commandHandler_;
     QStringList lines;
-    bool run;
     bool stateReloading_;
 
 protected: // FIXME: should be private, after I kill the first ctor
@@ -166,6 +190,13 @@ protected: // FIXME: should be private, after I kill the first ctor
 private:
     int m_thread;
     int m_frame;
+    // remember the timestamps (in ms since start of the epoch) when this command
+    // - was added to the command queue (enqueued)
+    // - was submitted to GDB
+    // - was completed; response from GDB arrived
+    qint64 m_enqueueTimestamp;
+    qint64 m_submitTimestamp;
+    qint64 m_completeTimestamp;
 };
 
 class UserCommand : public GDBCommand
@@ -286,7 +317,6 @@ GDBCommand::GDBCommand(
   handler_this(handler_this),
   handler_method(static_cast<handler_t>(handler_method)),
   commandHandler_(0),
-  run(false),
   stateReloading_(false),
   handlesError_(handlesError),
   m_thread(-1),
@@ -302,11 +332,11 @@ GDBCommand::GDBCommand(
     void (Handler::* handler_method)(const GDBMI::ResultRecord&),
     bool handlesError)
 : type_(type),
+  token_(0),
   command_(QString::number(index)),
   handler_this(handler_this),
   handler_method(static_cast<handler_t>(handler_method)),
   commandHandler_(0),
-  run(false),
   stateReloading_(false),
   handlesError_(handlesError),
   m_thread(-1),
diff --git a/debuggers/gdb/gdbcommandqueue.cpp b/debuggers/gdb/gdbcommandqueue.cpp
index 801bc41..8ae7067 100644
--- a/debuggers/gdb/gdbcommandqueue.cpp
+++ b/debuggers/gdb/gdbcommandqueue.cpp
@@ -15,6 +15,8 @@
 // *                                                                        *
 // **************************************************************************
 
+#include <kdebug.h>
+
 #include "gdbcommandqueue.h"
 
 #include "mi/gdbmi.h"
@@ -24,6 +26,7 @@ using namespace GDBDebugger;
 using namespace GDBMI;
 
 CommandQueue::CommandQueue()
+    : m_tokenCounter(0)
 {
 }
 
@@ -32,8 +35,13 @@ CommandQueue::~CommandQueue()
     qDeleteAll(m_commandList);
 }
 
-void GDBDebugger::CommandQueue::enqueue(GDBCommand * command, QueuePosition insertPosition)
+void GDBDebugger::CommandQueue::enqueue(GDBCommand* command, QueuePosition insertPosition)
 {
+    ++m_tokenCounter;
+    if (m_tokenCounter == 0)
+        m_tokenCounter = 1;
+    command->setToken(m_tokenCounter);
+
     switch (insertPosition) {
         case QueueAtFront:
             m_commandList.prepend(command);
@@ -41,25 +49,48 @@ void GDBDebugger::CommandQueue::enqueue(GDBCommand * command, QueuePosition inse
         case QueueAtEnd:
             m_commandList.append(command);
             break;
-
-        case QueueWhileInterrupted: {
-            int i;
-            for (i = 0; i < m_commandList.count(); ++i)
-                if (m_commandList.at(i)->isRun())
-                    break;
-
-            m_commandList.insert(i, command);
-        }
     }
+    // take the time when this command was added to the command queue
+    command->markAsEnqueued();
 
     rationalizeQueue(command);
+    dumpQueue();
 }
 
-void CommandQueue::rationalizeQueue(GDBCommand * command)
+void CommandQueue::dumpQueue()
 {
-    if (command->type() >= ExecAbort && command->type() <= ExecUntil)
+    kDebug(9012) << "Pending commands" << m_commandList.count();
+    unsigned commandNum = 0;
+    foreach(const GDBCommand* command, m_commandList) {
+        kDebug(9012) << "Command" << commandNum << command->initialString();
+        ++commandNum;
+    }
+}
+
+void CommandQueue::rationalizeQueue(GDBCommand* command)
+{
+    if (command->type() >= ExecAbort && command->type() <= ExecUntil) {
+      removeObsoleteExecCommands(command);
       // Changing execution location, abort any variable updates
       removeVariableUpdates();
+      // ... and stack list updates
+      removeStackListUpdates();
+    }
+}
+
+void GDBDebugger::CommandQueue::removeObsoleteExecCommands(GDBCommand* command)
+{
+    if (command->type() == ExecContinue || command->type() == ExecUntil) {
+        // Remove all exec commands up the latest ExecContinue or ExecUntil
+        QMutableListIterator<GDBCommand*> it = m_commandList;
+        while (it.hasNext()) {
+            GDBCommand* currentCmd = it.next();
+            if (currentCmd != command && currentCmd->type() >= ExecAbort && currentCmd->type() <= ExecUntil) {
+                it.remove();
+                delete currentCmd;
+            }
+        }
+    }
 }
 
 void GDBDebugger::CommandQueue::removeVariableUpdates()
@@ -67,9 +98,26 @@ void GDBDebugger::CommandQueue::removeVariableUpdates()
     QMutableListIterator<GDBCommand*> it = m_commandList;
 
     while (it.hasNext()) {
-        CommandType type = it.next()->type();
-        if ((type >= VarEvaluateExpression && type <= VarListChildren) || type == VarUpdate)
+        GDBCommand* command = it.next();
+        CommandType type = command->type();
+        if ((type >= VarEvaluateExpression && type <= VarListChildren) || type == VarUpdate) {
+            it.remove();
+            delete command;
+        }
+    }
+}
+
+void GDBDebugger::CommandQueue::removeStackListUpdates()
+{
+    QMutableListIterator<GDBCommand*> it = m_commandList;
+
+    while (it.hasNext()) {
+        GDBCommand* command = it.next();
+        CommandType type = command->type();
+        if (type >= StackListArguments && type <= StackListLocals) {
             it.remove();
+            delete command;
+        }
     }
 }
 
@@ -89,7 +137,7 @@ bool GDBDebugger::CommandQueue::isEmpty() const
     return m_commandList.isEmpty();
 }
 
-GDBCommand * GDBDebugger::CommandQueue::nextCommand()
+GDBCommand* GDBDebugger::CommandQueue::nextCommand()
 {
     if (!m_commandList.isEmpty())
         return m_commandList.takeAt(0);
diff --git a/debuggers/gdb/gdbcommandqueue.h b/debuggers/gdb/gdbcommandqueue.h
index 7d82f45..8535d40 100644
--- a/debuggers/gdb/gdbcommandqueue.h
+++ b/debuggers/gdb/gdbcommandqueue.h
@@ -46,9 +46,13 @@ public:
 
 private:
     void rationalizeQueue(GDBCommand* command);
+    void removeObsoleteExecCommands(GDBCommand* command);
     void removeVariableUpdates();
+    void removeStackListUpdates();
+    void dumpQueue();
   
     QList<GDBCommand*> m_commandList;
+    uint32_t m_tokenCounter;
 };
 
 }
diff --git a/debuggers/gdb/gdbframestackmodel.cpp b/debuggers/gdb/gdbframestackmodel.cpp
index e9e1fce..d10e004 100644
--- a/debuggers/gdb/gdbframestackmodel.cpp
+++ b/debuggers/gdb/gdbframestackmodel.cpp
@@ -22,6 +22,8 @@
 #include "gdbframestackmodel.h"
 #include "gdbcommand.h"
 
+#include <KLocalizedString>
+
 using namespace KDevelop;
 
 QString getFunctionOrAddress(const GDBMI::Value &frame)
@@ -67,8 +69,13 @@ void GdbFrameStackModel::handleThreadInfo(const GDBMI::ResultRecord& r)
     int gidx = threads.size()-1;
     for (; gidx >= 0; --gidx) {
         KDevelop::FrameStackModel::ThreadItem i;
-        i.nr = threads[gidx]["id"].toInt();
-        i.name = getFunctionOrAddress(threads[gidx]["frame"]);
+        const GDBMI::Value & threadMI = threads[gidx];
+        i.nr = threadMI["id"].toInt();
+        if (threadMI["state"].literal() == "stopped") {
+            i.name = getFunctionOrAddress(threads[gidx]["frame"]);
+        } else {
+            i.name = i18n("(running)");
+        }
         threadsList << i;
     }
     setThreads(threadsList);
diff --git a/debuggers/gdb/gdbglobal.h b/debuggers/gdb/gdbglobal.h
index ef31c02..da6fe32 100644
--- a/debuggers/gdb/gdbglobal.h
+++ b/debuggers/gdb/gdbglobal.h
@@ -43,12 +43,10 @@ enum DBGStateFlag
 };
 
 Q_DECLARE_FLAGS(DBGStateFlags, DBGStateFlag)
-Q_DECLARE_OPERATORS_FOR_FLAGS(DBGStateFlags)
 
 enum QueuePosition {
     QueueAtEnd,
-    QueueAtFront,
-    QueueWhileInterrupted
+    QueueAtFront
 };
 
 
@@ -58,4 +56,6 @@ enum DataType { typeUnknown, typeValue, typePointer, typeReference,
 
 }
 
+Q_DECLARE_OPERATORS_FOR_FLAGS(GDBDebugger::DBGStateFlags)
+
 #endif
diff --git a/debuggers/gdb/gdblaunchconfig.cpp b/debuggers/gdb/gdblaunchconfig.cpp
index 7200998..3937f71 100644
--- a/debuggers/gdb/gdblaunchconfig.cpp
+++ b/debuggers/gdb/gdblaunchconfig.cpp
@@ -32,6 +32,7 @@
 #include <kparts/mainwindow.h>
 
 #include <outputview/outputmodel.h>
+#include <interfaces/idebugcontroller.h>
 #include <interfaces/ilaunchconfiguration.h>
 #include <util/environmentgrouplist.h>
 #include <interfaces/iproject.h>
@@ -146,9 +147,18 @@ KJob* GdbLauncher::start(const QString& launchMode, KDevelop::ILaunchConfigurati
     }
     if( launchMode == "debug" )
     {
-        QList<KJob*> l;
         Q_ASSERT(m_execute);
-        QString err;
+
+        if (KDevelop::ICore::self()->debugController()->currentSession() != nullptr) {
+            int answer = KMessageBox::warningYesNo(
+                nullptr,
+                i18n("A program is already being debugged. Do you want to abort the "
+                     "currently running debug session and continue with the launch?"));
+            if (answer == KMessageBox::No)
+                return nullptr;
+        }
+
+        QList<KJob*> l;
         KJob* depjob = m_execute->dependecyJob(cfg);
         if( depjob ) 
         {
diff --git a/debuggers/gdb/memviewdlg.cpp b/debuggers/gdb/memviewdlg.cpp
index cf9d0b4..ba88d51 100644
--- a/debuggers/gdb/memviewdlg.cpp
+++ b/debuggers/gdb/memviewdlg.cpp
@@ -153,6 +153,7 @@ namespace GDBDebugger
     void MemoryView::initWidget()
     {
         QVBoxLayout *l = new QVBoxLayout(this);
+        l->setContentsMargins(0, 0, 0, 0);
 
         khexedit2_widget = KHE::createBytesEditWidget(this);
         if (!khexedit2_widget)
@@ -236,9 +237,11 @@ namespace GDBDebugger
             KDevelop::ICore::self()->debugController()->currentSession());
         if (!session) return;
 
-        session->addCommand(new ExpressionValueCommand(
-                rangeSelector_->amountLineEdit->text(),
-                this, &MemoryView::sizeComputed));
+        QString amount = rangeSelector_->amountLineEdit->text();
+        if(amount.isEmpty())
+            amount = QString("sizeof(%1)").arg(rangeSelector_->startAddressLineEdit->text());
+
+        session->addCommand(new ExpressionValueCommand(amount, this, &MemoryView::sizeComputed));
     }
 
     void MemoryView::sizeComputed(const QString& size)
@@ -463,9 +466,7 @@ namespace GDBDebugger
     {
         bool app_started = !(debuggerState_ & s_appNotStarted);
 
-        bool enabled_ = app_started &&
-            !rangeSelector_->startAddressLineEdit->text().isEmpty() &&
-            !rangeSelector_->amountLineEdit->text().isEmpty();
+        bool enabled_ = app_started && !rangeSelector_->startAddressLineEdit->text().isEmpty();
 
         rangeSelector_->okButton->setEnabled(enabled_);
     }
@@ -486,10 +487,14 @@ namespace GDBDebugger
         addAction(newMemoryViewerAction);
 
         QVBoxLayout *l = new QVBoxLayout(this);
+        l->setContentsMargins(0, 0, 0, 0);
 
         toolBox_ = new QToolBox(this);
+        toolBox_->setContentsMargins(0, 0, 0, 0);
         l->addWidget(toolBox_);
 
+        setLayout(l);
+
         // Start with one empty memory view.
         slotAddMemoryView();
     }
diff --git a/debuggers/gdb/mi/gdbmi.h b/debuggers/gdb/mi/gdbmi.h
index d5e92b8..4a81a8a 100644
--- a/debuggers/gdb/mi/gdbmi.h
+++ b/debuggers/gdb/mi/gdbmi.h
@@ -338,7 +338,6 @@ namespace GDBMI
         const Value& operator[](int index) const;
 
         QList<Result*> results;
-
     };
 
     struct Record
@@ -346,19 +345,42 @@ namespace GDBMI
         virtual ~Record() {}
         virtual QString toString() const { Q_ASSERT( 0 ); return QString::null; }
 
-        enum { Prompt, Stream, Result } kind;
+        enum { Prompt, Stream, Result, Async } kind;
+    };
+
+    struct TupleRecord : public Record, public TupleValue
+    {
     };
 
-    struct ResultRecord : public Record, public TupleValue
+    struct ResultRecord : public TupleRecord
     {
-        ResultRecord()
-            : subkind(CommandResult)
+        ResultRecord(const QString& reason)
+            : token(0)
+            , reason(reason)
         {
             Record::kind = Result;
         }
         
-        enum { CommandResult, ExecNotification, StatusNotification, GeneralNotification } subkind;
+        uint32_t token;
+        QString reason;
+    };
 
+    struct AsyncRecord : public TupleRecord
+    {
+        enum Subkind {
+            Exec,
+            Status,
+            Notify
+        };
+
+        AsyncRecord(Subkind subkind, const QString& reason)
+            : subkind(subkind)
+            , reason(reason)
+        {
+            Record::kind = Async;
+        }
+
+        Subkind subkind;
         QString reason;
     };
 
@@ -372,9 +394,25 @@ namespace GDBMI
 
     struct StreamRecord : public Record
     {
-        inline StreamRecord() : reason(0) { Record::kind = Stream; }
+        enum Subkind {
+            /// Console stream: usual CLI output of GDB in response to non-MI commands
+            Console,
+
+            /// Target output stream (stdout/stderr of the inferior process, only in some
+            /// scenarios - usually we get stdout/stderr via other means)
+            Target,
+
+            /// Log stream: GDB internal messages that should be displayed as part of an error log
+            Log
+        };
+
+        StreamRecord(Subkind subkind)
+            : subkind(subkind)
+        {
+            Record::kind = Stream;
+        }
 
-        char reason;
+        Subkind subkind;
         QString message;
     };
 }
diff --git a/debuggers/gdb/mi/miparser.cpp b/debuggers/gdb/mi/miparser.cpp
index 123c97e..d5ba205 100644
--- a/debuggers/gdb/mi/miparser.cpp
+++ b/debuggers/gdb/mi/miparser.cpp
@@ -21,7 +21,6 @@
  ***************************************************************************/
 #include "miparser.h"
 #include "tokens.h"
-#include <memory>
 
 using namespace GDBMI;
 
@@ -37,6 +36,18 @@ using namespace GDBMI;
       m_lex->nextToken(); \
   } while (0)
 
+#define MATCH_PTR(tok) \
+  do { \
+      if (m_lex->lookAhead(0) != (tok)) \
+          return {}; \
+  } while (0)
+
+#define ADVANCE_PTR(tok) \
+  do { \
+      MATCH_PTR(tok); \
+      m_lex->nextToken(); \
+  } while (0)
+
 MIParser::MIParser()
     : m_lex(0)
 {
@@ -46,117 +57,119 @@ MIParser::~MIParser()
 {
 }
 
-Record *MIParser::parse(FileSymbol *file)
+std::unique_ptr<Record> MIParser::parse(FileSymbol *file)
 {
     m_lex = 0;
 
-    Record *record = 0;
-
     TokenStream *tokenStream = m_lexer.tokenize(file);
     if (!tokenStream)
         return 0;
 
     m_lex = file->tokenStream = tokenStream;
 
+    uint32_t token = 0;
+    if (m_lex->lookAhead() == Token_number_literal) {
+        token = QString::fromUtf8(m_lex->currentTokenText()).toUInt();
+        m_lex->nextToken();
+    }
+
+    std::unique_ptr<Record> record;
+
     switch (m_lex->lookAhead()) {
         case '~':
         case '@':
         case '&':
-            parseStreamRecord(record);
+            record = parseStreamRecord();
             break;
         case '(':
-            parsePrompt(record);
+            record = parsePrompt();
             break;
         case '^':
-            parseResultRecord(record);
-            break;
         case '*':
-            // Same as result, only differs in start
-            // marker.
-            parseResultRecord(record);
-            break;
         case '=':
-            parseResultRecord(record);
+        case '+':
+            record = parseResultOrAsyncRecord();
             break;
         default:
             break;
     }
 
+    if (record && record->kind == Record::Result) {
+        ResultRecord * result = static_cast<ResultRecord *>(record.get());
+        result->token = token;
+    } else {
+        Q_ASSERT(token == 0);
+    }
+
     return record;
 }
 
-bool MIParser::parsePrompt(Record *&record)
+std::unique_ptr<Record> MIParser::parsePrompt()
 {
-    ADVANCE('(');
-    MATCH(Token_identifier);
+    ADVANCE_PTR('(');
+    MATCH_PTR(Token_identifier);
     if (m_lex->currentTokenText() != "gdb")
-        return false;
+        return {};
     m_lex->nextToken();
-    ADVANCE(')');
+    ADVANCE_PTR(')');
 
-    record = new PromptRecord;
-    return true;
+    return std::unique_ptr<Record>(new PromptRecord);
 }
 
-bool MIParser::parseStreamRecord(Record *&record)
+std::unique_ptr<Record> MIParser::parseStreamRecord()
 {
-    std::unique_ptr<StreamRecord> stream(new StreamRecord);
+    StreamRecord::Subkind subkind;
 
     switch (m_lex->lookAhead()) {
-        case '~':
-        case '@':
-        case '&': {
-            stream->reason = m_lex->lookAhead();
-            m_lex->nextToken();
-            MATCH(Token_string_literal);
-            stream->message = parseStringLiteral();
-            record = stream.release();
-        }
-        return true;
-
-        default:
-            break;
+    case '~': subkind = StreamRecord::Console; break;
+    case '@': subkind = StreamRecord::Target; break;
+    case '&': subkind = StreamRecord::Log; break;
+    default:
+        Q_ASSERT(false);
+        return {};
     }
 
-    return false;
+    std::unique_ptr<StreamRecord> stream(new StreamRecord(subkind));
+
+    m_lex->nextToken();
+    MATCH_PTR(Token_string_literal);
+    stream->message = parseStringLiteral();
+    return std::move(stream);
 }
 
-bool MIParser::parseResultRecord(Record *&record)
+std::unique_ptr<Record> MIParser::parseResultOrAsyncRecord()
 {
+    std::unique_ptr<TupleRecord> result;
+
     char c = m_lex->lookAhead();
-    if (c != '^' && c != '*' && c != '=' && c != '+')
-        return false;
     m_lex->nextToken();
-
-    MATCH(Token_identifier);
+    MATCH_PTR(Token_identifier);
     QString reason = m_lex->currentTokenText();
     m_lex->nextToken();
 
-    std::unique_ptr<ResultRecord> res(new ResultRecord);
-    res->reason = reason;
-    if (c == '^')
-        res->subkind = ResultRecord::CommandResult;
-    else if (c == '*')
-        res->subkind = ResultRecord::ExecNotification;
-    else if (c == '+')
-        res->subkind = ResultRecord::StatusNotification;
-    else {
-        Q_ASSERT(c == '=');
-        res->subkind = ResultRecord::GeneralNotification;        
-    }
-                
-    if (m_lex->lookAhead() != ',') {
-        record = res.release();
-        return true;
+    if (c == '^') {
+        result.reset(new ResultRecord(reason));
+    } else {
+        AsyncRecord::Subkind subkind;
+        switch (c) {
+        case '*': subkind = AsyncRecord::Exec; break;
+        case '=': subkind = AsyncRecord::Notify; break;
+        case '+': subkind = AsyncRecord::Status; break;
+        default:
+            Q_ASSERT(false);
+            return {};
+        }
+        result.reset(new AsyncRecord(subkind, reason));
     }
 
-    m_lex->nextToken();
-    
-    if (!parseCSV(*res))
-        return false;
+    if (m_lex->lookAhead() == ',') {
+        m_lex->nextToken();
 
-    record = res.release();
-    return true;
+        if (!parseCSV(*result))
+            return {};
+    }
+
+    return std::move(result);
 }
 
 bool MIParser::parseResult(Result *&result)
diff --git a/debuggers/gdb/mi/miparser.h b/debuggers/gdb/mi/miparser.h
index 7096af0..e01c314 100644
--- a/debuggers/gdb/mi/miparser.h
+++ b/debuggers/gdb/mi/miparser.h
@@ -20,6 +20,8 @@
 #ifndef MIPARSER_H
 #define MIPARSER_H
 
+#include <memory>
+
 #include "milexer.h"
 #include "gdbmi.h"
 
@@ -34,12 +36,12 @@ public:
     MIParser();
     ~MIParser();
 
-    GDBMI::Record *parse(FileSymbol *file);
+    std::unique_ptr<GDBMI::Record> parse(FileSymbol *file);
 
 protected: // rules
-    bool parseResultRecord(GDBMI::Record *&record);
-    bool parsePrompt(GDBMI::Record *&record);
-    bool parseStreamRecord(GDBMI::Record *&record);
+    std::unique_ptr<GDBMI::Record> parseResultOrAsyncRecord();
+    std::unique_ptr<GDBMI::Record> parsePrompt();
+    std::unique_ptr<GDBMI::Record> parseStreamRecord();
 
     bool parseResult(GDBMI::Result *&result);
     bool parseValue(GDBMI::Value *&value);
diff --git a/debuggers/gdb/printers/CMakeLists.txt b/debuggers/gdb/printers/CMakeLists.txt
index f772c8a..cfc0b85 100644
--- a/debuggers/gdb/printers/CMakeLists.txt
+++ b/debuggers/gdb/printers/CMakeLists.txt
@@ -1,7 +1,4 @@
 add_subdirectory(tests)
 
-configure_file( gdbinit ${CMAKE_CURRENT_BINARY_DIR}/gdbinit )
-
-install( FILES helper.py qt4.py kde4.py
-    ${CMAKE_CURRENT_BINARY_DIR}/gdbinit
+install( FILES helper.py qt4.py kde4.py gdbinit
     DESTINATION ${DATA_INSTALL_DIR}/kdevgdb/printers )
diff --git a/debuggers/gdb/printers/gdbinit b/debuggers/gdb/printers/gdbinit
index c82ac97..787cad6 100644
--- a/debuggers/gdb/printers/gdbinit
+++ b/debuggers/gdb/printers/gdbinit
@@ -1,6 +1,4 @@
 python
-import sys
-sys.path.insert(0, '${DATA_INSTALL_DIR}/kdevgdb/printers')
 
 from qt4 import register_qt4_printers
 register_qt4_printers (None)
diff --git a/debuggers/gdb/unittests/gdb_script_empty b/debuggers/gdb/unittests/gdb_script_empty
new file mode 100644
index 0000000..ffa43c0
--- /dev/null
+++ b/debuggers/gdb/unittests/gdb_script_empty
@@ -0,0 +1 @@
+# Dummy script used for testing purposes
diff --git a/debuggers/gdb/unittests/gdbtest.cpp b/debuggers/gdb/unittests/gdbtest.cpp
index ef3cd42..82f080c 100644
--- a/debuggers/gdb/unittests/gdbtest.cpp
+++ b/debuggers/gdb/unittests/gdbtest.cpp
@@ -67,11 +67,35 @@ KUrl findExecutable(const QString& name)
 
 QString findSourceFile(const QString& name)
 {
-    QFileInfo info(QFileInfo(__FILE__).dir().path() + '/' + name);
+    QFileInfo info(QFileInfo(__FILE__).dir().absoluteFilePath(name));
     Q_ASSERT(info.exists());
     return info.canonicalFilePath();
 }
 
+static bool isAttachForbidden(const char * file, int line)
+{
+    // if on linux, ensure we can actually attach
+    QFile canRun("/proc/sys/kernel/yama/ptrace_scope");
+    if (canRun.exists()) {
+        if (!canRun.open(QIODevice::ReadOnly)) {
+            QTest::qFail("Something is wrong: /proc/sys/kernel/yama/ptrace_scope exists but cannot be read", file, line);
+            return true;
+        }
+        if (canRun.read(1).toInt() != 0) {
+            QTest::qSkip("ptrace attaching not allowed, skipping test. To enable it, set /proc/sys/kernel/yama/ptrace_scope to 0.", QTest::SkipSingle, file, line);
+            return true;
+        }
+    }
+
+    return false;
+}
+
+#define SKIP_IF_ATTACH_FORBIDDEN() \
+    do { \
+        if (isAttachForbidden(__FILE__, __LINE__)) \
+            return; \
+    } while(0)
+
 void GdbTest::initTestCase()
 {
     AutoTestShell::init();
@@ -159,6 +183,7 @@ public:
     {
         qRegisterMetaType<KUrl>("KUrl");
         
+        setTesting(true);
         KDevelop::ICore::self()->debugController()->addSession(this);
     }
     
@@ -175,13 +200,62 @@ public:
 
 };
 
+class TestWaiter
+{
+public:
+    TestWaiter(DebugSession * session_, const char * condition_, const char * file_, int line_)
+        : session(session_)
+        , condition(condition_)
+        , file(file_)
+        , line(line_)
+    {
+        stopWatch.start();
+    }
+
+    bool waitUnless(bool ok)
+    {
+        if (ok) {
+            qDebug() << "Condition " << condition << " reached in " << file << ':' << line;
+            return false;
+        }
+
+        if (stopWatch.elapsed() > 5000) {
+            QTest::qFail(qPrintable(QString("Timeout before reaching condition %0").arg(condition)),
+                file, line);
+            return false;
+        }
+
+        QTest::qWait(100);
+
+        if (!session) {
+            QTest::qFail(qPrintable(QString("Session ended without reaching condition %0").arg(condition)),
+                file, line);
+            return false;
+        }
+
+        return true;
+    }
+
+private:
+    QTime stopWatch;
+    QPointer<DebugSession> session;
+    const char * condition;
+    const char * file;
+    int line;
+};
 
 #define WAIT_FOR_STATE(session, state) \
     waitForState((session), (state), __FILE__, __LINE__)
 
-#define WAIT_FOR_STATE_FAIL(session, state) \
+#define WAIT_FOR_STATE_AND_IDLE(session, state) \
     waitForState((session), (state), __FILE__, __LINE__, true)
 
+#define WAIT_FOR(session, condition) \
+    do { \
+        TestWaiter w((session), #condition, __FILE__, __LINE__); \
+        while (w.waitUnless((condition))) /* nothing */ ; \
+    } while(0)
+
 #define COMPARE_DATA(index, expected) \
     compareData((index), (expected), __FILE__, __LINE__)
 void compareData(QModelIndex index, QString expected, const char *file, int line)
@@ -224,17 +298,19 @@ void GdbTest::testBreakpoint()
     TestLaunchConfiguration cfg;
 
     KDevelop::Breakpoint * b = breakpoints()->addCodeBreakpoint(debugeeFileName, 28);
-    QCOMPARE(session->breakpointController()->breakpointState(b), KDevelop::Breakpoint::NotStartedState);
+    QCOMPARE(b->state(), KDevelop::Breakpoint::NotStartedState);
 
     session->startProgram(&cfg, m_iface);
     WAIT_FOR_STATE(session, DebugSession::PausedState);
-    QCOMPARE(session->breakpointController()->breakpointState(b), KDevelop::Breakpoint::CleanState);
+    QCOMPARE(b->state(), KDevelop::Breakpoint::CleanState);
     session->stepInto();
     WAIT_FOR_STATE(session, DebugSession::PausedState);
     session->stepInto();
     WAIT_FOR_STATE(session, DebugSession::PausedState);
     session->run();
     WAIT_FOR_STATE(session, DebugSession::EndedState);
+
+    QCOMPARE(b->state(), KDevelop::Breakpoint::NotStartedState);
 }
 
 void GdbTest::testDisableBreakpoint()
@@ -267,7 +343,7 @@ void GdbTest::testDisableBreakpoint()
 
 
     session->startProgram(&cfg, m_iface);
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
 
     QCOMPARE(session->currentLine(), thirdBreak->line());
 
@@ -293,7 +369,7 @@ void GdbTest::testChangeLocationBreakpoint()
     KDevelop::Breakpoint *b = breakpoints()->addCodeBreakpoint(debugeeFileName, 27);
 
     session->startProgram(&cfg, m_iface);
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 27);
 
     QTest::qWait(100);
@@ -334,9 +410,8 @@ void GdbTest::testDeleteBreakpoint()
     breakpoints()->addCodeBreakpoint(debugeeFileName, 22);
 
     session->startProgram(&cfg, m_iface);
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     breakpoints()->removeRow(0);
-    QTest::qWait(100);
     session->run();
 
     WAIT_FOR_STATE(session, DebugSession::EndedState);
@@ -350,11 +425,11 @@ void GdbTest::testPendingBreakpoint()
     breakpoints()->addCodeBreakpoint(debugeeFileName, 28);
 
     KDevelop::Breakpoint * b = breakpoints()->addCodeBreakpoint(findSourceFile("/gdbtest.cpp"), 10);
-    QCOMPARE(session->breakpointController()->breakpointState(b), KDevelop::Breakpoint::NotStartedState);
+    QCOMPARE(b->state(), KDevelop::Breakpoint::NotStartedState);
 
     session->startProgram(&cfg, m_iface);
     WAIT_FOR_STATE(session, DebugSession::PausedState);
-    QCOMPARE(session->breakpointController()->breakpointState(b), KDevelop::Breakpoint::PendingState);
+    QCOMPARE(b->state(), KDevelop::Breakpoint::PendingState);
     session->run();
     WAIT_FOR_STATE(session, DebugSession::EndedState);
 }
@@ -389,18 +464,19 @@ void GdbTest::testIgnoreHitsBreakpoint()
     TestDebugSession *session = new TestDebugSession;
     TestLaunchConfiguration cfg;
 
-    KDevelop::Breakpoint * b = breakpoints()->addCodeBreakpoint(debugeeFileName, 21);
-    b->setIgnoreHits(1);
+    KDevelop::Breakpoint * b1 = breakpoints()->addCodeBreakpoint(debugeeFileName, 21);
+    b1->setIgnoreHits(1);
 
-    b = breakpoints()->addCodeBreakpoint(debugeeFileName, 22);
+    KDevelop::Breakpoint * b2 = breakpoints()->addCodeBreakpoint(debugeeFileName, 22);
 
     session->startProgram(&cfg, m_iface);
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
-    QTest::qWait(100);
-    b->setIgnoreHits(1);
+    //WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR(session, session->state() == DebugSession::PausedState && b2->hitCount() == 1);
+    b2->setIgnoreHits(1);
     session->run();
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    //WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR(session, session->state() == DebugSession::PausedState && b1->hitCount() == 1);
     session->run();
     WAIT_FOR_STATE(session, DebugSession::EndedState);
 }
@@ -420,8 +496,7 @@ void GdbTest::testConditionBreakpoint()
 
     session->startProgram(&cfg, m_iface);
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
-    QCOMPARE(session->line(), 24);
+    WAIT_FOR(session, session->state() == DebugSession::PausedState && session->line() == 24);
     b->setCondition("i == 0");
     QTest::qWait(100);
     session->run();
@@ -443,7 +518,7 @@ void GdbTest::testBreakOnWriteBreakpoint()
 
     session->startProgram(&cfg, m_iface);
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 24);
     
     breakpoints()->addWatchpoint("i");
@@ -468,7 +543,7 @@ void GdbTest::testBreakOnWriteWithConditionBreakpoint()
 
     session->startProgram(&cfg, m_iface);
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 24);
 
     KDevelop::Breakpoint *b = breakpoints()->addWatchpoint("i");
@@ -513,7 +588,7 @@ void GdbTest::testBreakOnReadBreakpoint2()
 
     session->startProgram(&cfg, m_iface);
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 24);
 
     breakpoints()->addReadWatchpoint("i");
@@ -539,7 +614,7 @@ void GdbTest::testBreakOnAccessBreakpoint()
 
     session->startProgram(&cfg, m_iface);
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 24);
 
     breakpoints()->addAccessWatchpoint("i");
@@ -617,7 +692,7 @@ void GdbTest::testInsertBreakpointFunctionName()
     breakpoints()->addCodeBreakpoint("main");
 
     session->startProgram(&cfg, m_iface);
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 27);
     session->run();
     WAIT_FOR_STATE(session, DebugSession::EndedState);
@@ -667,13 +742,12 @@ void GdbTest::testStack()
     
     breakpoints()->addCodeBreakpoint(debugeeFileName, 21);
     QVERIFY(session->startProgram(&cfg, m_iface));
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
 
     QModelIndex tIdx = stackModel->index(0,0);    
     QCOMPARE(stackModel->rowCount(QModelIndex()), 1);
     QCOMPARE(stackModel->columnCount(QModelIndex()), 3);
     COMPARE_DATA(tIdx, "#1 at foo");
-    
 
     QCOMPARE(stackModel->rowCount(tIdx), 2);
     QCOMPARE(stackModel->columnCount(tIdx), 3);
@@ -709,7 +783,7 @@ void GdbTest::testStackFetchMore()
 
     breakpoints()->addCodeBreakpoint(fileName, 25);
     QVERIFY(session->startProgram(&cfg, m_iface));
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->frameStackModel()->fetchFramesCalled, 1);
 
     QModelIndex tIdx = stackModel->index(0,0);
@@ -808,8 +882,7 @@ void GdbTest::testStackSwitchThread()
 
     breakpoints()->addCodeBreakpoint(fileName, 38);
     QVERIFY(session->startProgram(&cfg, m_iface));
-    QTest::qWait(500);
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
 
     QCOMPARE(stackModel->rowCount(), 4);
 
@@ -833,14 +906,7 @@ void GdbTest::testStackSwitchThread()
 
 void GdbTest::testAttach()
 {
-    // if on linux, ensure we can actually attach
-    QFile canRun("/proc/sys/kernel/yama/ptrace_scope");
-    if (canRun.exists()) {
-        QVERIFY(canRun.open(QIODevice::ReadOnly));
-        if (canRun.read(1).toInt() != 0) {
-            QSKIP("ptrace attaching not allows, skipping test. To enable it, set /proc/sys/kernel/yama/ptrace_scope to 0.", SkipAll);
-        }
-    }
+    SKIP_IF_ATTACH_FORBIDDEN();
 
     QString fileName = findSourceFile("debugeeslow.cpp");
 
@@ -867,6 +933,31 @@ void GdbTest::testAttach()
     WAIT_FOR_STATE(session, DebugSession::EndedState);
 }
 
+void GdbTest::testManualAttach()
+{
+    SKIP_IF_ATTACH_FORBIDDEN();
+
+    QString fileName = findSourceFile("debugeeslow.cpp");
+
+    KProcess debugeeProcess;
+    debugeeProcess << "nice" << findExecutable("debugeeslow").toLocalFile();
+    debugeeProcess.start();
+    QVERIFY(debugeeProcess.waitForStarted());
+
+    TestDebugSession *session = new TestDebugSession;
+
+    TestLaunchConfiguration cfg;
+    cfg.config().writeEntry(GDBDebugger::remoteGdbRunEntry, KUrl(findSourceFile("gdb_script_empty")));
+    QVERIFY(session->startProgram(&cfg, m_iface));
+
+    session->addCommand(GDBMI::NonMI, QString("attach %0").arg(debugeeProcess.pid()));
+    WAIT_FOR_STATE(session, DebugSession::PausedState);
+
+    session->run();
+    QTest::qWait(2000); // give the slow inferior some extra time to run
+    WAIT_FOR_STATE(session, DebugSession::EndedState);
+}
+
 void GdbTest::testCoreFile()
 {
     QFile f("core");
@@ -1242,7 +1333,7 @@ void GdbTest::testSegfaultDebugee()
 
     QVERIFY(session->startProgram(&cfg, m_iface));
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 23);
     session->run();
 
@@ -1263,7 +1354,7 @@ void GdbTest::testSwitchFrameGdbConsole()
 
     breakpoints()->addCodeBreakpoint(debugeeFileName, 24);
     QVERIFY(session->startProgram(&cfg, m_iface));
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(stackModel->currentFrame(), 0);
     stackModel->setCurrentFrame(1);
     QCOMPARE(stackModel->currentFrame(), 1);
@@ -1328,7 +1419,7 @@ void GdbTest::testPickupManuallyInsertedBreakpoint()
     KDevelop::Breakpoint *b = breakpoints()->breakpoint(1);
     QVERIFY(b);
     QCOMPARE(b->line(), 31); //we start with 0, gdb with 1
-    QCOMPARE(b->url().url(), QString("debugee.cpp"));
+    QCOMPARE(b->url().fileName(), QString("debugee.cpp"));
 }
 
 //Bug 270970
@@ -1356,12 +1447,12 @@ void GdbTest::testPickupManuallyInsertedBreakpointOnlyOnce()
     KDevelop::Breakpoint *b = breakpoints()->breakpoint(0);
     QVERIFY(b);
     QCOMPARE(b->line(), 31); //we start with 0, gdb with 1
-    QCOMPARE(b->url().url(), QString("debugee.cpp"));
+    QCOMPARE(b->url().fileName(), QString("debugee.cpp"));
 
     b = breakpoints()->breakpoint(1);
     QVERIFY(b);
     QCOMPARE(b->line(), 21);
-    QCOMPARE(b->url().url(), QString("debugee.cpp"));
+    QCOMPARE(b->url().fileName(), QString("debugee.cpp"));
 }
 
 void GdbTest::testRunGdbScript()
@@ -1382,7 +1473,7 @@ void GdbTest::testRunGdbScript()
 
     QVERIFY(session->startProgram(&cfg, m_iface));
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
 
     QCOMPARE(session->line(), 27);
 
@@ -1421,7 +1512,7 @@ void GdbTest::testRemoteDebug()
 
     QVERIFY(session->startProgram(&cfg, m_iface));
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
 
     QCOMPARE(session->line(), 29);
 
@@ -1465,7 +1556,7 @@ void GdbTest::testRemoteDebugInsertBreakpoint()
 
     QVERIFY(session->startProgram(&cfg, m_iface));
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
 
     QCOMPARE(session->line(), 29);
 
@@ -1516,7 +1607,7 @@ void GdbTest::testRemoteDebugInsertBreakpointPickupOnlyOnce()
 
     QVERIFY(session->startProgram(&cfg, m_iface));
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
 
     QCOMPARE(session->line(), 29);
 
@@ -1534,7 +1625,7 @@ void GdbTest::testRemoteDebugInsertBreakpointPickupOnlyOnce()
     session = new TestDebugSession;
     QVERIFY(session->startProgram(&cfg, m_iface));
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
 
     QCOMPARE(session->line(), 29);
 
@@ -1560,10 +1651,10 @@ void GdbTest::testBreakpointWithSpaceInPath()
     QString fileName = findSourceFile("debugee space.cpp");
 
     KDevelop::Breakpoint * b = breakpoints()->addCodeBreakpoint(fileName, 20);
-    QCOMPARE(session->breakpointController()->breakpointState(b), KDevelop::Breakpoint::NotStartedState);
+    QCOMPARE(b->state(), KDevelop::Breakpoint::NotStartedState);
 
     session->startProgram(&cfg, m_iface);
-    WAIT_FOR_STATE_FAIL(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 20);
     session->run();
     WAIT_FOR_STATE(session, DebugSession::EndedState);
@@ -1582,7 +1673,7 @@ void GdbTest::testBreakpointDisabledOnStart()
     b->setData(KDevelop::Breakpoint::EnableColumn, Qt::Unchecked);
 
     session->startProgram(&cfg, m_iface);
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 29);
     b->setData(KDevelop::Breakpoint::EnableColumn, Qt::Checked);
     session->run();
@@ -1676,8 +1767,8 @@ void GdbTest::parseBug304730()
 
     MIParser parser;
 
-    QScopedPointer<GDBMI::Record> record(parser.parse(&file));
-    QVERIFY(!record.isNull());
+    std::unique_ptr<GDBMI::Record> record(parser.parse(&file));
+    QVERIFY(record.get() != nullptr);
 }
 
 void GdbTest::testMultipleLocationsBreakpoint()
@@ -1691,7 +1782,7 @@ void GdbTest::testMultipleLocationsBreakpoint()
     //TODO check if the additional location breakpoint is added
 
     session->startProgram(&cfg, m_iface);
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 19);
 
     session->run();
@@ -1785,8 +1876,8 @@ void GdbTest::testChangeBreakpointWhileRunning() {
     TestLaunchConfiguration c(findExecutable("debugeeslow"));
     KDevelop::Breakpoint* b = breakpoints()->addCodeBreakpoint("debugeeslow.cpp:25");
     session->startProgram(&c, m_iface);
-    
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QVERIFY(session->currentLine() >= 24 && session->currentLine() <= 26 );
     session->run();
     WAIT_FOR_STATE(session, DebugSession::ActiveState);
@@ -1823,8 +1914,8 @@ void GdbTest::testDebugInExternalTerminal()
         KDevelop::Breakpoint* b = breakpoints()->addCodeBreakpoint(debugeeFileName, 28);
 
         session->startProgram(&cfg, m_iface);
-        WAIT_FOR_STATE(session, DebugSession::PausedState);
-        QCOMPARE(session->breakpointController()->breakpointState(b), KDevelop::Breakpoint::CleanState);
+        WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
+        QCOMPARE(b->state(), KDevelop::Breakpoint::CleanState);
         session->stepInto();
         WAIT_FOR_STATE(session, DebugSession::PausedState);
         session->run();
@@ -1841,43 +1932,45 @@ void GdbTest::testPathWithSpace()
     auto debugee = findExecutable("path with space/spacedebugee");
     TestLaunchConfiguration c(debugee, debugee.upUrl());
     KDevelop::Breakpoint* b = breakpoints()->addCodeBreakpoint("spacedebugee.cpp:30");
-    QCOMPARE(session->breakpointController()->breakpointState(b), KDevelop::Breakpoint::NotStartedState);
+    QCOMPARE(b->state(), KDevelop::Breakpoint::NotStartedState);
     session->startProgram(&c, m_iface);
 
     WAIT_FOR_STATE(session, DebugSession::PausedState);
-    QCOMPARE(session->breakpointController()->breakpointState(b), KDevelop::Breakpoint::CleanState);
+    QCOMPARE(b->state(), KDevelop::Breakpoint::CleanState);
     session->run();
     WAIT_FOR_STATE(session, DebugSession::EndedState);
 #endif
 }
 
 void GdbTest::waitForState(GDBDebugger::DebugSession *session, DebugSession::DebuggerState state,
-                            const char *file, int line, bool expectFail)
+                            const char *file, int line, bool waitForIdle)
 {
     QWeakPointer<GDBDebugger::DebugSession> s(session); //session can get deleted in DebugController
-    kDebug() << "waiting for state" << state;
     QTime stopWatch;
     stopWatch.start();
-    while (s.data()->state() != state) {
+    while (s.data()->state() != state || (waitForIdle && s.data()->stateIsOn(s_dbgBusy))) {
         if (stopWatch.elapsed() > 5000) {
             kWarning() << "current state" << s.data()->state() << "waiting for" << state;
-            if (!expectFail) {
-                QFAIL(qPrintable(QString("Didn't reach state in %0:%1").arg(file).arg(line)));
-            } else {
-                break;
-            }
+            QTest::qFail(qPrintable(QString("Timeout before reaching state %0").arg(state)),
+                file, line);
+            return;
         }
         QTest::qWait(20);
         if (!s) {
-            if (state == DebugSession::EndedState) break;
-            if (!expectFail) {
-                QFAIL(qPrintable(QString("Didn't reach state; session ended in %0:%1").arg(file).arg(line)));
-            } else {
+            if (state == DebugSession::EndedState)
                 break;
-            }
+            QTest::qFail(qPrintable(QString("Session ended before reaching state %0").arg(state)),
+                file, line);
+            return;
         }
     }
-    QTest::qWait(100);
+    if (!waitForIdle && state != DebugSession::EndedState) {
+        // legacy behavior for tests that implicitly may require waiting for idle,
+        // but which were written before waitForIdle was added
+        QTest::qWait(100);
+    }
+
+    qDebug() << "Reached state " << state << " in " << file << ':' << line;
 }
 
 }
diff --git a/debuggers/gdb/unittests/gdbtest.h b/debuggers/gdb/unittests/gdbtest.h
index b9a961d..4cb0a14 100644
--- a/debuggers/gdb/unittests/gdbtest.h
+++ b/debuggers/gdb/unittests/gdbtest.h
@@ -60,6 +60,7 @@ private Q_SLOTS:
     void testStackDeactivateAndActive();
     void testStackSwitchThread();
     void testAttach();
+    void testManualAttach();
     void testCoreFile();
     void testVariablesLocals();
     void testVariablesLocalsStruct();
@@ -97,7 +98,7 @@ private:
     void waitForState(GDBDebugger::DebugSession *session,
                       KDevelop::IDebugSession::DebuggerState state,
                       const char *file, int line,
-                      bool expectFail = false);
+                      bool waitForIdle = false);
     IExecutePlugin* m_iface;
 };
 
diff --git a/debuggers/gdb/variablecontroller.cpp b/debuggers/gdb/variablecontroller.cpp
index 5198c09..5cf27f0 100644
--- a/debuggers/gdb/variablecontroller.cpp
+++ b/debuggers/gdb/variablecontroller.cpp
@@ -41,7 +41,7 @@ VariableController::VariableController(DebugSession* parent)
     : KDevelop::IVariableController(parent)
 {
     Q_ASSERT(parent);
-    connect(parent, SIGNAL(programStopped(GDBMI::ResultRecord)), SLOT(programStopped(GDBMI::ResultRecord)));
+    connect(parent, SIGNAL(programStopped(GDBMI::AsyncRecord)), SLOT(programStopped(GDBMI::AsyncRecord)));
     connect(parent, SIGNAL(stateChanged(KDevelop::IDebugSession::DebuggerState)), SLOT(stateChanged(KDevelop::IDebugSession::DebuggerState)));
 }
 
@@ -50,7 +50,7 @@ DebugSession *VariableController::debugSession() const
     return static_cast<DebugSession*>(const_cast<QObject*>(QObject::parent()));
 }
 
-void VariableController::programStopped(const GDBMI::ResultRecord& r)
+void VariableController::programStopped(const GDBMI::AsyncRecord& r)
 {
     if (debugSession()->stateIsOn(s_shuttingDown)) return;
 
diff --git a/debuggers/gdb/variablecontroller.h b/debuggers/gdb/variablecontroller.h
index f5ac8c1..924e87e 100644
--- a/debuggers/gdb/variablecontroller.h
+++ b/debuggers/gdb/variablecontroller.h
@@ -31,6 +31,7 @@
 using namespace KDevelop;
 
 namespace GDBMI {
+struct AsyncRecord;
 struct ResultRecord;
 struct Value;
 }
@@ -56,7 +57,7 @@ public:
     virtual void update();
 
 private slots:
-    void programStopped(const GDBMI::ResultRecord &r);
+    void programStopped(const GDBMI::AsyncRecord &r);
     void stateChanged(KDevelop::IDebugSession::DebuggerState);
 
 private:
diff --git a/formatters/customscript/kdevcustomscript.desktop.cmake b/formatters/customscript/kdevcustomscript.desktop.cmake
index 7b8c9f8..0569eed 100644
--- a/formatters/customscript/kdevcustomscript.desktop.cmake
+++ b/formatters/customscript/kdevcustomscript.desktop.cmake
@@ -52,7 +52,7 @@ Name[it]=Backend formattatore script personalizzato
 Name[kk]=   
 Name[nb]=Bakgrunnsmotor for formattering med egne skripter
 Name[nds]=Egen Skript-Formateerhlpprogramm
-Name[nl]=Eigen script voor formatteerbackend
+Name[nl]=Backend voor formatteerprogramma met eigen scripts
 Name[pl]=Silnik formatowania przy uyciu wasnych skryptw
 Name[pt]=Infra-Estrutura de Formatao Personalizada
 Name[pt_BR]=Infraestrutura de formatao de scripts personalizados
diff --git a/languages/cpp/codegen/makeimplementationprivate.h b/languages/cpp/codegen/makeimplementationprivate.h
index 1db7489..bab7be1 100644
--- a/languages/cpp/codegen/makeimplementationprivate.h
+++ b/languages/cpp/codegen/makeimplementationprivate.h
@@ -86,8 +86,8 @@ class MakeImplementationPrivate : public CodeGenerator<ParseSession>
     //DocumentChange insertConstructorInitializations(ClassFunctionDeclaration * constructor, const QList<ClassMemberDeclaration *>)
 };
 
-Q_DECLARE_OPERATORS_FOR_FLAGS(MakeImplementationPrivate::Policies)
-
 }
 
+Q_DECLARE_OPERATORS_FOR_FLAGS(KDevelop::MakeImplementationPrivate::Policies)
+
 #endif // MAKEIMPLEMENTATIONPRIVATE_H
diff --git a/languages/plugins/custom-definesandincludes/kcm_widget/kcm_kdevcustomdefinesandincludes.desktop b/languages/plugins/custom-definesandincludes/kcm_widget/kcm_kdevcustomdefinesandincludes.desktop
index e9f226e..e6708b3 100644
--- a/languages/plugins/custom-definesandincludes/kcm_widget/kcm_kdevcustomdefinesandincludes.desktop
+++ b/languages/plugins/custom-definesandincludes/kcm_widget/kcm_kdevcustomdefinesandincludes.desktop
@@ -9,6 +9,7 @@ X-KDE-ParentApp=kdevplatformproject
 X-KDE-ParentComponents=kdevplatformproject
 
 Name=Custom Defines And Includes
+Name[bs]=Vlastite definicije i ukljuivanja
 Name[ca]=Personalitza les definicions i inclusions
 Name[de]=Eigene Definitionen und Includes
 Name[en_GB]=Custom Defines And Includes
@@ -29,6 +30,7 @@ Name[uk]=   
 Name[x-test]=xxCustom Defines And Includesxx
 
 Comment=Configure which macros and include directories/files will be added to the parser during project parsing.
+Comment[bs]=Konfigurie koji makroi i direktoriji/ukljuivanja e se dodati parseru tokom parsiranja projekta.
 Comment[ca]=Configura quines macros i directoris/fitxers s'afegiran a l'analitzador durant l'anlisi del projecte.
 Comment[de]=Einstellung der Makros und Include-Ordner/-Dateien, die zum fr den Parser whrend des Einlesens des Projekts hinzugefgt werden.
 Comment[en_GB]=Configure which macros and include directories/files will be added to the parser during project parsing.
@@ -47,3 +49,4 @@ Comment[sv]=Anpassa vilka makron och filer eller kataloger att inkludera som l
 Comment[tr]=Proje ayrtrlrken hangi makrolarn ve ierme dizinlerinin/dosyalarn ayrtrcya ekleneceini yaplandrn.
 Comment[uk]=      ,       .
 Comment[x-test]=xxConfigure which macros and include directories/files will be added to the parser during project parsing.xx
+Comment[zh_CN]=
diff --git a/languages/plugins/custom-definesandincludes/kdevdefinesandincludesmanager.desktop.cmake b/languages/plugins/custom-definesandincludes/kdevdefinesandincludesmanager.desktop.cmake
index 61472b0..2b351ec 100644
--- a/languages/plugins/custom-definesandincludes/kdevdefinesandincludesmanager.desktop.cmake
+++ b/languages/plugins/custom-definesandincludes/kdevdefinesandincludesmanager.desktop.cmake
@@ -1,6 +1,7 @@
 [Desktop Entry]
 Type=Service
 Name=Custom Defines And Includes Manager
+Name[bs]=Menader vlastitih definicija i ukljuivanja
 Name[ca]=Gestor per personalitzar les definicions i inclusions
 Name[de]=Verwaltung eigener Definitionen und Includes
 Name[en_GB]=Custom Defines And Includes Manager
@@ -20,6 +21,7 @@ Name[tr]=zel Tanmlama ve erme Yneticisi
 Name[uk]=    
 Name[x-test]=xxCustom Defines And Includes Managerxx
 GenericName=Custom Defines And Includes Manager
+GenericName[bs]=Menader vlastitih definicija i ukljuivanja
 GenericName[ca]=Gestor per personalitzar les definicions i inclusions
 GenericName[de]=Verwaltung eigener Definitionen und Includes
 GenericName[en_GB]=Custom Defines And Includes Manager
@@ -39,6 +41,7 @@ GenericName[tr]=zel Tanmlama ve erme Yneticisi
 GenericName[uk]=    
 GenericName[x-test]=xxCustom Defines And Includes Managerxx
 Comment=Configure which macros and include directories/files will be added to the parser during project parsing.
+Comment[bs]=Konfigurie koji makroi i direktoriji/ukljuivanja e se dodati parseru tokom parsiranja projekta.
 Comment[ca]=Configura quines macros i directoris/fitxers s'afegiran a l'analitzador durant l'anlisi del projecte.
 Comment[de]=Einstellung der Makros und Include-Ordner/-Dateien, die zum fr den Parser whrend des Einlesens des Projekts hinzugefgt werden.
 Comment[en_GB]=Configure which macros and include directories/files will be added to the parser during project parsing.
@@ -57,6 +60,7 @@ Comment[sv]=Anpassa vilka makron och filer eller kataloger att inkludera som l
 Comment[tr]=Proje ayrtrlrken hangi makrolarn ve ierme dizinlerinin/dosyalarn ayrtrcya ekleneceini yaplandrn.
 Comment[uk]=      ,       .
 Comment[x-test]=xxConfigure which macros and include directories/files will be added to the parser during project parsing.xx
+Comment[zh_CN]=
 Icon=kdevelop
 ServiceTypes=KDevelop/Plugin
 X-KDE-Library=kdevdefinesandincludesmanager
