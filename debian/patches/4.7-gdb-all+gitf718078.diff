diff --git a/debuggers/gdb/CMakeLists.txt b/debuggers/gdb/CMakeLists.txt
index bf0ef80..4f6423d 100644
--- a/debuggers/gdb/CMakeLists.txt
+++ b/debuggers/gdb/CMakeLists.txt
@@ -1,5 +1,7 @@
 project(gdb)
 
+find_package(ZLIB)
+
 function(add_debuggable_executable target)
     cmake_parse_arguments(add_debuggable_executable "" "" "SRCS" ${ARGN})
     add_executable(${target} ${add_debuggable_executable_SRCS})
@@ -12,24 +14,6 @@ function(add_debuggable_executable target)
     set_target_properties(${target} PROPERTIES COMPILE_FLAGS "${CMAKE_CXX_FLAGS_DEBUG} ${_flags}")
 endfunction()
 
-if(NOT APPLE)
-macro_optional_find_package( KDE4Workspace 4.2.0 )
-
-macro_log_feature( KDE4WORKSPACE_FOUND
-"KDE 4 Workspace" "KDE 4 Workspace libraries" "kdebase/workspace" FALSE
-"" "Required for building the process selection dialog for attaching GDB to a running process."
-)
-endif(NOT APPLE)
-
-if(KDE4WORKSPACE_FOUND)
-    include_directories(
-        ${KDE4WORKSPACE_INCLUDE_DIR}
-    )
-    add_definitions(
-        -DKDEV_ENABLE_GDB_ATTACH_DIALOG
-    )
-endif(KDE4WORKSPACE_FOUND)
-
 if (CMAKE_VERSION VERSION_GREATER "2.9" OR NOT CMAKE_GENERATOR MATCHES "Ninja")
     set(HAVE_PATH_WITH_SPACES_TEST TRUE)
 else()
@@ -45,6 +29,8 @@ include_directories(
     ${CMAKE_CURRENT_BINARY_DIR}
     )
 
+configure_file(config-ksysguard.h.cmake ${CMAKE_CURRENT_BINARY_DIR}/config-ksysguard.h )
+
 #add_subdirectory(tests)
 
 ########### next target ###############
@@ -81,21 +67,27 @@ set(kdevgdb_PART_SRCS
     registers/registercontroller_arm.cpp
     registers/modelsmanager.cpp
     registers/converters.cpp
+    processselection.cpp
+    ksysguard/process.cpp
+    ksysguard/processes.cpp
+    ksysguard/ksysguardprocesslist.cpp
+    ksysguard/processes_atop_p.cpp
+    ksysguard/processes_base_p.cpp
+    ksysguard/processes_local_p.cpp
+    ksysguard/processes_remote_p.cpp
+    ksysguard/ProcessFilter.cpp
+    ksysguard/ProcessModel.cpp
+    ksysguard/ReniceDlg.cpp
 )
 
-if(KDE4WORKSPACE_FOUND)
-    set(kdevgdb_PART_SRCS
-        ${kdevgdb_PART_SRCS}
-        processselection.cpp
-    )
-endif(KDE4WORKSPACE_FOUND)
-
 set(kdevgdb_PART_UI
     debuggertracingdialog.ui
     debuggerconfigwidget.ui
     selectcore.ui
     selectaddress.ui
     registers/registersview.ui
+    ksysguard/ProcessWidgetUI.ui
+    ksysguard/ReniceDlgUi.ui
 )
 
 kde4_add_ui_files(kdevgdb_PART_SRCS ${kdevgdb_PART_UI})
@@ -110,6 +102,7 @@ target_link_libraries(kdevgdb ${KDEVPLATFORM_SUBLIME_LIBRARIES}
     ${KDEVPLATFORM_UTIL_LIBRARIES}
     ${KDE4_KTEXTEDITOR_LIBS}
     ${KDE4WORKSPACE_PROCESSUI_LIBS}
+    ${ZLIB_LIBRARY}
 )
 
 install(TARGETS kdevgdb DESTINATION ${PLUGIN_INSTALL_DIR})
@@ -144,19 +137,24 @@ set(gdbtest_PART_SRCS
     registers/registercontroller_arm.cpp
     registers/modelsmanager.cpp
     registers/converters.cpp
-)
-
-if(KDE4WORKSPACE_FOUND)
-    set(gdbtest_PART_SRCS
-        ${gdbtest_PART_SRCS}
-        processselection.cpp
+    ksysguard/process.cpp
+    ksysguard/processes.cpp
+    ksysguard/ksysguardprocesslist.cpp
+    ksysguard/processes_atop_p.cpp
+    ksysguard/processes_base_p.cpp
+    ksysguard/processes_local_p.cpp
+    ksysguard/processes_remote_p.cpp
+    ksysguard/ProcessFilter.cpp
+    ksysguard/ProcessModel.cpp
+    ksysguard/ReniceDlg.cpp
     )
-endif(KDE4WORKSPACE_FOUND)
 
 kde4_add_ui_files(gdbtest_PART_SRCS
     debuggertracingdialog.ui
     selectaddress.ui
     registers/registersview.ui
+    ksysguard/ProcessWidgetUI.ui
+    ksysguard/ReniceDlgUi.ui
 )
 kde4_add_unit_test(gdbtest ${gdbtest_PART_SRCS})
 target_link_libraries(gdbtest
@@ -171,6 +169,7 @@ target_link_libraries(gdbtest
     ${KDE4_KTEXTEDITOR_LIBS}
     ${KDE4_KPARTS_LIBRARY}
     ${KDE4WORKSPACE_PROCESSUI_LIBS}
+    ${ZLIB_LIBRARY}
 )
 
 if (HAVE_PATH_WITH_SPACES_TEST)
diff --git a/debuggers/gdb/DESIGN.txt b/debuggers/gdb/DESIGN.txt
index ddefb70..2ee03ba 100644
--- a/debuggers/gdb/DESIGN.txt
+++ b/debuggers/gdb/DESIGN.txt
@@ -65,7 +65,7 @@ predefined set of steps:
 
    - Once there are no commands in queue, and "reload_program_state" flag is
      set, we raise the 'program_state_changed' event. All widgets react to
-     that by queueing commands for realoding their state.
+     that by queueing commands for reloading their state.
 
      
 
diff --git a/debuggers/gdb/breakpointcontroller.cpp b/debuggers/gdb/breakpointcontroller.cpp
index 744e750..ca58192 100644
--- a/debuggers/gdb/breakpointcontroller.cpp
+++ b/debuggers/gdb/breakpointcontroller.cpp
@@ -57,10 +57,21 @@ QString unquoteExpression(QString expr)
 struct Handler : public GDBCommandHandler
 {
     Handler(BreakpointController *c, KDevelop::Breakpoint *b)
-        : controller(c), breakpoint(b) {}
+        : controller(c)
+        , breakpointIndex(c->breakpointModel()->breakpointIndex(b, 0))
+    {
+    }
+
+    Breakpoint * breakpoint()
+    {
+        if (breakpointIndex.isValid()) {
+            return controller->breakpointModel()->breakpoint(breakpointIndex.row());
+        }
+        return nullptr;
+    }
 
     BreakpointController *controller;
-    KDevelop::Breakpoint *breakpoint;
+    QPersistentModelIndex breakpointIndex;
 };
 
 struct UpdateHandler : public Handler
@@ -70,6 +81,10 @@ struct UpdateHandler : public Handler
 
     void handle(const GDBMI::ResultRecord &r)
     {
+        Breakpoint * breakpoint = this->breakpoint();
+        if (!breakpoint)
+            return;
+
         if (r.reason == "error") {
             controller->error(breakpoint, r["msg"].literal(), m_column);
             kWarning() << r["msg"].literal();
@@ -92,39 +107,55 @@ struct InsertedHandler : public Handler
 
     virtual void handle(const GDBMI::ResultRecord &r)
     {
-        kDebug() << controller->m_dirty[breakpoint];
+        Breakpoint * breakpoint = this->breakpoint();
 
         if (r.reason == "error") {
-            controller->error(breakpoint, r["msg"].literal(), KDevelop::Breakpoint::LocationColumn);
-            kWarning() << r["msg"].literal();
+            if (breakpoint) {
+                controller->error(breakpoint, r["msg"].literal(), KDevelop::Breakpoint::LocationColumn);
+                kWarning() << r["msg"].literal();
+            }
         } else {
-            controller->m_errors[breakpoint].remove(KDevelop::Breakpoint::LocationColumn);
-            if (r.hasField("bkpt")) {
-                controller->update(breakpoint, r["bkpt"]);
-            } else if (r.hasField("wpt")) {
-                // For watchpoint creation, GDB basically does not say
-                // anything.  Just record id.
-                controller->m_ids[breakpoint] = r["wpt"]["number"].literal();
-            } else if (r.hasField("hw-rwpt")) {
-                controller->m_ids[breakpoint] = r["hw-rwpt"]["number"].literal();
-            } else if (r.hasField("hw-awpt")) {
-                controller->m_ids[breakpoint] = r["hw-awpt"]["number"].literal();
+            QString id;
+
+            for (auto kind : {"bkpt", "wpt", "hw-rwpt", "hw-awpt"}) {
+                if (r.hasField(kind)) {
+                    id = r[kind]["number"].literal();
+                    break;
+                }
+            }
+            Q_ASSERT(!id.isEmpty());
+
+            if (breakpoint) {
+                controller->m_errors[breakpoint].remove(KDevelop::Breakpoint::LocationColumn);
+                controller->m_ids[breakpoint] = id;
+                if (r.hasField("bkpt")) {
+                    controller->update(breakpoint, r["bkpt"]);
+                }
+                kDebug() << "breakpoint id" << breakpoint << controller->m_ids[breakpoint];
+            } else {
+                // breakpoint was deleted while insertion was in flight
+                controller->debugSession()->addCommandToFront(
+                    new GDBCommand(BreakDelete, id));
             }
-            Q_ASSERT(!controller->m_ids[breakpoint].isEmpty());
-            kDebug() << "breakpoint id" << breakpoint << controller->m_ids[breakpoint];
         }
-        controller->m_dirty[breakpoint].remove(KDevelop::Breakpoint::LocationColumn);
-        controller->breakpointStateChanged(breakpoint);
-        controller->sendMaybe(breakpoint);
+
+        if (breakpoint) {
+            controller->m_dirty[breakpoint].remove(KDevelop::Breakpoint::LocationColumn);
+            controller->breakpointStateChanged(breakpoint);
+            controller->sendMaybe(breakpoint);
+        }
     }
 
     virtual bool handlesError() { return true; }
 };
 
-struct DeletedHandler : public Handler
+struct DeletedHandler : public GDBCommandHandler
 {
     DeletedHandler(BreakpointController *c, KDevelop::Breakpoint *b)
-        : Handler(c, b) {}
+        : controller(c)
+        , breakpoint(b)
+    {
+    }
 
     void handle(const GDBMI::ResultRecord &r)
     {
@@ -137,6 +168,9 @@ struct DeletedHandler : public Handler
             delete breakpoint;
         }
     }
+
+    BreakpointController * controller;
+    Breakpoint * breakpoint;
 };
 
 
@@ -148,7 +182,7 @@ BreakpointController::BreakpointController(DebugSession* parent)
     // a base class that does this connect.
     connect(debugSession(),     SIGNAL(event(IDebugSession::event_t)),
             this,       SLOT(slotEvent(IDebugSession::event_t)));
-    connect(parent, SIGNAL(programStopped(GDBMI::ResultRecord)), SLOT(programStopped(GDBMI::ResultRecord)));
+    connect(parent, SIGNAL(programStopped(GDBMI::AsyncRecord)), SLOT(programStopped(GDBMI::AsyncRecord)));
 }
 
 DebugSession *BreakpointController::debugSession() const
@@ -300,13 +334,16 @@ void BreakpointController::sendMaybe(KDevelop::Breakpoint* breakpoint)
         kDebug() << "deleted";
         m_dirty.remove(breakpoint);
         m_errors.remove(breakpoint);
-        if (m_ids.contains(breakpoint)) { //if id is 0 breakpoint insertion is still pending, InsertedHandler will call sendMaybe again and delete it
+        if (m_ids.contains(breakpoint)) {
             kDebug() << "breakpoint id" << m_ids[breakpoint];
             if (!m_ids[breakpoint].isEmpty()) {
                 debugSession()->addCommandToFront(
                     new GDBCommand(BreakDelete, m_ids[breakpoint],
                                 new DeletedHandler(this, breakpoint)));
                 addedCommand = true;
+            } else {
+                kDebug() << "insertion is still in flight, just delete it";
+                delete breakpoint;
             }
         } else {
             kDebug() << "breakpoint doesn't have yet an id, just delete it";
@@ -459,41 +496,36 @@ void BreakpointController::handleBreakpointList(const GDBMI::ResultRecord &r)
 void BreakpointController::update(KDevelop::Breakpoint *breakpoint, const GDBMI::Value &b)
 {
     m_dontSendChanges++;
-    
+
     m_ids[breakpoint] = b["number"].literal();
 
-    if (b.hasField("original-location")) {
-        if (breakpoint->address().isEmpty()) {
-            /* If the address is not empty, it means that the breakpoint
-               is set by KDevelop, not by the user, and that we want to
-               show the original expression, not the address, in the table.
-               TODO: this also means that if used added a watchpoint in gdb
-               like "watch foo", then we'll show it in the breakpoint table
-               just fine, but after KDevelop restart, we'll try to add the
-               breakpoint using basically "watch *&(foo)".  I'm not sure if
-               that's a problem or not.  */
-            QString location = b["original-location"].literal();
-            kDebug() << "location" << location;
-            if (breakpoint->kind() == KDevelop::Breakpoint::CodeBreakpoint) {
-                QRegExp rx("^(.+):(\\d+)$");
-                if (rx.indexIn(location) != -1) {
-                    breakpoint->setLocation(KUrl(unquoteExpression(rx.cap(1))), rx.cap(2).toInt()-1);
-                } else {
-                    //for regular expression breakpoints and not only...
-                    if(b.hasField("fullname") && b.hasField("line")){
-                        breakpoint->setLocation(KUrl(unquoteExpression(b["fullname"].literal())), b["line"].toInt()-1);
-                    }else{
-                        breakpoint->setData(KDevelop::Breakpoint::LocationColumn, unquoteExpression(location));
-                    }
-                }
-            } else {
-                breakpoint->setData(KDevelop::Breakpoint::LocationColumn, unquoteExpression(location));
-            }
+    /* If the address is not empty, it means that the breakpoint
+        is set by KDevelop, not by the user, and that we want to
+        show the original expression, not the address, in the table.
+        TODO: this also means that if used added a watchpoint in gdb
+        like "watch foo", then we'll show it in the breakpoint table
+        just fine, but after KDevelop restart, we'll try to add the
+        breakpoint using basically "watch *&(foo)".  I'm not sure if
+        that's a problem or not.  */
+    const bool emptyAddress = breakpoint->address().isEmpty();
+    const bool isCodeBreakpoint = breakpoint->kind() == KDevelop::Breakpoint::CodeBreakpoint;
+
+    if (emptyAddress && isCodeBreakpoint && b.hasField("fullname") && b.hasField("line")){
+        breakpoint->setLocation(QUrl::fromLocalFile(unquoteExpression(b["fullname"].literal())),
+                                b["line"].toInt()-1);
+    } else if (emptyAddress && isCodeBreakpoint && b.hasField("original-location")) {
+        QRegExp rx("^(.+):(\\d+)$");
+        QString location = b["original-location"].literal();
+        kDebug() << "location" << location;
+        if (rx.indexIn(location) != -1) {
+            breakpoint->setLocation(KUrl(unquoteExpression(rx.cap(1))), rx.cap(2).toInt()-1);
+        } else {
+            breakpoint->setData(KDevelop::Breakpoint::LocationColumn, unquoteExpression(location));
         }
     } else if (b.hasField("what") && b["what"].literal() == "exception throw") {
         breakpoint->setExpression("catch throw");
     } else {
-        kWarning() << "That's too bad, breakpoint doesn't contain \"original-location\" field ";
+        kWarning() << "Breakpoint doesn't contain required location/expression data: " << m_ids[breakpoint];
     }
 
     if (!m_dirty[breakpoint].contains(KDevelop::Breakpoint::ConditionColumn)
@@ -525,7 +557,7 @@ void BreakpointController::update(KDevelop::Breakpoint *breakpoint, const GDBMI:
     m_dontSendChanges--;
 }
 
-void BreakpointController::programStopped(const GDBMI::ResultRecord& r)
+void BreakpointController::programStopped(const GDBMI::AsyncRecord& r)
 {
     QString reason;
     if (r.hasField("reason")) {
diff --git a/debuggers/gdb/breakpointcontroller.h b/debuggers/gdb/breakpointcontroller.h
index 1b8ae0e..f415922 100644
--- a/debuggers/gdb/breakpointcontroller.h
+++ b/debuggers/gdb/breakpointcontroller.h
@@ -32,6 +32,7 @@
 class QModelIndex;
 
 namespace GDBMI {
+struct AsyncRecord;
 struct ResultRecord;
 struct Value;
 }
@@ -56,9 +57,11 @@ class BreakpointController : public IBreakpointController
 public:
     BreakpointController(DebugSession* parent);
 
-private slots:
+    using IBreakpointController::breakpointModel;
+
+private Q_SLOTS:
     void slotEvent(IDebugSession::event_t);
-    void programStopped(const GDBMI::ResultRecord &r);
+    void programStopped(const GDBMI::AsyncRecord &r);
 
 private:
     DebugSession* debugSession() const;
diff --git a/debuggers/gdb/config-ksysguard.h.cmake b/debuggers/gdb/config-ksysguard.h.cmake
new file mode 100644
index 0000000..670fb8d
--- /dev/null
+++ b/debuggers/gdb/config-ksysguard.h.cmake
@@ -0,0 +1,12 @@
+/* Define to 1 if you have the <sys/ptrace.h> header file. */
+#cmakedefine HAVE_SYS_PTRACE_H 1
+
+/* Define to 1 if you have the <sys/endian.h> header file. */
+#cmakedefine HAVE_SYS_ENDIAN_H 1
+
+/* Define to 1 if you have the <byteswap.h> header file. */
+#cmakedefine HAVE_BYTESWAP_H 1
+
+/* Define to 1 if you have the X11 xres file */
+#cmakedefine HAVE_XRES 1
+
diff --git a/debuggers/gdb/debuggerplugin.cpp b/debuggers/gdb/debuggerplugin.cpp
index ca2bbaf..437a554 100644
--- a/debuggers/gdb/debuggerplugin.cpp
+++ b/debuggers/gdb/debuggerplugin.cpp
@@ -71,9 +71,7 @@
 #include <interfaces/launchconfigurationtype.h>
 
 #include "disassemblewidget.h"
-#ifdef KDEV_ENABLE_GDB_ATTACH_DIALOG
 #include "processselection.h"
-#endif
 #include "memviewdlg.h"
 #include "gdbparser.h"
 #include "gdboutputwidget.h"
@@ -137,7 +135,7 @@ private:
 
 CppDebuggerPlugin::CppDebuggerPlugin( QObject *parent, const QVariantList & ) :
     KDevelop::IPlugin( CppDebuggerFactory::componentData(), parent ),
-    m_config(KGlobal::config(), "GDB Debugger"), m_session(0)
+    m_config(KGlobal::config(), "GDB Debugger")
 {
     KDEV_USE_EXTENSION_INTERFACE( KDevelop::IStatus )
     
@@ -177,13 +175,6 @@ CppDebuggerPlugin::CppDebuggerPlugin( QObject *parent, const QVariantList & ) :
         Q_ASSERT(type);
         type->addLauncher( new GdbLauncher( this, iface ) );
     }
-    // The output from tracepoints goes to "application" window, because
-    // we don't have any better alternative, and using yet another window
-    // is undesirable. Besides, this makes tracepoint look even more similar
-    // to printf debugging.
-// PORTING TODO broken - need intermediate signal?
-//     connect( gdbBreakpointWidget,   SIGNAL(tracingOutput(QByteArray)),
-//              procLineMaker,         SLOT(slotReceivedStdout(QByteArray)));
 }
 
 void CppDebuggerPlugin::unload()
@@ -302,16 +293,6 @@ KDevelop::ContextMenuExtension CppDebuggerPlugin::contextMenuExtension( KDevelop
 
     m_contextIdent = econtext->currentWord();
 
-    //bool running = m_session && m_session->isRunning();
-
-    // If debugger is running, we insert items at the top.
-    // The reason is user has explicitly run the debugger, so he's
-    // surely debugging, not editing code or something. So, first
-    // menu items should be about debugging, not some copy/paste/cut
-    // things.
-    //if (!running)
-        //popup->addSeparator();
-
     if (!m_contextIdent.isEmpty())
     {
         // PORTING TODO
@@ -371,7 +352,6 @@ void CppDebuggerPlugin::slotExamineCore()
     job->start();
 }
 
-#ifdef KDEV_ENABLE_GDB_ATTACH_DIALOG
 void CppDebuggerPlugin::slotAttachProcess()
 {
     emit showMessage(this, i18n("Choose a process to attach to..."), 1000);
@@ -387,7 +367,6 @@ void CppDebuggerPlugin::slotAttachProcess()
     else
         attachProcess(pid);
 }
-#endif
 
 void CppDebuggerPlugin::attachProcess(int pid)
 {
diff --git a/debuggers/gdb/debuggerplugin.h b/debuggers/gdb/debuggerplugin.h
index 0ec300a..0c1b391 100644
--- a/debuggers/gdb/debuggerplugin.h
+++ b/debuggers/gdb/debuggerplugin.h
@@ -51,7 +51,6 @@ class ProcessLineMaker;
 
 namespace GDBDebugger
 {
-class GDBBreakpointWidget;
 class FramestackWidget;
 class DisassembleWidget;
 class Breakpoint;
@@ -103,9 +102,7 @@ private Q_SLOTS:
     void contextWatch();
 
     void slotExamineCore();
-    #ifdef KDEV_ENABLE_GDB_ATTACH_DIALOG
     void slotAttachProcess();
-    #endif
 
     void slotDBusServiceRegistered(const QString& service);
     void slotDBusServiceUnregistered(const QString& service);
@@ -140,14 +137,8 @@ private:
 
     QString m_contextIdent;
 
-    // Set to true after each debugger restart
-    // Currently used to auto-show variables view
-    // on the first pause.
-    bool justRestarted_;
-
     KConfigGroup m_config;
 
-    DebugSession* m_session;
     DebuggerToolFactory< DisassembleWidget >* disassemblefactory;
     DebuggerToolFactory< GDBOutputWidget >* gdbfactory;
     DebuggerToolFactory< MemoryViewerWidget >* memoryviewerfactory;
diff --git a/debuggers/gdb/debugjob.cpp b/debuggers/gdb/debugjob.cpp
index 2807484..e6d7c8a 100644
--- a/debuggers/gdb/debugjob.cpp
+++ b/debuggers/gdb/debugjob.cpp
@@ -102,7 +102,9 @@ void DebugJob::start()
 
     startOutput();
 
-    m_session->startProgram( m_launchcfg, m_execute );
+    if (!m_session->startProgram( m_launchcfg, m_execute )) {
+        done();
+    }
 }
 
 bool DebugJob::doKill()
diff --git a/debuggers/gdb/debugsession.cpp b/debuggers/gdb/debugsession.cpp
index edc0d34..330d5a7 100644
--- a/debuggers/gdb/debugsession.cpp
+++ b/debuggers/gdb/debugsession.cpp
@@ -28,6 +28,7 @@
 #include <typeinfo>
 
 #include <QtCore/QFileInfo>
+#include <QtCore/QDir>
 #include <QtGui/QApplication>
 #include <QRegExp>
 
@@ -65,8 +66,8 @@ namespace GDBDebugger {
 DebugSession::DebugSession()
     : KDevelop::IDebugSession(),
       m_sessionState(NotStartedState),
-      justRestarted_(false),
       m_config(KGlobal::config(), "GDB Debugger"),
+      m_testing(false),
       commandQueue_(new CommandQueue),
       m_tty(0),
       state_(s_dbgNotStarted|s_appNotStarted),
@@ -107,6 +108,11 @@ DebugSession::~DebugSession()
     delete commandQueue_;
 }
 
+void DebugSession::setTesting(bool testing)
+{
+    m_testing = testing;
+}
+
 KDevelop::IDebugSession::DebuggerState DebugSession::state() const {
     return m_sessionState;
 }
@@ -128,10 +134,6 @@ KDevelop::IFrameStackModel* DebugSession::createFrameStackModel()
 
 void DebugSession::setupController()
 {
-    // variableTree -> gdbBreakpointWidget
-//     connect( variableTree,          SIGNAL(toggleWatchpoint(QString)),
-//              gdbBreakpointWidget,   SLOT(slotToggleWatchpoint(QString)));
-
     // controller -> procLineMaker
     connect( this,            SIGNAL(ttyStdout(QByteArray)),
              m_procLineMaker,         SLOT(slotReceivedStdout(QByteArray)));
@@ -150,73 +152,46 @@ void DebugSession::_gdbStateChanged(DBGStateFlags oldState, DBGStateFlags newSta
 {
     QString message;
 
+    DebuggerState oldSessionState = state();
+    DebuggerState newSessionState = oldSessionState;
     DBGStateFlags changedState = oldState ^ newState;
 
-    if (changedState & s_dbgNotStarted) {
-        if (newState & s_dbgNotStarted) {
+    if (newState & s_dbgNotStarted) {
+        if (changedState & s_dbgNotStarted) {
             message = i18n("Debugger stopped");
-
-        } else {
-            setSessionState(StartingState);
+            emit finished();
         }
-
-        //core()->running(this, false);
-        // TODO enable/disable tool views as applicable
-    }
-
-    // As soon as debugger clears 's_appNotStarted' flag, we
-    // set 'justRestarted' variable.
-    // The other approach would be to set justRestarted in slotRun, slotCore
-    // and slotAttach.
-    // Note that setting this var in startDebugger is not OK, because the
-    // initial state of debugger is exactly the same as state after pause,
-    // so we'll always show varaibles view.
-    if (changedState & s_appNotStarted) {
+        if (oldSessionState != NotStartedState) {
+            newSessionState = EndedState;
+        }
+    } else {
         if (newState & s_appNotStarted) {
-            setSessionState(StoppedState);
-            justRestarted_ = false;
-
+            if (oldSessionState == NotStartedState || oldSessionState == StartingState) {
+                newSessionState = StartingState;
+            } else {
+                newSessionState = StoppedState;
+            }
+        } else if (newState & s_programExited) {
+            if (changedState & s_programExited) {
+                message = i18n("Process exited");
+            }
+            newSessionState = StoppedState;
+        } else if (newState & s_appRunning) {
+            if (changedState & s_appRunning) {
+                message = i18n("Application is running");
+            }
+            newSessionState = ActiveState;
         } else {
-            justRestarted_ = true;
+            if (changedState & s_appRunning) {
+                message = i18n("Application is paused");
+            }
+            newSessionState = PausedState;
         }
     }
 
-    if (changedState & s_explicitBreakInto)
+    if (changedState & s_explicitBreakInto) {
         if (!(newState & s_explicitBreakInto))
             message = i18n("Application interrupted");
-
-    if (changedState & s_programExited) {
-        if (newState & s_programExited) {
-            message = i18n("Process exited");
-            setSessionState(StoppedState);
-        }
-    }
-
-    if (changedState & s_appRunning) {
-        if (newState & s_appRunning) {
-            message = i18n("Application is running");
-            setSessionState(ActiveState);
-        }
-        else
-        {
-            if (!(newState & s_appNotStarted)) {
-                message = i18n("Application is paused");
-                setSessionState(PausedState);
-
-                // On the first stop, show the variables view.
-                // We do it on first stop, and not at debugger start, because
-                // a program might just successfully run till completion. If we show
-                // the var views on start and hide on stop, this will look like flicker.
-                // On the other hand, if application is paused, it's very
-                // likely that the user wants to see variables.
-                if (justRestarted_)
-                {
-                    justRestarted_ = false;
-                    //mainWindow()->setViewAvailable(variableWidget, true);
-                    //FIXME: emit raiseVariableViews();
-                }
-            }
-        }
     }
 
     // And now? :-)
@@ -225,44 +200,55 @@ void DebugSession::_gdbStateChanged(DBGStateFlags oldState, DBGStateFlags newSta
     if (!message.isEmpty())
         emit showMessage(message, 3000);
 
-    if (!(oldState & s_dbgNotStarted) && (newState & s_dbgNotStarted))
-    {
-        emit finished();
-        setSessionState(EndedState); //this will delete the DebugSession, so do it last
-    }
-
     emit gdbStateChanged(oldState, newState);
+
+    // must be last, since it can lead to deletion of the DebugSession
+    if (newSessionState != oldSessionState) {
+        setSessionState(newSessionState);
+    }
 }
 
 void DebugSession::examineCoreFile(const KUrl& debugee, const KUrl& coreFile)
 {
-    setStateOff(s_programExited|s_appNotStarted);
-    setStateOn(s_core);
-
     if (stateIsOn(s_dbgNotStarted))
       startDebugger(0);
 
     // TODO support non-local URLs
     queueCmd(new GDBCommand(GDBMI::FileExecAndSymbols, debugee.toLocalFile()));
-    queueCmd(new GDBCommand(GDBMI::NonMI, "core " + coreFile.toLocalFile()));
+    queueCmd(new GDBCommand(GDBMI::NonMI, "core " + coreFile.toLocalFile(), this, &DebugSession::handleCoreFile, true));
 
     raiseEvent(connected_to_program);
     raiseEvent(program_state_changed);
 }
 
+void DebugSession::handleCoreFile(const GDBMI::ResultRecord& r)
+{
+    if (r.reason != "error") {
+        setStateOn(s_programExited|s_core);
+    } else {
+        KMessageBox::information(
+            qApp->activeWindow(),
+            i18n("<b>Failed to load core file</b>"
+                "<p>Debugger reported the following error:"
+                "<p><tt>%1", r["msg"].literal()),
+            i18n("Debugger error"));
+
+        // How should we proceed at this point? Stop the debugger?
+    }
+}
+
 void DebugSession::attachToProcess(int pid)
 {
     kDebug() << pid;
 
-    setStateOff(s_appNotStarted|s_programExited);
+    if (stateIsOn(s_dbgNotStarted))
+      startDebugger(0);
+
     setStateOn(s_attached);
 
     //set current state to running, after attaching we will get *stopped response
     setStateOn(s_appRunning);
 
-    if (stateIsOn(s_dbgNotStarted))
-      startDebugger(0);
-
     // Currently, we always start debugger with a name of binary,
     // we might be connecting to a different binary completely,
     // so cancel all symbol tables gdb has.
@@ -528,11 +514,6 @@ void DebugSession::addCommandToFront(GDBCommand* cmd)
     queueCmd(cmd, QueueAtFront);
 }
 
-void DebugSession::addCommandBeforeRun(GDBCommand* cmd)
-{
-    queueCmd(cmd, QueueWhileInterrupted);
-}
-
 // Fairly obvious that we'll add whatever command you give me to a queue
 // If you tell me to, I'll put it at the head of the queue so it'll run ASAP
 // Not quite so obvious though is that if we are going to run again. then any
@@ -556,7 +537,7 @@ void DebugSession::queueCmd(GDBCommand *cmd, QueuePosition queue_where)
 
     commandQueue_->enqueue(cmd, queue_where);
 
-    kDebug(9012) << "QUEUE: " << cmd->initialString() << (stateReloadInProgress_ ? "(state reloading)" : "");
+    kDebug(9012) << "QUEUE: " << cmd->initialString() << (stateReloadInProgress_ ? "(state reloading)" : "") << commandQueue_->count() << "pending";
 
     bool varCommandWithContext= (cmd->type() >= GDBMI::VarAssign
                                  && cmd->type() <= GDBMI::VarUpdate
@@ -661,7 +642,7 @@ void DebugSession::destroyCmds()
 }
 
 
-void DebugSession::slotProgramStopped(const GDBMI::ResultRecord& r)
+void DebugSession::slotProgramStopped(const GDBMI::AsyncRecord& r)
 {
     /* By default, reload all state on program stop.  */
     state_reload_needed = true;
@@ -776,6 +757,19 @@ void DebugSession::slotProgramStopped(const GDBMI::ResultRecord& r)
 }
 
 
+void DebugSession::processNotification(const GDBMI::AsyncRecord & async)
+{
+    if (async.reason == "thread-group-started") {
+        setStateOff(s_appNotStarted | s_programExited);
+    } else if (async.reason == "thread-group-exited") {
+        setStateOn(s_programExited);
+    } else if (async.reason == "library-loaded") {
+        // do nothing
+    } else {
+        kDebug(9012) << "Unhandled notification: " << async.reason;
+    }
+}
+
 void DebugSession::reloadProgramState()
 {
     raiseEvent(program_state_changed);
@@ -836,25 +830,6 @@ void DebugSession::programFinished(const QString& msg)
 }
 
 
-void DebugSession::parseStreamRecord(const GDBMI::StreamRecord& s)
-{
-    if (s.reason == '~')
-    {
-        QString line = s.message;
-        if (line.startsWith("Program terminated")) {
-            //when examining core file
-            setStateOff(s_appRunning);
-            setStateOn(s_appNotStarted|s_programExited);
-        } else if (line.startsWith("The program no longer exists")
-                   || line.startsWith("Program exited")) {
-            programNoApp(line);
-        } else if (!line.isEmpty() && line.at(0) == '[' && line.contains(QRegExp("^\\[Inferior \\d+ \\(.*process|target.*\\) exited .*\\]"))) {
-            m_inferiorExitCode = line;
-            addCommand(new CliCommand(GDBMI::NonMI, "info inferiors", this,  &DebugSession::lastInferiorHandler));
-        }
-    }
-}
-
 bool DebugSession::startDebugger(KDevelop::ILaunchConfiguration* cfg)
 {
     kDebug(9012) << "Starting debugger controller";
@@ -886,31 +861,35 @@ bool DebugSession::startDebugger(KDevelop::ILaunchConfiguration* cfg)
 
     connect(gdb, SIGNAL(ready()), this, SLOT(gdbReady()));
     connect(gdb, SIGNAL(gdbExited()), this, SLOT(gdbExited()));
-    connect(gdb, SIGNAL(programStopped(GDBMI::ResultRecord)),
-            this, SLOT(slotProgramStopped(GDBMI::ResultRecord)));
-    connect(gdb, SIGNAL(programStopped(GDBMI::ResultRecord)),
-            this, SIGNAL(programStopped(GDBMI::ResultRecord)));
+    connect(gdb, SIGNAL(programStopped(GDBMI::AsyncRecord)),
+            this, SLOT(slotProgramStopped(GDBMI::AsyncRecord)));
+    connect(gdb, SIGNAL(programStopped(GDBMI::AsyncRecord)),
+            this, SIGNAL(programStopped(GDBMI::AsyncRecord)));
     connect(gdb, SIGNAL(programRunning()),
             this, SLOT(programRunning()));
-
-    connect(gdb, SIGNAL(streamRecord(GDBMI::StreamRecord)),
-            this, SLOT(parseStreamRecord(GDBMI::StreamRecord)));
+    connect(gdb, SIGNAL(notification(GDBMI::AsyncRecord)),
+            this, SLOT(processNotification(GDBMI::AsyncRecord)));
 
     // Start gdb. Do this after connecting all signals so that initial
     // GDB output, and important events like "GDB died" are reported.
 
-
-    if (cfg)
     {
-        KConfigGroup config = cfg->config();
-        m_gdb.data()->start(config);
-    }
-    else
-    {
-        // FIXME: this is hack, I am not sure there's any way presently
-        // to edit this via GUI.
-        KConfigGroup config(KGlobal::config(), "GDB Debugger");
-        m_gdb.data()->start(config);
+        QStringList extraArguments;
+        if (m_testing)
+            extraArguments << "--nx"; // do not load any .gdbinit files
+
+        if (cfg)
+        {
+            KConfigGroup config = cfg->config();
+            m_gdb.data()->start(config, extraArguments);
+        }
+        else
+        {
+            // FIXME: this is hack, I am not sure there's any way presently
+            // to edit this via GUI.
+        	KConfigGroup config(KGlobal::config(), "GDB Debugger");
+            m_gdb.data()->start(config, extraArguments);
+        }
     }
 
     setStateOff(s_dbgNotStarted);
@@ -938,6 +917,10 @@ bool DebugSession::startDebugger(KDevelop::ILaunchConfiguration* cfg)
 
     QString fileName = KStandardDirs::locate("data", "kdevgdb/printers/gdbinit");
     if (!fileName.isEmpty()) {
+        QFileInfo fileInfo(fileName);
+        QString quotedPrintersPath = fileInfo.dir().path().replace('\\', "\\\\").replace('"', "\\\"");
+        queueCmd(new GDBCommand(GDBMI::NonMI,
+            QString("python sys.path.insert(0, \"%0\")").arg(quotedPrintersPath)));
         queueCmd(new GDBCommand(GDBMI::NonMI, "source " + fileName));
     }
 
@@ -951,9 +934,10 @@ bool DebugSession::startProgram(KDevelop::ILaunchConfiguration* cfg, IExecutePlu
         emit showMessage(i18n("Running program"), 1000);
     }
 
-    if (stateIsOn(s_dbgNotStarted))
+    if (stateIsOn(s_dbgNotStarted)) {
         if (!startDebugger(cfg))
             return false;
+    }
 
     if (stateIsOn(s_shuttingDown)) {
         kDebug() << "Tried to run when debugger shutting down";
@@ -1102,8 +1086,6 @@ bool DebugSession::startProgram(KDevelop::ILaunchConfiguration* cfg, IExecutePlu
         queueCmd(new GDBCommand(GDBMI::ExecRun));
     }
 
-    setStateOff(s_appNotStarted|s_programExited);
-
     {
         QString startWith = grp.readEntry(GDBDebugger::startWithEntry, QString("ApplicationOutput"));
         if (startWith == "GdbConsole") {
@@ -1155,8 +1137,6 @@ void DebugSession::slotKill()
     // The -exec-abort is not implemented in gdb
     // queueCmd(new GDBCommand(GDBMI::ExecAbort));
     queueCmd(new GDBCommand(GDBMI::NonMI, "kill"));
-
-    setStateOn(s_appNotStarted);
 }
 
 // **************************************************************************
@@ -1474,22 +1454,6 @@ void DebugSession::handleTargetAttach(const GDBMI::ResultRecord& r)
     }
 }
 
-void DebugSession::lastInferiorHandler(const QStringList& l)
-{
-    //* 1    <null>
-    QRegExp rx("^\\*?\\s+\\d+\\s+\\<null\\>\\s.*$");
-
-    for (int i = 2 ; i < l.size(); i++) {
-        if (!rx.exactMatch(l[i])) {
-            kDebug() << "Still running: " << l[i];
-            return;
-        }
-    }
-    kDebug() << "Exiting";
-    programNoApp(m_inferiorExitCode);
-    state_reload_needed = false;
-}
-
 }
 
 
diff --git a/debuggers/gdb/debugsession.h b/debuggers/gdb/debugsession.h
index 7a1a3d9..146900f 100644
--- a/debuggers/gdb/debugsession.h
+++ b/debuggers/gdb/debugsession.h
@@ -83,7 +83,7 @@ Q_SIGNALS:
     void applicationStandardErrorLines(const QStringList& lines);
     void showMessage(const QString& message, int timeout);
     void reset();
-    void programStopped(const GDBMI::ResultRecord& mi_record);
+    void programStopped(const GDBMI::AsyncRecord& mi_record);
 
 public Q_SLOTS:
     /**
@@ -112,6 +112,13 @@ public Q_SLOTS:
      */
     void attachToProcess(int pid);
 
+protected:
+    /**
+     * Testing mode affects a (very!) limited number of settings in an attempt to create
+     * a cleaner and more reproducible environment for unit tests.
+     */
+    void setTesting(bool testing);
+
 Q_SIGNALS:
     void raiseGdbConsoleViews();
 
@@ -128,11 +135,9 @@ private:
     KDevelop::ProcessLineMaker *m_procLineMaker;
     KDevelop::ProcessLineMaker *m_gdbLineMaker;
     DebuggerState m_sessionState;
-    bool justRestarted_;
     KConfigGroup m_config;
     QWeakPointer<GDB> m_gdb;
-
-
+    bool m_testing;
 
 
 public:
@@ -194,12 +199,6 @@ public:
     */
     void addCommandToFront(GDBCommand* cmd);
 
-    /* If current command queue has any command
-       for which isRun is true, inserts 'cmd'
-       before the first such command. Otherwise,
-       works the same as addCommand. */
-    void addCommandBeforeRun(GDBCommand* cmd);
-
     bool stateIsOn(DBGStateFlags state) const;
     DBGStateFlags debuggerState() const;
 
@@ -244,25 +243,13 @@ private:
 
     bool startDebugger(KDevelop::ILaunchConfiguration* cfg);
 
-    ///Checks if exited inferior is the last one, if so ends the debug session.
-    void lastInferiorHandler(const QStringList& l);
-
 private Q_SLOTS:
 
     void gdbReady();
 
     void gdbExited();
 
-    void slotProgramStopped(const GDBMI::ResultRecord& mi_record);
-
-    /** Parses the CLI output line, and catches interesting messages
-        like "Program exited". This is intended to allow using console
-        commands in the gdb window despite the fact that GDB does not
-        produce right MI notification for CLI commands. I.e. if you
-        run "continue" there will be no MI message if the application has
-        exited.
-    */
-    void parseStreamRecord(const GDBMI::StreamRecord& s);
+    void slotProgramStopped(const GDBMI::AsyncRecord& mi_record);
 
     /** Default handler for errors.
         Tries to guess is the error message is telling that target is
@@ -273,6 +260,9 @@ private Q_SLOTS:
     /**Triggered every time program begins/continues it's execution.*/
     void programRunning();
 
+    /** Handle MI async notifications. */
+    void processNotification(const GDBMI::AsyncRecord& n);
+
     // All of these slots are entered in the controller's thread, as they use queued connections or are called internally
     void queueCmd(GDBCommand *cmd, QueuePosition queue_where = QueueAtEnd);
 
@@ -290,6 +280,7 @@ private Q_SLOTS:
     void handleVersion(const QStringList& s);
     void handleFileExecAndSymbols(const GDBMI::ResultRecord& r);
     void handleTargetAttach(const GDBMI::ResultRecord& r);
+    void handleCoreFile(const GDBMI::ResultRecord& r);
 
 public Q_SLOTS:
     void slotKill();
diff --git a/debuggers/gdb/disassemblewidget.cpp b/debuggers/gdb/disassemblewidget.cpp
index 91194ed..a000f1e 100644
--- a/debuggers/gdb/disassemblewidget.cpp
+++ b/debuggers/gdb/disassemblewidget.cpp
@@ -108,12 +108,50 @@ DisassembleWindow::DisassembleWindow(QWidget *parent, DisassembleWidget* widget)
     connect(m_selectAddrAction, SIGNAL(triggered()), widget, SLOT(slotChangeAddress()));
 
     m_jumpToLocation = new QAction(KIcon("debug-execute-to-cursor"), i18n("&Jump to Cursor"), this);
-    m_jumpToLocation->setWhatsThis(i18n("Sets the execution pointer to the current cursor position."));
+    m_jumpToLocation->setToolTip(i18n("Sets the execution pointer to the current cursor position."));
     connect(m_jumpToLocation,SIGNAL(triggered()), widget, SLOT(jumpToCursor()));
 
     m_runUntilCursor = new QAction(KIcon("debug-run-cursor"), i18n("&Run to Cursor"), this);
-    m_runUntilCursor->setWhatsThis(i18n("Continues execution until the cursor position is reached."));
+    m_runUntilCursor->setToolTip(i18n("Continues execution until the cursor position is reached."));
     connect(m_runUntilCursor,SIGNAL(triggered()), widget, SLOT(runToCursor()));
+
+    m_disassemblyFlavorAtt = new QAction(i18n("&AT&&T"), this);
+    m_disassemblyFlavorAtt->setToolTip(i18n("GDB will use the AT&T disassembly flavor (e.g. mov 0xc(%ebp),%eax)."));
+    m_disassemblyFlavorAtt->setData(DisassemblyFlavorATT);
+    m_disassemblyFlavorAtt->setCheckable(true);
+
+    m_disassemblyFlavorIntel = new QAction(i18n("&Intel"), this);
+    m_disassemblyFlavorIntel->setToolTip(i18n("GDB will use the Intel disassembly flavor (e.g. mov eax, DWORD PTR [ebp+0xc])."));
+    m_disassemblyFlavorIntel->setData(DisassemblyFlavorIntel);
+    m_disassemblyFlavorIntel->setCheckable(true);
+
+    m_disassemblyFlavorActionGroup = new QActionGroup(this);
+    m_disassemblyFlavorActionGroup->setExclusive(true);
+    m_disassemblyFlavorActionGroup->addAction(m_disassemblyFlavorAtt);
+    m_disassemblyFlavorActionGroup->addAction(m_disassemblyFlavorIntel);
+
+    connect(m_disassemblyFlavorActionGroup, SIGNAL(triggered(QAction*)),
+            widget, SLOT(setDisassemblyFlavor(QAction*)));
+    }
+}
+
+void DisassembleWindow::setDisassemblyFlavor(DisassemblyFlavor flavor)
+{
+    switch(flavor)
+    {
+    default:
+    case DisassemblyFlavorUnknown:
+        m_disassemblyFlavorAtt->setChecked(false);
+        m_disassemblyFlavorIntel->setChecked(false);
+        break;
+    case DisassemblyFlavorATT:
+        m_disassemblyFlavorAtt->setChecked(true);
+        m_disassemblyFlavorIntel->setChecked(false);
+        break;
+    case DisassemblyFlavorIntel:
+        m_disassemblyFlavorAtt->setChecked(false);
+        m_disassemblyFlavorIntel->setChecked(true);
+        break;
     }
 }
 
@@ -123,6 +161,9 @@ void DisassembleWindow::contextMenuEvent(QContextMenuEvent *e)
         popup.addAction(m_selectAddrAction);
         popup.addAction(m_jumpToLocation);
         popup.addAction(m_runUntilCursor);
+        QMenu* disassemblyFlavorMenu = popup.addMenu(i18n("Disassembly flavor"));
+        disassemblyFlavorMenu->addAction(m_disassemblyFlavorAtt);
+        disassemblyFlavorMenu->addAction(m_disassemblyFlavorIntel);
         popup.exec(e->globalPos());
 }
 /***************************************************************************/
@@ -284,6 +325,7 @@ void DisassembleWidget::slotActivate(bool activate)
         active_ = activate;
         if (active_)
         {
+            updateDisassemblyFlavor();
             m_registersManager->updateRegisters();
             if (!displayCurrent())
                 disassembleMemoryRegion();
@@ -321,17 +363,16 @@ void DisassembleWidget::disassembleMemoryRegion(const QString& from, const QStri
 
     //only get $pc
     if (from.isEmpty()){
-        s->addCommandToFront(
+        s->addCommand(
                     new GDBCommand(DataDisassemble, "-s \"$pc\" -e \"$pc+1\" -- 0", this, &DisassembleWidget::updateExecutionAddressHandler ) );
     }else{
 
         QString cmd = (to.isEmpty())?
         QString("-s %1 -e \"%1 + 256\" -- 0").arg(from ):
         QString("-s %1 -e %2+1 -- 0").arg(from).arg(to); // if both addr set
-        
-        s->addCommandToFront(
-        new GDBCommand(DataDisassemble, cmd, this, &DisassembleWidget::disassembleMemoryHandler ) );
 
+        s->addCommand(
+            new GDBCommand(DataDisassemble, cmd, this, &DisassembleWidget::disassembleMemoryHandler ) );
    }
 }
 
@@ -405,7 +446,9 @@ void DisassembleWidget::enableControls(bool enabled)
 
 void DisassembleWidget::slotChangeAddress()
 {
-    if(!m_dlg) return;
+    if(!m_dlg) {
+        return;
+    }
     m_dlg->updateOkState();
     
     if (!m_disassembleWindow->selectedItems().isEmpty()) {
@@ -438,6 +481,70 @@ void DisassembleWidget::update(const QString &address)
     m_registersManager->updateRegisters();
 }
 
+void DisassembleWidget::setDisassemblyFlavor(QAction* action)
+{
+    DebugSession* s = qobject_cast<DebugSession*>(KDevelop::ICore::
+            self()->debugController()->currentSession());
+    if(!s || !s->isRunning()) {
+        return;
+    }
+
+    DisassemblyFlavor disassemblyFlavor = static_cast<DisassemblyFlavor>(action->data().toInt());
+    QString cmd;
+    switch(disassemblyFlavor)
+    {
+    default:
+        // unknown flavor, do not build a GDB command
+        break;
+    case DisassemblyFlavorATT:
+        cmd = "disassembly-flavor att";
+        break;
+    case DisassemblyFlavorIntel:
+        cmd = "disassembly-flavor intel";
+        break;
+    }
+    kDebug(9012) << "Disassemble widget set " << cmd;
+
+    if (!cmd.isEmpty()) {
+        s->addCommand(
+                new GDBCommand(GdbSet, cmd, this, &DisassembleWidget::setDisassemblyFlavorHandler));
+    }
+}
+
+void DisassembleWidget::setDisassemblyFlavorHandler(const GDBMI::ResultRecord& r)
+{
+    if (r.reason == "done" && active_) {
+        disassembleMemoryRegion();
+    }
+}
+
+void DisassembleWidget::updateDisassemblyFlavor()
+{
+    DebugSession* s = qobject_cast<DebugSession*>(KDevelop::ICore::
+            self()->debugController()->currentSession());
+    if(!s || !s->isRunning()) {
+        return;
+    }
+
+    s->addCommand(
+                new GDBCommand(GdbShow, "disassembly-flavor", this, &DisassembleWidget::showDisassemblyFlavorHandler));
+}
+
+void DisassembleWidget::showDisassemblyFlavorHandler(const GDBMI::ResultRecord& r)
+{
+    const GDBMI::Value& value = r["value"];
+    kDebug(9012) << "Disassemble widget disassembly flavor" << value.literal();
+
+    DisassemblyFlavor disassemblyFlavor = DisassemblyFlavorUnknown;
+    if (value.literal() == "att") {
+        disassemblyFlavor = DisassemblyFlavorATT;
+    } else if (value.literal() == "intel") {
+        disassemblyFlavor = DisassemblyFlavorIntel;
+    }
+    m_disassembleWindow->setDisassemblyFlavor(disassemblyFlavor);
+}
+
+
 }
 
 #include "disassemblewidget.moc"
diff --git a/debuggers/gdb/disassemblewidget.h b/debuggers/gdb/disassemblewidget.h
index ccffc2f..c4f86dd 100644
--- a/debuggers/gdb/disassemblewidget.h
+++ b/debuggers/gdb/disassemblewidget.h
@@ -75,11 +75,19 @@ private:
 
 class DisassembleWidget;
 
+enum DisassemblyFlavor {
+    DisassemblyFlavorUnknown = -1,
+    DisassemblyFlavorATT = 0,
+    DisassemblyFlavorIntel,
+};
+
 class DisassembleWindow : public QTreeWidget
 {
 public:
     DisassembleWindow(QWidget *parent, DisassembleWidget* widget);
 
+    void setDisassemblyFlavor(DisassemblyFlavor flavor);
+
 protected:
    virtual void contextMenuEvent(QContextMenuEvent *e);
 
@@ -87,6 +95,9 @@ private:
     QAction* m_selectAddrAction;
     QAction* m_jumpToLocation;
     QAction* m_runUntilCursor;
+    QAction* m_disassemblyFlavorAtt;
+    QAction* m_disassemblyFlavorIntel;
+    QActionGroup* m_disassemblyFlavorActionGroup;
 };
 
 class Breakpoint;
@@ -125,6 +136,7 @@ private Q_SLOTS:
     void currentSessionChanged(KDevelop::IDebugSession* session);
     void jumpToCursor();
     void runToCursor();
+    void setDisassemblyFlavor(QAction* action);
 
 protected:
     virtual void showEvent(QShowEvent*);
@@ -133,6 +145,7 @@ protected:
 
 private:
     bool displayCurrent();
+    void updateDisassemblyFlavor();
     
     /// Disassembles memory region from..to
     /// if from is empty current execution position is used
@@ -143,6 +156,8 @@ private:
     /// callbacks for GDBCommands
     void disassembleMemoryHandler(const GDBMI::ResultRecord& r);
     void updateExecutionAddressHandler(const GDBMI::ResultRecord& r);
+    void setDisassemblyFlavorHandler(const GDBMI::ResultRecord& r);
+    void showDisassemblyFlavorHandler(const GDBMI::ResultRecord& r);
 
     //for str to uint conversion.
     bool ok;
@@ -151,10 +166,9 @@ private:
     unsigned long    upper_;
     unsigned long    address_;
 
-    RegistersManager* m_registersManager ;
+    RegistersManager* m_registersManager;
+    DisassembleWindow* m_disassembleWindow;
 
-    DisassembleWindow * m_disassembleWindow;
-    
     static const KIcon icon_;
     SelectAddrDialog* m_dlg;
 
diff --git a/debuggers/gdb/gdb.cpp b/debuggers/gdb/gdb.cpp
index 4642087..3ea9ede 100644
--- a/debuggers/gdb/gdb.cpp
+++ b/debuggers/gdb/gdb.cpp
@@ -44,7 +44,7 @@
 using namespace GDBDebugger;
 
 GDB::GDB(QObject* parent)
-: QObject(parent), process_(0), sawPrompt_(false), currentCmd_(0), receivedReply_(false), isRunning_(false), childPid_(0)
+: QObject(parent), process_(0), currentCmd_(0), isRunning_(false)
 {
 }
 
@@ -59,7 +59,7 @@ GDB::~GDB()
     }
 }
 
-void GDB::start(KConfigGroup& config)
+void GDB::start(KConfigGroup& config, const QStringList& extraArguments)
 {
     // FIXME: verify that default value leads to something sensible
     KUrl gdbUrl = config.readEntry(GDBDebugger::gdbPathEntry, KUrl());
@@ -82,7 +82,7 @@ void GDB::start(KConfigGroup& config)
             SLOT(processErrored(QProcess::ProcessError)));
 
 
-    QStringList arguments;
+    QStringList arguments = extraArguments;
     arguments << "--interpreter=mi2" << "-quiet";
 
     KUrl shell = config.readEntry(GDBDebugger::debuggerShellEntry, KUrl());
@@ -132,11 +132,11 @@ void GDB::execute(GDBCommand* command)
     kDebug(9012) << "SEND:" << commandText;
     
     isRunning_ = false;
-    receivedReply_ = false;
 
     QByteArray commandUtf8 = commandText.toUtf8();
 
     process_->write(commandUtf8, commandUtf8.length());
+    command->markAsSubmitted();
 
     QString prettyCmd = currentCmd_->cmdToSend();
     prettyCmd.remove( QRegExp("set prompt \032.\n") );
@@ -157,9 +157,7 @@ void GDB::interrupt()
 {
     //TODO:win32 Porting needed
     int pid = process_->pid();
-    if (childPid_) {
-        ::kill(childPid_, SIGINT);
-    } else if (pid != 0) {
+    if (pid != 0) {
         ::kill(pid, SIGINT);
     }
 }
@@ -202,11 +200,6 @@ void GDB::readyReadStandardError()
 void GDB::processLine(const QByteArray& line)
 {
     kDebug(9012) << "GDB output: " << line;
-    if(!currentCmd_)
-    {
-        kDebug(9012) << "No current command\n";
-        return;
-    }
 
     FileSymbol file;
     file.contents = line;
@@ -227,145 +220,136 @@ void GDB::processLine(const QByteArray& line)
         return;
     }
 
-   if (!sawPrompt_)
-   {
-       if (r->kind == GDBMI::Record::Stream)
-       {
-           GDBMI::StreamRecord& s = dynamic_cast<GDBMI::StreamRecord&>(*r);
-           emit userCommandOutput(s.message);
-       }
-       else if (r->kind == GDBMI::Record::Prompt)
-       {
-           sawPrompt_ = true;
-       }
-   }
-   else
-   {
-       
-       #ifndef DEBUG_NO_TRY
-       try
-       {
-       #endif
-           switch(r->kind)
-           {
-           case GDBMI::Record::Result: {
-
-               GDBMI::ResultRecord& result = static_cast<GDBMI::ResultRecord&>(*r);
-
-               emit internalCommandOutput(QString::fromUtf8(line) + '\n');
-
-               if (result.reason == "thread-group-started") {
-                   receivedReply_ = true;
-                   //     (gdb) -exec-run
-                   //     =thread-group-started,id="i1",pid="16768"
-                   if (line.contains("pid=\"")) {
-                       QList<QByteArray> splitLine = line.split(',');
-                       if (splitLine.size() > 2) {
-                           QByteArray pidStr = splitLine[2];
-                           pidStr.chop(1);
-                           childPid_ = pidStr.mid(5).toULong();
-                           if (childPid_ == 0) {
-                               kDebug() << "line=" << line << "pidStr=" << pidStr << pidStr.mid(5) << "pid=" << childPid_;
-                           }
-                       }
-                   }
-               }
-
-               // FIXME: the code below should be reviewed to consider result record
-               // subtype when doing all decisions.
-               
-               if (result.subkind == GDBMI::ResultRecord::GeneralNotification)
-               {
-                   kDebug(9012) << "General notification";
-                   emit notification(result);
-                   return;
-               }
-               
-               if (result.reason == "stopped")
-               {
-                   //stopped is *not* a reply, wait for ^running or ^done (running before stopped, done after stopped)
-                   isRunning_ = false;
-                   emit programStopped(result);
-               }
-               else if (result.reason == "running")
-               {
-                   receivedReply_ = true;
-                   isRunning_ = true;
-                   emit programRunning();
-               }
-               else
-               {
-                   receivedReply_ = true;
-               }
-
-               if (result.reason == "done")
-               {
-                   currentCmd_->invokeHandler(result);
-                   emit resultRecord(result);
-               }
-               else if (result.reason == "error")
-               {
-                   kDebug(9012) << "Handling error";
-                   // Some commands want to handle errors themself.
-                   if (currentCmd_->handlesError() &&
-                       currentCmd_->invokeHandler(result))
-                   {
-                       kDebug(9012) << "Invoked custom handler\n";
-                       // Done, nothing more needed
-                   }
-                   else
-                       emit error(result);
-               }
-
-               break;
-           }
-
-           case GDBMI::Record::Stream: {
-
-               GDBMI::StreamRecord& s = dynamic_cast<GDBMI::StreamRecord&>(*r);
-
-               if (s.reason == '@')
-                   emit applicationOutput(s.message);
-
-               if (currentCmd_->isUserCommand())
-                   emit userCommandOutput(s.message);
-               else
-                   emit internalCommandOutput(s.message);
-
-               currentCmd_->newOutput(s.message);
-
-               emit streamRecord(s);
-
-               break;
-           }
-           case GDBMI::Record::Prompt:
-               break;
-           }
-       #ifndef DEBUG_NO_TRY
-       }
-       catch(const std::exception& e)
-       {
-           KMessageBox::detailedSorry(
-               qApp->activeWindow(),
-               i18nc("<b>Internal debugger error</b>",
-                     "<p>The debugger component encountered internal error while "
-                     "processing reply from gdb. Please submit a bug report."),
-               i18n("The exception is: %1\n"
-                    "The MI response is: %2", e.what(),
-                    QString::fromLatin1(line)),
-               i18n("Internal debugger error"));
-            isRunning_ = false;
-            receivedReply_ = true;
-       }
-       #endif
-
-       if (receivedReply_ && !isRunning_)
-       {
-           delete currentCmd_;
-           currentCmd_ = 0;
-           emit ready();
-       }
+    #ifndef DEBUG_NO_TRY
+    try
+    {
+    #endif
+        switch(r->kind)
+        {
+        case GDBMI::Record::Result: {
+            GDBMI::ResultRecord& result = static_cast<GDBMI::ResultRecord&>(*r);
+
+            emit internalCommandOutput(QString::fromUtf8(line) + '\n');
+
+            // GDB doc: "running" and "exit" are status codes equivalent to "done"
+            if (result.reason == "done" || result.reason == "running" || result.reason == "exit")
+            {
+                if (!currentCmd_) {
+                    kDebug(9012) << "Received a result without a pending command";
+                } else {
+                    Q_ASSERT(currentCmd_->token() == result.token);
+                    currentCmd_->markAsCompleted();
+                    kDebug(9012) << "Command successful, times" << currentCmd_->totalProcessingTime() << currentCmd_->queueTime() << currentCmd_->gdbProcessingTime();
+                    currentCmd_->invokeHandler(result);
+                }
+            }
+            else if (result.reason == "error")
+            {
+                kDebug(9012) << "Handling error";
+                currentCmd_->markAsCompleted();
+                kDebug(9012) << "Command error, times" << currentCmd_->totalProcessingTime() << currentCmd_->queueTime() << currentCmd_->gdbProcessingTime();
+                // Some commands want to handle errors themself.
+                if (currentCmd_->handlesError() &&
+                    currentCmd_->invokeHandler(result))
+                {
+                    kDebug(9012) << "Invoked custom handler\n";
+                    // Done, nothing more needed
+                }
+                else
+                    emit error(result);
+            }
+            else
+            {
+                kDebug(9012) << "Unhandled result code: " << result.reason;
+            }
+
+            delete currentCmd_;
+            currentCmd_ = nullptr;
+            emit ready();
+            break;
+        }
+
+        case GDBMI::Record::Async: {
+            GDBMI::AsyncRecord& async = dynamic_cast<GDBMI::AsyncRecord&>(*r);
+
+            switch (async.subkind) {
+            case GDBMI::AsyncRecord::Exec: {
+                // Prefix '*'; asynchronous state changes of the target
+                if (async.reason == "stopped")
+                {
+                    isRunning_ = false;
+                    emit programStopped(async);
+                }
+                else if (async.reason == "running")
+                {
+                    isRunning_ = true;
+                    emit programRunning();
+                }
+                else
+                {
+                    kDebug(9012) << "Unhandled exec notification: " << async.reason;
+                }
+                break;
+            }
+
+            case GDBMI::AsyncRecord::Notify: {
+                // Prefix '='; supplementary information that we should handle (new breakpoint etc.)
+                emit notification(async);
+                break;
+            }
+
+            case GDBMI::AsyncRecord::Status: {
+                // Prefix '+'; GDB documentation:
+                // On-going status information about progress of a slow operation; may be ignored
+                break;
+            }
+
+            default:
+                Q_ASSERT(false);
+            }
+            break;
+        }
+
+        case GDBMI::Record::Stream: {
+
+            GDBMI::StreamRecord& s = dynamic_cast<GDBMI::StreamRecord&>(*r);
+
+            if (s.subkind == GDBMI::StreamRecord::Target) {
+                emit applicationOutput(s.message);
+            } else {
+                if (currentCmd_ && currentCmd_->isUserCommand())
+                    emit userCommandOutput(s.message);
+                else
+                    emit internalCommandOutput(s.message);
+
+                if (currentCmd_)
+                    currentCmd_->newOutput(s.message);
+            }
+
+            emit streamRecord(s);
+
+            break;
+        }
+
+        case GDBMI::Record::Prompt:
+            break;
+        }
+    #ifndef DEBUG_NO_TRY
+    }
+    catch(const std::exception& e)
+    {
+        KMessageBox::detailedSorry(
+            qApp->activeWindow(),
+            i18nc("<b>Internal debugger error</b>",
+                    "<p>The debugger component encountered internal error while "
+                    "processing reply from gdb. Please submit a bug report."),
+            i18n("The exception is: %1\n"
+                "The MI response is: %2", e.what(),
+                QString::fromLatin1(line)),
+            i18n("Internal debugger error"));
+        isRunning_ = false;
     }
+    #endif
 }
 
 // **************************************************************************
diff --git a/debuggers/gdb/gdb.h b/debuggers/gdb/gdb.h
index 31688cd..6c7193b 100644
--- a/debuggers/gdb/gdb.h
+++ b/debuggers/gdb/gdb.h
@@ -45,7 +45,7 @@ public:
 
     /** Starts GDB.  This should be done after connecting to all
         signals the client is interested in.  */
-    void start(KConfigGroup& config);
+    void start(KConfigGroup& config, const QStringList& extraArguments = {});
 
     /** Executes a command.  This method may be called at
         most once each time 'ready' is emitted.  When the
@@ -82,7 +82,7 @@ Q_SIGNALS:
 
     /** Emitted when GDB reports stop, with 'r' being the
         data provided by GDB. */
-    void programStopped(const GDBMI::ResultRecord& r);
+    void programStopped(const GDBMI::AsyncRecord& r);
     
     /** Emitted when GDB believes that the program is running.  */
     void programRunning();
@@ -94,11 +94,8 @@ Q_SIGNALS:
     */
     void streamRecord(const GDBMI::StreamRecord& s);
 
-    /** FIXME: temporary, to be eliminated.  */
-    void resultRecord(const GDBMI::ResultRecord& s);
-    
-    /** Reports a general MI notification.  */
-    void notification(const GDBMI::ResultRecord& n);
+    /** Reports an async notification record.  */
+    void notification(const GDBMI::AsyncRecord& n);
     
     /** Emitted for error that is not handled by the
         command being executed. */
@@ -132,7 +129,6 @@ private:
 private:
     QString gdbBinary_;
     KProcess* process_;
-    bool sawPrompt_;
 
     GDBCommand* currentCmd_;
 
@@ -141,10 +137,8 @@ private:
     /** The unprocessed output from gdb. Output is
         processed as soon as we see newline. */
     QByteArray buffer_;
-    
-    bool receivedReply_;
+
     bool isRunning_;
-    unsigned long childPid_;
 };
 }
 
diff --git a/debuggers/gdb/gdbcommand.cpp b/debuggers/gdb/gdbcommand.cpp
index 67abbd8..817962a 100644
--- a/debuggers/gdb/gdbcommand.cpp
+++ b/debuggers/gdb/gdbcommand.cpp
@@ -14,6 +14,7 @@
  ***************************************************************************/
 
 #include "gdbcommand.h"
+#include <QtCore/QDateTime>
 
 using namespace GDBMI;
 
@@ -21,20 +22,46 @@ namespace GDBDebugger
 {
 
 GDBCommand::GDBCommand(GDBMI::CommandType type, const QString &command)
-: type_(type), command_(command), handler_method(0), commandHandler_(0),
-  run(false), stateReloading_(false), handlesError_(false), m_thread(-1), m_frame(-1)
+    : type_(type)
+    , command_(command)
+    , handler_method(0)
+    , commandHandler_(0)
+    , stateReloading_(false)
+    , handlesError_(false)
+    , m_thread(-1)
+    , m_frame(-1)
+    , m_enqueueTimestamp(0)
+    , m_submitTimestamp(0)
+    , m_completeTimestamp(0)
 {
 }
 
 GDBCommand::GDBCommand(GDBMI::CommandType type, int index)
-: type_(type), command_(QString::number(index)), handler_method(0), commandHandler_(0),
-  run(false), stateReloading_(false), handlesError_(false), m_thread(-1), m_frame(-1)
+    : type_(type)
+    , command_(QString::number(index))
+    , handler_method(0)
+    , commandHandler_(0)
+    , stateReloading_(false)
+    , handlesError_(false)
+    , m_thread(-1)
+    , m_frame(-1)
+    , m_enqueueTimestamp(0)
+    , m_submitTimestamp(0)
+    , m_completeTimestamp(0)
 {
 }
 
 GDBCommand::GDBCommand(CommandType type, const QString& arguments, GDBCommandHandler* handler)
-: type_(type), command_(arguments), handler_method(0), commandHandler_(handler),
-  run(false), stateReloading_(false), m_thread(-1), m_frame(-1)
+    : type_(type)
+    , command_(arguments)
+    , handler_method(0)
+    , commandHandler_(handler)
+    , stateReloading_(false)
+    , m_thread(-1)
+    , m_frame(-1)
+    , m_enqueueTimestamp(0)
+    , m_submitTimestamp(0)
+    , m_completeTimestamp(0)
 {
     handlesError_ = handler->handlesError();
 }
@@ -46,11 +73,13 @@ QString GDBCommand::cmdToSend()
 
 QString GDBCommand::initialString() const
 {
-    if (type() == NonMI)
-        return command_;
-    else
+    QString result = QString::number(token());
+
+    if (type() == NonMI) {
+        result += command_;
+    } else
     {
-        QString result = gdbCommand();
+        result += gdbCommand();
 
         if (m_thread != -1)
             result = result + QString(" --thread %1").arg(m_thread);
@@ -59,9 +88,9 @@ QString GDBCommand::initialString() const
 
         if (!command_.isEmpty())
             result += ' ' + command_;
-        
-        return result;
     }
+
+    return result;
 }
 
 bool GDBCommand::isUserCommand() const
@@ -107,16 +136,6 @@ GDBCommand::~GDBCommand()
 {
 }
 
-bool GDBCommand::isRun() const
-{
-    return run;
-}
-
-void GDBCommand::setRun(bool run)
-{
-    this->run = run;
-}
-
 
 UserCommand::UserCommand(GDBMI::CommandType type, const QString& s)
 : GDBCommand(type, s)
@@ -607,5 +626,34 @@ bool GDBCommand::stateReloading() const
     return stateReloading_;
 }
 
+void GDBCommand::markAsEnqueued()
+{
+    m_enqueueTimestamp = QDateTime::currentMSecsSinceEpoch();
+}
+
+void GDBCommand::markAsSubmitted()
+{
+    m_submitTimestamp = QDateTime::currentMSecsSinceEpoch();
+}
+
+void GDBCommand::markAsCompleted()
+{
+    m_completeTimestamp = QDateTime::currentMSecsSinceEpoch();
+}
+
+qint64 GDBCommand::gdbProcessingTime() const
+{
+    return m_completeTimestamp - m_submitTimestamp;
+}
+
+qint64 GDBCommand::queueTime() const
+{
+    return m_submitTimestamp - m_enqueueTimestamp;
+}
+
+qint64 GDBCommand::totalProcessingTime() const
+{
+    return m_completeTimestamp - m_enqueueTimestamp;
+}
 
 }
diff --git a/debuggers/gdb/gdbcommand.h b/debuggers/gdb/gdbcommand.h
index e1ebc69..aa5e437 100644
--- a/debuggers/gdb/gdbcommand.h
+++ b/debuggers/gdb/gdbcommand.h
@@ -72,6 +72,17 @@ public:
     QString gdbCommand() const;
 
     /**
+     * Returns the MI token with which the command is sent, allowing the parser to match up
+     * the result message with the command.
+     */
+    uint32_t token() const {return token_;}
+
+    /**
+     * Set the MI token. This is done by \ref GDBCommandQueue.
+     */
+    void setToken(uint32_t token) {token_ = token;}
+
+    /**
      * Returns the thread that needs to be currently selected when this command is executed,
      * or -1 if there is no requirement.
      */
@@ -135,28 +146,41 @@ public:
 
     const QStringList& allStreamOutput() const;
 
-    // True if this command run then target for
-    // unspecified period of time -- that is either 'run' or
-    // 'continue'.
-    bool isRun() const;
-
-    void setRun(bool run);
-
     QString command() const;
 
     void setStateReloading(bool f);
 
     bool stateReloading() const;
 
+    /// Called when the command has been enqueued in the debug session
+    /// and the command is wait for being submitted to GDB.
+    void markAsEnqueued();
+
+    /// Called when the command has been submitted to GDB and the command
+    /// waits for completion by GDB.
+    void markAsSubmitted();
+
+    /// Called when the command has been completed and the response has arrived.
+    void markAsCompleted();
+
+    /// returns the amount of time (in ms) passed between submission and completion.
+    qint64 gdbProcessingTime() const;
+
+    /// returns the amount of time (in ms) passed between enqueuing and submission.
+    qint64 queueTime() const;
+
+    /// returns the amount of time (in ms) passed between enqueuing and completion.
+    qint64 totalProcessingTime() const;
+
 private:
     GDBMI::CommandType type_;
+    uint32_t token_;
     QString command_;
     QWeakPointer<QObject> handler_this;
     typedef void (QObject::* handler_t)(const GDBMI::ResultRecord&);
     handler_t handler_method;
     GDBCommandHandler *commandHandler_;
     QStringList lines;
-    bool run;
     bool stateReloading_;
 
 protected: // FIXME: should be private, after I kill the first ctor
@@ -166,6 +190,13 @@ protected: // FIXME: should be private, after I kill the first ctor
 private:
     int m_thread;
     int m_frame;
+    // remember the timestamps (in ms since start of the epoch) when this command
+    // - was added to the command queue (enqueued)
+    // - was submitted to GDB
+    // - was completed; response from GDB arrived
+    qint64 m_enqueueTimestamp;
+    qint64 m_submitTimestamp;
+    qint64 m_completeTimestamp;
 };
 
 class UserCommand : public GDBCommand
@@ -286,7 +317,6 @@ GDBCommand::GDBCommand(
   handler_this(handler_this),
   handler_method(static_cast<handler_t>(handler_method)),
   commandHandler_(0),
-  run(false),
   stateReloading_(false),
   handlesError_(handlesError),
   m_thread(-1),
@@ -302,11 +332,11 @@ GDBCommand::GDBCommand(
     void (Handler::* handler_method)(const GDBMI::ResultRecord&),
     bool handlesError)
 : type_(type),
+  token_(0),
   command_(QString::number(index)),
   handler_this(handler_this),
   handler_method(static_cast<handler_t>(handler_method)),
   commandHandler_(0),
-  run(false),
   stateReloading_(false),
   handlesError_(handlesError),
   m_thread(-1),
diff --git a/debuggers/gdb/gdbcommandqueue.cpp b/debuggers/gdb/gdbcommandqueue.cpp
index 801bc41..8ae7067 100644
--- a/debuggers/gdb/gdbcommandqueue.cpp
+++ b/debuggers/gdb/gdbcommandqueue.cpp
@@ -15,6 +15,8 @@
 // *                                                                        *
 // **************************************************************************
 
+#include <kdebug.h>
+
 #include "gdbcommandqueue.h"
 
 #include "mi/gdbmi.h"
@@ -24,6 +26,7 @@ using namespace GDBDebugger;
 using namespace GDBMI;
 
 CommandQueue::CommandQueue()
+    : m_tokenCounter(0)
 {
 }
 
@@ -32,8 +35,13 @@ CommandQueue::~CommandQueue()
     qDeleteAll(m_commandList);
 }
 
-void GDBDebugger::CommandQueue::enqueue(GDBCommand * command, QueuePosition insertPosition)
+void GDBDebugger::CommandQueue::enqueue(GDBCommand* command, QueuePosition insertPosition)
 {
+    ++m_tokenCounter;
+    if (m_tokenCounter == 0)
+        m_tokenCounter = 1;
+    command->setToken(m_tokenCounter);
+
     switch (insertPosition) {
         case QueueAtFront:
             m_commandList.prepend(command);
@@ -41,25 +49,48 @@ void GDBDebugger::CommandQueue::enqueue(GDBCommand * command, QueuePosition inse
         case QueueAtEnd:
             m_commandList.append(command);
             break;
-
-        case QueueWhileInterrupted: {
-            int i;
-            for (i = 0; i < m_commandList.count(); ++i)
-                if (m_commandList.at(i)->isRun())
-                    break;
-
-            m_commandList.insert(i, command);
-        }
     }
+    // take the time when this command was added to the command queue
+    command->markAsEnqueued();
 
     rationalizeQueue(command);
+    dumpQueue();
 }
 
-void CommandQueue::rationalizeQueue(GDBCommand * command)
+void CommandQueue::dumpQueue()
 {
-    if (command->type() >= ExecAbort && command->type() <= ExecUntil)
+    kDebug(9012) << "Pending commands" << m_commandList.count();
+    unsigned commandNum = 0;
+    foreach(const GDBCommand* command, m_commandList) {
+        kDebug(9012) << "Command" << commandNum << command->initialString();
+        ++commandNum;
+    }
+}
+
+void CommandQueue::rationalizeQueue(GDBCommand* command)
+{
+    if (command->type() >= ExecAbort && command->type() <= ExecUntil) {
+      removeObsoleteExecCommands(command);
       // Changing execution location, abort any variable updates
       removeVariableUpdates();
+      // ... and stack list updates
+      removeStackListUpdates();
+    }
+}
+
+void GDBDebugger::CommandQueue::removeObsoleteExecCommands(GDBCommand* command)
+{
+    if (command->type() == ExecContinue || command->type() == ExecUntil) {
+        // Remove all exec commands up the latest ExecContinue or ExecUntil
+        QMutableListIterator<GDBCommand*> it = m_commandList;
+        while (it.hasNext()) {
+            GDBCommand* currentCmd = it.next();
+            if (currentCmd != command && currentCmd->type() >= ExecAbort && currentCmd->type() <= ExecUntil) {
+                it.remove();
+                delete currentCmd;
+            }
+        }
+    }
 }
 
 void GDBDebugger::CommandQueue::removeVariableUpdates()
@@ -67,9 +98,26 @@ void GDBDebugger::CommandQueue::removeVariableUpdates()
     QMutableListIterator<GDBCommand*> it = m_commandList;
 
     while (it.hasNext()) {
-        CommandType type = it.next()->type();
-        if ((type >= VarEvaluateExpression && type <= VarListChildren) || type == VarUpdate)
+        GDBCommand* command = it.next();
+        CommandType type = command->type();
+        if ((type >= VarEvaluateExpression && type <= VarListChildren) || type == VarUpdate) {
+            it.remove();
+            delete command;
+        }
+    }
+}
+
+void GDBDebugger::CommandQueue::removeStackListUpdates()
+{
+    QMutableListIterator<GDBCommand*> it = m_commandList;
+
+    while (it.hasNext()) {
+        GDBCommand* command = it.next();
+        CommandType type = command->type();
+        if (type >= StackListArguments && type <= StackListLocals) {
             it.remove();
+            delete command;
+        }
     }
 }
 
@@ -89,7 +137,7 @@ bool GDBDebugger::CommandQueue::isEmpty() const
     return m_commandList.isEmpty();
 }
 
-GDBCommand * GDBDebugger::CommandQueue::nextCommand()
+GDBCommand* GDBDebugger::CommandQueue::nextCommand()
 {
     if (!m_commandList.isEmpty())
         return m_commandList.takeAt(0);
diff --git a/debuggers/gdb/gdbcommandqueue.h b/debuggers/gdb/gdbcommandqueue.h
index 7d82f45..8535d40 100644
--- a/debuggers/gdb/gdbcommandqueue.h
+++ b/debuggers/gdb/gdbcommandqueue.h
@@ -46,9 +46,13 @@ public:
 
 private:
     void rationalizeQueue(GDBCommand* command);
+    void removeObsoleteExecCommands(GDBCommand* command);
     void removeVariableUpdates();
+    void removeStackListUpdates();
+    void dumpQueue();
   
     QList<GDBCommand*> m_commandList;
+    uint32_t m_tokenCounter;
 };
 
 }
diff --git a/debuggers/gdb/gdbframestackmodel.cpp b/debuggers/gdb/gdbframestackmodel.cpp
index e9e1fce..d10e004 100644
--- a/debuggers/gdb/gdbframestackmodel.cpp
+++ b/debuggers/gdb/gdbframestackmodel.cpp
@@ -22,6 +22,8 @@
 #include "gdbframestackmodel.h"
 #include "gdbcommand.h"
 
+#include <KLocalizedString>
+
 using namespace KDevelop;
 
 QString getFunctionOrAddress(const GDBMI::Value &frame)
@@ -67,8 +69,13 @@ void GdbFrameStackModel::handleThreadInfo(const GDBMI::ResultRecord& r)
     int gidx = threads.size()-1;
     for (; gidx >= 0; --gidx) {
         KDevelop::FrameStackModel::ThreadItem i;
-        i.nr = threads[gidx]["id"].toInt();
-        i.name = getFunctionOrAddress(threads[gidx]["frame"]);
+        const GDBMI::Value & threadMI = threads[gidx];
+        i.nr = threadMI["id"].toInt();
+        if (threadMI["state"].literal() == "stopped") {
+            i.name = getFunctionOrAddress(threads[gidx]["frame"]);
+        } else {
+            i.name = i18n("(running)");
+        }
         threadsList << i;
     }
     setThreads(threadsList);
diff --git a/debuggers/gdb/gdbglobal.h b/debuggers/gdb/gdbglobal.h
index ef31c02..da6fe32 100644
--- a/debuggers/gdb/gdbglobal.h
+++ b/debuggers/gdb/gdbglobal.h
@@ -43,12 +43,10 @@ enum DBGStateFlag
 };
 
 Q_DECLARE_FLAGS(DBGStateFlags, DBGStateFlag)
-Q_DECLARE_OPERATORS_FOR_FLAGS(DBGStateFlags)
 
 enum QueuePosition {
     QueueAtEnd,
-    QueueAtFront,
-    QueueWhileInterrupted
+    QueueAtFront
 };
 
 
@@ -58,4 +56,6 @@ enum DataType { typeUnknown, typeValue, typePointer, typeReference,
 
 }
 
+Q_DECLARE_OPERATORS_FOR_FLAGS(GDBDebugger::DBGStateFlags)
+
 #endif
diff --git a/debuggers/gdb/gdblaunchconfig.cpp b/debuggers/gdb/gdblaunchconfig.cpp
index 7200998..3937f71 100644
--- a/debuggers/gdb/gdblaunchconfig.cpp
+++ b/debuggers/gdb/gdblaunchconfig.cpp
@@ -32,6 +32,7 @@
 #include <kparts/mainwindow.h>
 
 #include <outputview/outputmodel.h>
+#include <interfaces/idebugcontroller.h>
 #include <interfaces/ilaunchconfiguration.h>
 #include <util/environmentgrouplist.h>
 #include <interfaces/iproject.h>
@@ -146,9 +147,18 @@ KJob* GdbLauncher::start(const QString& launchMode, KDevelop::ILaunchConfigurati
     }
     if( launchMode == "debug" )
     {
-        QList<KJob*> l;
         Q_ASSERT(m_execute);
-        QString err;
+
+        if (KDevelop::ICore::self()->debugController()->currentSession() != nullptr) {
+            int answer = KMessageBox::warningYesNo(
+                nullptr,
+                i18n("A program is already being debugged. Do you want to abort the "
+                     "currently running debug session and continue with the launch?"));
+            if (answer == KMessageBox::No)
+                return nullptr;
+        }
+
+        QList<KJob*> l;
         KJob* depjob = m_execute->dependecyJob(cfg);
         if( depjob ) 
         {
diff --git a/debuggers/gdb/ksysguard/ProcessFilter.cpp b/debuggers/gdb/ksysguard/ProcessFilter.cpp
new file mode 100644
index 0000000..b37766e
--- /dev/null
+++ b/debuggers/gdb/ksysguard/ProcessFilter.cpp
@@ -0,0 +1,148 @@
+/*
+    KSysGuard, the KDE System Guard
+
+	Copyright (c) 2006-2007 John Tapsell <john.tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+
+/* For getuid() */
+#include <unistd.h>
+#include <sys/types.h>
+
+#include <QVariant>
+
+#include <kdebug.h>
+
+#include "ProcessModel.h"
+#include "ProcessModel_p.h"
+#include "ProcessFilter.h"
+
+bool ProcessFilter::filterAcceptsRow( int source_row, const QModelIndex & source_parent ) const
+{
+	if( (mFilter == AllProcesses || mFilter == AllProcessesInTreeForm)
+			&& filterRegExp().isEmpty()) return true; //Shortcut for common case
+
+	ProcessModel *model = static_cast<ProcessModel *>(sourceModel());
+	const KSysGuard::Process *process;
+        if(model->isSimpleMode()) {
+		if(source_parent.isValid()) {
+			kDebug() << "Serious error with data.  In simple mode, there should be no children";
+			return true;
+		}
+		process = model->getProcessAtIndex(source_row);
+	} else {
+		KSysGuard::Process *parent_process = NULL;
+		if(source_parent.isValid()) {
+			parent_process = reinterpret_cast<KSysGuard::Process *>(source_parent.internalPointer());
+		       	Q_ASSERT(parent_process);
+		} else {
+			//if(!model->isSimpleMode()) {
+				parent_process = model->getProcess(-1); //Get our 'special' process which should have the root init child
+		        	Q_ASSERT(parent_process);
+			//}
+		}
+		if(!model->isSimpleMode() && source_row >= parent_process->children.size()) {
+			kDebug() << "Serious error with data.  Source row requested for a non existent row. Requested " << source_row << " of " << parent_process->children.size() << " for " << parent_process->pid;
+			return true;
+		}
+
+		process = parent_process->children.at(source_row);
+	}
+	Q_ASSERT(process);
+	long uid = process->uid;
+	long euid = process->euid;
+
+	bool accepted = true;
+	switch(mFilter) {
+	case AllProcesses:
+	case AllProcessesInTreeForm:
+		break;
+        case SystemProcesses:
+                if( uid >= 100 && model->canUserLogin(uid))
+			accepted = false;
+		break;
+        case UserProcesses:
+		if( (uid < 100 || !model->canUserLogin(uid)) && (euid < 100 || !model->canUserLogin(euid)))
+			accepted = false;
+		break;
+        case OwnProcesses: {
+		long ownuid = getuid();
+                if(uid != ownuid && process->suid != ownuid && process->fsuid != ownuid && euid != ownuid)
+			accepted = false;
+		break;
+	}
+	case ProgramsOnly:
+		if(process->tty.isEmpty()) {
+			if(!model->hasGUIWindow(process->pid))
+				accepted = false;
+		} else {
+			// login and getty kinda _are_ the tty, so I do not really count them as 'programs'. So make a special case and hide them
+			// Their ppid are 1 (init) so by checking we try to avoid false matches, and speed up checking overall
+			QString name = process->name.section(' ', 0,0);
+			if(process->parent_pid == 1 && (name == "login" || name.endsWith("getty")))
+				accepted = false;
+		}
+		break;
+        default:
+		break;
+        }
+
+	if(accepted) {
+		if(filterRegExp().isEmpty()) return true;
+
+		//Allow the user to search by PID
+		if(QString::number(process->pid).contains(filterRegExp())) return true;
+
+		//None of our tests have rejected it.  Pass it on to qsortfilterproxymodel's filter
+		if(QSortFilterProxyModel::filterAcceptsRow(source_row, source_parent))
+			return true;
+	}
+
+
+	//We did not accept this row at all.
+
+	//If we are in flat mode, then give up now
+	if(mFilter != AllProcessesInTreeForm)
+		return false;
+
+	//one of our children might be accepted, so accept this row if our children are accepted.
+	QModelIndex source_index = sourceModel()->index(source_row, 0, source_parent);
+	for(int i = 0 ; i < sourceModel()->rowCount(source_index); i++) {
+		if(filterAcceptsRow(i, source_index)) return true;
+	}
+	return false;
+}
+
+bool ProcessFilter::lessThan(const QModelIndex &left, const QModelIndex &right) const
+{
+	if(right.isValid() && left.isValid()) {
+		Q_ASSERT(left.model());
+		Q_ASSERT(right.model());
+        const ProcessModel *model = static_cast<const ProcessModel *>(left.model());
+        return model->lessThan(left, right);
+	}
+	return QSortFilterProxyModel::lessThan(left,right);
+}
+
+
+void ProcessFilter::setFilter(State filter) {
+	mFilter = filter;
+	filterChanged();//Tell the proxy view to refresh all its information
+}
+#include "ProcessFilter.moc"
diff --git a/debuggers/gdb/ksysguard/ProcessFilter.h b/debuggers/gdb/ksysguard/ProcessFilter.h
new file mode 100644
index 0000000..36fcf8c
--- /dev/null
+++ b/debuggers/gdb/ksysguard/ProcessFilter.h
@@ -0,0 +1,64 @@
+/*
+    KSysGuard, the KDE System Guard
+
+	Copyright (c) 1999, 2000 Chris Schlaeger <cs@kde.org>
+	Copyright (c) 2006 John Tapsell <john.tapsell@kdemail.net>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef PROCESSFILTER_H_
+#define PROCESSFILTER_H_
+
+#include <QtGui/QSortFilterProxyModel>
+#include <QtCore/QObject>
+#include <kdemacros.h>
+
+class QModelIndex;
+
+#ifdef Q_OS_WIN
+// this workaround is needed to make krunner link under msvc
+// please keep it this way even if you port this library to have a _export.h header file
+#define KSYSGUARD_EXPORT
+#else
+#define KSYSGUARD_EXPORT KDE_EXPORT
+#endif
+
+class KSYSGUARD_EXPORT ProcessFilter : public QSortFilterProxyModel
+{
+	Q_OBJECT
+	Q_ENUMS(State)
+
+  public:
+	enum State {AllProcesses=0,AllProcessesInTreeForm, SystemProcesses, UserProcesses, OwnProcesses, ProgramsOnly};
+	ProcessFilter(QObject *parent=0) : QSortFilterProxyModel(parent) {mFilter = AllProcesses;}
+	virtual ~ProcessFilter() {}
+	bool lessThan(const QModelIndex &left, const QModelIndex &right) const;
+	State filter() const {return mFilter; }
+
+
+  public Q_SLOTS:
+	void setFilter(State index);
+
+  protected:
+	virtual bool filterAcceptsRow( int source_row, const QModelIndex & source_parent ) const;
+
+	State mFilter;
+};
+
+#endif
+
diff --git a/debuggers/gdb/ksysguard/ProcessModel.cpp b/debuggers/gdb/ksysguard/ProcessModel.cpp
new file mode 100644
index 0000000..75d39b4
--- /dev/null
+++ b/debuggers/gdb/ksysguard/ProcessModel.cpp
@@ -0,0 +1,2090 @@
+/*
+    KSysGuard, the KDE System Guard
+
+    Copyright (c) 1999, 2000 Chris Schlaeger <cs@kde.org>
+    Copyright (c) 2006-2007 John Tapsell <john.tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+
+#include "ProcessModel.h"
+#include "ProcessModel_p.h"
+
+#include "processes.h"
+#include "process.h"
+
+#include <kapplication.h>
+#include <kcolorscheme.h>
+#include <kiconloader.h>
+#include <kdebug.h>
+#include <klocale.h>
+#include <QBitmap>
+#include <QFont>
+#include <QIcon>
+#include <QPixmap>
+#include <QList>
+#include <QMimeData>
+#include <QTextDocument>
+
+#define HEADING_X_ICON_SIZE 16
+#define MILLISECONDS_TO_SHOW_RED_FOR_KILLED_PROCESS 2000
+#define GET_OWN_ID
+
+#ifdef GET_OWN_ID
+/* For getuid*/
+#include <unistd.h>
+#include <sys/types.h>
+#endif
+
+#include "ProcessModel.moc"
+#include "ProcessModel_p.moc"
+
+#ifdef HAVE_XRES
+#include <X11/extensions/XRes.h>
+#endif
+
+extern KApplication* Kapp;
+
+static QString formatByteSize(qlonglong amountInKB, int units) {
+    enum { UnitsAuto, UnitsKB, UnitsMB, UnitsGB, UnitsTB, UnitsPB };
+    static QString kString = i18n("%1 K", QString::fromLatin1("%1"));
+    static QString mString = i18n("%1 M", QString::fromLatin1("%1"));
+    static QString gString = i18n("%1 G", QString::fromLatin1("%1"));
+    static QString tString = i18n("%1 T", QString::fromLatin1("%1"));
+    static QString pString = i18n("%1 P", QString::fromLatin1("%1"));
+    double amount;
+
+    if (units == UnitsAuto) {
+        if (amountInKB < 1024.0*0.9)
+            units = UnitsKB; // amount < 0.9 MiB == KiB
+        else if (amountInKB < 1024.0*1024.0*0.9)
+            units = UnitsMB; // amount < 0.9 GiB == MiB
+        else if (amountInKB < 1024.0*1024.0*1024.0*0.9)
+            units = UnitsGB; // amount < 0.9 TiB == GiB
+        else if (amountInKB < 1024.0*1024.0*1024.0*1024.0*0.9)
+            units = UnitsTB; // amount < 0.9 PiB == TiB
+        else
+            units = UnitsPB;
+    }
+
+    switch(units) {
+      case UnitsKB:
+        return kString.arg(KGlobal::locale()->formatNumber(amountInKB, 0));
+      case UnitsMB:
+        amount = amountInKB/1024.0;
+        return mString.arg(KGlobal::locale()->formatNumber(amount, 1));
+      case UnitsGB:
+        amount = amountInKB/(1024.0*1024.0);
+        if(amount < 0.1 && amount > 0.05) amount = 0.1;
+        return gString.arg(KGlobal::locale()->formatNumber(amount, 1));
+      case UnitsTB:
+        amount = amountInKB/(1024.0*1024.0*1024.0);
+        if(amount < 0.1 && amount > 0.05) amount = 0.1;
+        return tString.arg(KGlobal::locale()->formatNumber(amount, 1));
+      case UnitsPB:
+        amount = amountInKB/(1024.0*1024.0*1024.0*1024.0);
+        if(amount < 0.1 && amount > 0.05) amount = 0.1;
+        return pString.arg(KGlobal::locale()->formatNumber(amount, 1));
+      default:
+          return "";  // error
+    }
+}
+
+ProcessModelPrivate::ProcessModelPrivate() :  mBlankPixmap(HEADING_X_ICON_SIZE,1)
+{
+    mBlankPixmap.fill(QColor(0,0,0,0));
+    mSimple = true;
+    mIsLocalhost = true;
+    mMemTotal = -1;
+    mNumProcessorCores = 1;
+    mProcesses = NULL;
+    mShowChildTotals = true;
+    mShowCommandLineOptions = false;
+    mShowingTooltips = true;
+    mNormalizeCPUUsage = true;
+    mIoInformation = ProcessModel::ActualBytes;
+#ifdef HAVE_XRES
+    mHaveXRes = false;
+#endif
+    mHaveTimer = false,
+    mTimerId = -1,
+    mMovingRow = false;
+    mRemovingRow = false;
+    mInsertingRow = false;
+}
+
+ProcessModelPrivate::~ProcessModelPrivate()
+{
+#ifdef Q_WS_X11
+    qDeleteAll(mPidToWindowInfo);
+#endif
+    delete mProcesses;
+    mProcesses = NULL;
+}
+ProcessModel::ProcessModel(QObject* parent, const QString &host)
+    : QAbstractItemModel(parent), d(new ProcessModelPrivate)
+{
+    KGlobal::locale()->insertCatalog("processui");  //Make sure we include the translation stuff.  This needs to be run before any i18n call here
+    d->q=this;
+#ifdef HAVE_XRES
+    int event, error, major, minor;
+    d->mHaveXRes = XResQueryExtension(QX11Info::display(), &event, &error) && XResQueryVersion(QX11Info::display(), &major, &minor);
+#endif
+
+    if(host.isEmpty() || host == "localhost") {
+        d->mHostName = QString();
+        d->mIsLocalhost = true;
+    } else {
+        d->mHostName = host;
+        d->mIsLocalhost = false;
+    }
+    setupHeader();
+    d->setupProcesses();
+#ifdef Q_WS_X11
+    d->setupWindows();
+#endif
+    d->mUnits = UnitsKB;
+    d->mIoUnits = UnitsKB;
+
+
+}
+
+bool ProcessModel::lessThan(const QModelIndex &left, const QModelIndex &right) const
+{
+    //Because we need to sort Descendingly by default for most of the headings, we often return left > right
+    KSysGuard::Process *processLeft = reinterpret_cast< KSysGuard::Process * > (left.internalPointer());
+    KSysGuard::Process *processRight = reinterpret_cast< KSysGuard::Process * > (right.internalPointer());
+    Q_ASSERT(processLeft);
+    Q_ASSERT(processRight);
+    Q_ASSERT(left.column() == right.column());
+    switch(left.column()) {
+        case HeadingUser:
+        {
+            /* Sorting by user will be the default and the most common.
+               We want to sort in the most useful way that we can. We need to return a number though.
+               This code is based on that sorting ascendingly should put the current user at the top
+               First the user we are running as should be at the top.
+               Then any other users in the system.
+               Then at the bottom the 'system' processes.
+               We then sort by cpu usage to sort by that, then finally sort by memory usage */
+
+            /* First, place traced processes at the very top, ignoring any other sorting criteria */
+            if(processLeft->tracerpid >= 0)
+                return true;
+            if(processRight->tracerpid >= 0)
+                return false;
+
+            /* Sort by username.  First group into own user, normal users, system users */
+            if(processLeft->uid != processRight->uid) {
+                //We primarily sort by username
+                if(d->mIsLocalhost) {
+                    int ownUid = getuid();
+                    if(processLeft->uid == ownUid)
+                        return true; //Left is our user, right is not.  So left is above right
+                    if(processRight->uid == ownUid)
+                        return false; //Left is not our user, right is.  So right is above left
+                }
+                bool isLeftSystemUser = processLeft->uid < 100 || !canUserLogin(processLeft->uid);
+                bool isRightSystemUser = processRight->uid < 100 || !canUserLogin(processRight->uid);
+                if(isLeftSystemUser && !isRightSystemUser)
+                    return false; //System users are less than non-system users
+                if(!isLeftSystemUser && isRightSystemUser)
+                    return true;
+                //They are either both system users, or both non-system users.
+                //So now sort by username
+                return d->getUsernameForUser(processLeft->uid, false) < d->getUsernameForUser(processRight->uid, false);
+            }
+
+            /* 2nd sort order - Graphics Windows */
+            //Both columns have the same user.  Place processes with windows at the top
+            if(processLeft->hasManagedGuiWindow && !processRight->hasManagedGuiWindow)
+                return true;
+            if(!processLeft->hasManagedGuiWindow && processRight->hasManagedGuiWindow)
+                return false;
+
+            /* 3rd sort order - CPU Usage */
+            int leftCpu, rightCpu;
+            if(d->mSimple || !d->mShowChildTotals) {
+                leftCpu = processLeft->userUsage + processLeft->sysUsage;
+                rightCpu = processRight->userUsage + processRight->sysUsage;
+            } else {
+                leftCpu = processLeft->totalUserUsage + processLeft->totalSysUsage;
+                rightCpu = processRight->totalUserUsage + processRight->totalSysUsage;
+            }
+            if(leftCpu != rightCpu)
+                return leftCpu > rightCpu;
+
+            /* 4th sort order - Memory Usage */
+            qlonglong memoryLeft = (processLeft->vmURSS != -1)?processLeft->vmURSS:processLeft->vmRSS;
+            qlonglong memoryRight = (processRight->vmURSS != -1)?processRight->vmURSS:processRight->vmRSS;
+            return memoryLeft > memoryRight;
+        }
+        case HeadingCPUUsage: {
+            int leftCpu, rightCpu;
+            if(d->mSimple || !d->mShowChildTotals) {
+                leftCpu = processLeft->userUsage + processLeft->sysUsage;
+                rightCpu = processRight->userUsage + processRight->sysUsage;
+            } else {
+                leftCpu = processLeft->totalUserUsage + processLeft->totalSysUsage;
+                rightCpu = processRight->totalUserUsage + processRight->totalSysUsage;
+            }
+            return leftCpu > rightCpu;
+         }
+        case HeadingCPUTime: {
+            return (processLeft->userTime + processLeft->sysTime) > (processRight->userTime + processRight->sysTime);
+        }
+        case HeadingMemory: {
+            qlonglong memoryLeft = (processLeft->vmURSS != -1)?processLeft->vmURSS:processLeft->vmRSS;
+            qlonglong memoryRight = (processRight->vmURSS != -1)?processRight->vmURSS:processRight->vmRSS;
+            return memoryLeft > memoryRight;
+        }
+        case HeadingXMemory:
+            return processLeft->pixmapBytes > processRight->pixmapBytes;
+        case HeadingVmSize:
+            return processLeft->vmSize > processRight->vmSize;
+        case HeadingSharedMemory: {
+            qlonglong memoryLeft = (processLeft->vmURSS != -1)?processLeft->vmRSS - processLeft->vmURSS:0;
+            qlonglong memoryRight = (processRight->vmURSS != -1)?processRight->vmRSS - processRight->vmURSS:0;
+            return memoryLeft > memoryRight;
+        }
+        case HeadingPid:
+            return processLeft->pid > processRight->pid;
+        case HeadingNiceness:
+            //Sort by scheduler first
+            if(processLeft->scheduler != processRight->scheduler) {
+                if(processLeft->scheduler == KSysGuard::Process::RoundRobin || processLeft->scheduler == KSysGuard::Process::Fifo)
+                    return true;
+                if(processRight->scheduler == KSysGuard::Process::RoundRobin || processRight->scheduler == KSysGuard::Process::Fifo)
+                    return false;
+                if(processLeft->scheduler == KSysGuard::Process::Other)
+                    return true;
+                if(processRight->scheduler == KSysGuard::Process::Other)
+                    return false;
+                if(processLeft->scheduler == KSysGuard::Process::Batch)
+                    return true;
+            }
+            if(processLeft->niceLevel == processRight->niceLevel)
+                return processLeft->pid < processRight->pid; //Subsort by pid if the niceLevel is the same
+            return processLeft->niceLevel < processRight->niceLevel;
+        case HeadingTty: {
+            if( processLeft->tty == processRight->tty)
+                return processLeft->pid < processRight->pid; //Both ttys are the same.  Sort by pid
+            if(processLeft->tty.isEmpty())
+                return false; //Only left is empty (since they aren't the same)
+            else if(processRight->tty.isEmpty())
+                return true; //Only right is empty
+
+            //Neither left or right is empty. The tty string is like  "tty10"  so split this into "tty" and "10"
+            //and sort by the string first, then sort by the number
+            QRegExp regexpLeft("^(\\D*)(\\d*)$");
+            QRegExp regexpRight(regexpLeft);
+            if(regexpLeft.indexIn(processLeft->tty) == -1 || regexpRight.indexIn(processRight->tty) == -1)
+                return processLeft->tty < processRight->tty;
+            int nameMatch = regexpLeft.cap(1).compare(regexpRight.cap(1));
+            if(nameMatch < 0)
+                return true;
+            if(nameMatch > 0)
+                return false;
+            return regexpLeft.cap(2).toInt() < regexpRight.cap(2).toInt();
+        }
+        case HeadingIoRead:
+            switch(d->mIoInformation) {
+                case ProcessModel::Bytes:
+                    return processLeft->ioCharactersRead > processRight->ioCharactersRead;
+                case ProcessModel::Syscalls:
+                    return processLeft->ioReadSyscalls > processRight->ioReadSyscalls;
+                case ProcessModel::ActualBytes:
+                    return processLeft->ioCharactersActuallyRead > processRight->ioCharactersActuallyRead;
+                case ProcessModel::BytesRate:
+                    return processLeft->ioCharactersReadRate > processRight->ioCharactersReadRate;
+                case ProcessModel::SyscallsRate:
+                    return processLeft->ioReadSyscallsRate > processRight->ioReadSyscallsRate;
+                case ProcessModel::ActualBytesRate:
+                    return processLeft->ioCharactersActuallyReadRate > processRight->ioCharactersActuallyReadRate;
+
+            }
+        case HeadingIoWrite:
+            switch(d->mIoInformation) {
+                case ProcessModel::Bytes:
+                    return processLeft->ioCharactersWritten > processRight->ioCharactersWritten;
+                case ProcessModel::Syscalls:
+                    return processLeft->ioWriteSyscalls > processRight->ioWriteSyscalls;
+                case ProcessModel::ActualBytes:
+                    return processLeft->ioCharactersActuallyWritten > processRight->ioCharactersActuallyWritten;
+                case ProcessModel::BytesRate:
+                    return processLeft->ioCharactersWrittenRate > processRight->ioCharactersWrittenRate;
+                case ProcessModel::SyscallsRate:
+                    return processLeft->ioWriteSyscallsRate > processRight->ioWriteSyscallsRate;
+                case ProcessModel::ActualBytesRate:
+                    return processLeft->ioCharactersActuallyWrittenRate > processRight->ioCharactersActuallyWrittenRate;
+        }
+    }
+    //Sort by the display string if we do not have an explicit sorting here
+    return data(left, Qt::DisplayRole).toString() < data(right, Qt::DisplayRole).toString();
+}
+
+ProcessModel::~ProcessModel()
+{
+    delete d;
+}
+
+KSysGuard::Processes *ProcessModel::processController() const
+{
+    return d->mProcesses;
+}
+
+#ifdef Q_WS_X11
+void ProcessModelPrivate::windowRemoved(WId wid) {
+    WindowInfo *window = mWIdToWindowInfo.take(wid);
+    if(!window) return;
+    qlonglong pid = window->pid;
+
+    QMultiHash<qlonglong, WindowInfo*>::iterator i = mPidToWindowInfo.find(pid);
+    while (i != mPidToWindowInfo.end() && i.key() == pid) {
+        if(i.value()->wid == wid) {
+            i = mPidToWindowInfo.erase(i);
+            break;
+        } else
+            i++;
+    }
+    delete window;
+
+    //Update the model so that it redraws and resorts
+    KSysGuard::Process *process = mProcesses->getProcess(pid);
+    if(!process) return;
+
+    int row;
+    if(mSimple)
+        row = process->index;
+    else
+        row = process->parent->children.indexOf(process);
+    QModelIndex index2 = q->createIndex(row, ProcessModel::HeadingXTitle, process);
+    emit q->dataChanged(index2, index2);
+}
+#endif
+
+#ifdef Q_WS_X11
+void ProcessModelPrivate::setupWindows() {
+    connect( KWindowSystem::self(), SIGNAL(windowChanged(WId,uint)), this, SLOT(windowChanged(WId,uint)));
+    connect( KWindowSystem::self(), SIGNAL(windowAdded(WId)), this, SLOT(windowAdded(WId)));
+    connect( KWindowSystem::self(), SIGNAL(windowRemoved(WId)), this, SLOT(windowRemoved(WId)));
+
+    //Add all the windows that KWin is managing - i.e. windows that the user can see
+    QList<WId>::ConstIterator it;
+    for ( it = KWindowSystem::windows().begin(); it != KWindowSystem::windows().end(); ++it ) {
+        updateWindowInfo(*it, ~0u, true);
+    }
+}
+#endif
+#ifdef HAVE_XRES
+bool ProcessModelPrivate::updateXResClientData() {
+    XResClient *clients;
+    int count;
+
+    KXErrorHandler handler;
+    XResQueryClients(QX11Info::display(), &count, &clients);
+    if (handler.error( false ) )
+        return false;
+
+    mXResClientResources.clear();
+    for (int i=0; i < count; i++)
+        mXResClientResources.insert(-(qlonglong)(clients[i].resource_base), clients[i].resource_mask);
+
+    if(clients)
+        XFree(clients);
+    return true;
+}
+void ProcessModelPrivate::queryForAndUpdateAllXWindows() {
+//    qDebug() << "updating xres info:" << QTime::currentTime().toString("hh:mm:ss.zzz");
+    updateXResClientData();
+    Window       *children, dummy;
+    unsigned int  count;
+    Status result = XQueryTree(QX11Info::display(), QX11Info::appRootWindow(), &dummy, &dummy, &children, &count);
+    if(!result)
+        return;
+    if(!updateXResClientData())
+        return;
+    for (uint i=0; i < count; ++i) {
+        WId wid = children[i];
+        QMap<qlonglong, XID>::iterator iter = mXResClientResources.lowerBound(-(qlonglong)(wid));
+        if(iter == mXResClientResources.end())
+            continue; //We couldn't find it this time :-/
+
+        if(-iter.key() != (qlonglong)(wid & ~iter.value()))
+            continue; //Already added this window
+
+        //Get the PID for this window if we do not know it
+        KXErrorHandler handler;
+        NETWinInfo info( QX11Info::display(), wid, QX11Info::appRootWindow(), NET::WMPid );
+        if (handler.error( false ) )
+            continue;  //info is invalid - window just closed or something probably
+
+        qlonglong pid = info.pid();
+        if(!pid)
+            continue;
+        //We found a window with this client
+        mXResClientResources.erase(iter);
+        KSysGuard::Process *process = mProcesses->getProcess(pid);
+        if(!process) return; //shouldn't really happen.. maybe race condition etc
+        unsigned long previousPixmapBytes = process->pixmapBytes;
+        //Now update the pixmap bytes for this window
+        bool success = XResQueryClientPixmapBytes(QX11Info::display(), wid, &process->pixmapBytes);
+        if(!success)
+            process->pixmapBytes = 0;
+
+        if(previousPixmapBytes != process->pixmapBytes) {
+            int row;
+            if(mSimple)
+                row = process->index;
+            else
+                row = process->parent->children.indexOf(process);
+            QModelIndex index = q->createIndex(row, ProcessModel::HeadingXMemory, process);
+            emit q->dataChanged(index, index);
+        }
+    }
+    if(children)
+        XFree((char*)children);
+//    qDebug() << "done updating xres info:" << QTime::currentTime().toString("hh:mm:ss.zzz");
+}
+#endif
+void ProcessModelPrivate::setupProcesses() {
+    if(mProcesses) {
+#ifdef Q_WS_X11_DISABLE
+        mWIdToWindowInfo.clear();
+        mPidToWindowInfo.clear();
+#endif
+        delete mProcesses;
+        mProcesses = 0;
+        q->reset();
+    }
+
+    mProcesses = new KSysGuard::Processes(mHostName);
+
+    connect( mProcesses, SIGNAL(processChanged(KSysGuard::Process*,bool)), this, SLOT(processChanged(KSysGuard::Process*,bool)));
+    connect( mProcesses, SIGNAL(beginAddProcess(KSysGuard::Process*)), this, SLOT(beginInsertRow(KSysGuard::Process*)));
+    connect( mProcesses, SIGNAL(endAddProcess()), this, SLOT(endInsertRow()));
+    connect( mProcesses, SIGNAL(beginRemoveProcess(KSysGuard::Process*)), this, SLOT(beginRemoveRow(KSysGuard::Process*)));
+    connect( mProcesses, SIGNAL(endRemoveProcess()), this, SLOT(endRemoveRow()));
+    connect( mProcesses, SIGNAL(beginMoveProcess(KSysGuard::Process*,KSysGuard::Process*)), this,
+            SLOT(beginMoveProcess(KSysGuard::Process*,KSysGuard::Process*)));
+    connect( mProcesses, SIGNAL(endMoveProcess()), this, SLOT(endMoveRow()));
+    mNumProcessorCores = mProcesses->numberProcessorCores();
+    if(mNumProcessorCores < 1) mNumProcessorCores=1;  //Default to 1 if there was an error getting the number
+}
+
+#ifdef Q_WS_X11
+void ProcessModelPrivate::windowChanged(WId wid, unsigned int properties)
+{
+    updateWindowInfo(wid, properties, false);
+}
+
+void ProcessModelPrivate::windowAdded(WId wid)
+{
+    updateWindowInfo(wid, ~0u, true);
+}
+
+void ProcessModelPrivate::updateWindowInfo(WId wid, unsigned int properties, bool newWindow)
+{
+    properties &= (NET::WMPid | NET::WMVisibleName | NET::WMName | NET::WMIcon);
+
+    if(!properties)
+        return; //Nothing interesting changed
+
+    WindowInfo *w = mWIdToWindowInfo.value(wid);
+    if(!w && !newWindow)
+        return; //We do not have a record of this window and this is not a new window
+
+    if(properties == NET::WMIcon) {
+        if(w)
+            w->icon = KWindowSystem::icon(wid, HEADING_X_ICON_SIZE, HEADING_X_ICON_SIZE, true);
+        return;
+    }
+    /* Get PID for window */
+    KXErrorHandler handler;
+    NETWinInfo info( QX11Info::display(), wid, QX11Info::appRootWindow(), properties & ~NET::WMIcon );
+    if (handler.error( false ) ) {
+        return;  //info is invalid - window just closed or something probably
+    }
+
+    if(!w) {
+        //We know that this must be a newWindow
+        qlonglong pid = info.pid();
+        if(!(properties & NET::WMPid && pid))
+            return; //No PID for the window - this happens if the process did not set _NET_WM_PID
+
+        //If we are to get the PID only, we are only interested in the XRes info for this,
+        //so don't bother if we already have this info
+        if(properties == NET::WMPid && mPidToWindowInfo.contains(pid))
+            return;
+
+        w = new WindowInfo(wid, pid);
+        mPidToWindowInfo.insertMulti(pid, w);
+        mWIdToWindowInfo.insert(wid, w);
+    }
+
+    if(w && (properties & NET::WMIcon))
+        w->icon = KWindowSystem::icon(wid, HEADING_X_ICON_SIZE, HEADING_X_ICON_SIZE, true);
+    if(properties & NET::WMVisibleName && info.visibleName())
+        w->name = QString::fromUtf8(info.visibleName());
+    else if(properties & NET::WMName)
+        w->name = QString::fromUtf8(info.name());
+    else if(properties & (NET::WMName | NET::WMVisibleName))
+        w->name.clear();
+
+    KSysGuard::Process *process = mProcesses->getProcess(w->pid);
+    if(!process) {
+        mProcesses->updateOrAddProcess(w->pid);
+        return; //This happens when a new window is detected before we've read in the process
+    }
+
+    int row;
+    if(mSimple)
+        row = process->index;
+    else
+        row = process->parent->children.indexOf(process);
+    if(!process->hasManagedGuiWindow) {
+        process->hasManagedGuiWindow = true;;
+        //Since this is the first window for a process, invalidate HeadingName so that
+        //if we are sorting by name this gets taken into account
+        QModelIndex index1 = q->createIndex(row, ProcessModel::HeadingName, process);
+        emit q->dataChanged(index1, index1);
+    }
+    QModelIndex index2 = q->createIndex(row, ProcessModel::HeadingXTitle, process);
+    emit q->dataChanged(index2, index2);
+}
+#endif
+
+void ProcessModel::update(long updateDurationMSecs, KSysGuard::Processes::UpdateFlags updateFlags) {
+//    kDebug() << "update all processes: " << QTime::currentTime().toString("hh:mm:ss.zzz");
+    if(updateFlags != KSysGuard::Processes::XMemory) {
+        d->mProcesses->updateAllProcesses(updateDurationMSecs, updateFlags);
+        if(d->mMemTotal <= 0)
+            d->mMemTotal = d->mProcesses->totalPhysicalMemory();
+    }
+
+//    kDebug() << "finished:             " << QTime::currentTime().toString("hh:mm:ss.zzz");
+#ifdef HAVE_XRES
+    //Add all the rest of the windows
+    if(d->mHaveXRes && updateFlags.testFlag(KSysGuard::Processes::XMemory))
+        d->queryForAndUpdateAllXWindows();
+#endif
+
+}
+
+QString ProcessModelPrivate::getStatusDescription(KSysGuard::Process::ProcessStatus status) const
+{
+    switch( status) {
+        case KSysGuard::Process::Running:
+            return i18n("- Process is doing some work.");
+        case KSysGuard::Process::Sleeping:
+            return i18n("- Process is waiting for something to happen.");
+        case KSysGuard::Process::Stopped:
+            return i18n("- Process has been stopped. It will not respond to user input at the moment.");
+        case KSysGuard::Process::Zombie:
+            return i18n("- Process has finished and is now dead, but the parent process has not cleaned up.");
+        case KSysGuard::Process::Ended:
+//            return i18n("- Process has finished and no longer exists.");
+        default:
+            return QString();
+    }
+}
+
+KSysGuard::Process *ProcessModel::getProcessAtIndex(int index) const
+{
+    Q_ASSERT(d->mSimple);
+    return d->mProcesses->getAllProcesses().at(index);
+}
+int ProcessModel::rowCount(const QModelIndex &parent) const
+{
+    if(d->mSimple) {
+        if(parent.isValid()) return 0; //In flat mode, none of the processes have children
+        return d->mProcesses->processCount();
+    }
+
+    //Deal with the case that we are showing it as a tree
+    KSysGuard::Process *process;
+    if(parent.isValid()) {
+        if(parent.column() != 0) return 0;  //For a treeview we say that only the first column has children
+        process = reinterpret_cast< KSysGuard::Process * > (parent.internalPointer()); //when parent is invalid, it must be the root level which we set as 0
+    } else {
+        process = d->mProcesses->getProcess(-1);
+    }
+    Q_ASSERT(process);
+    int num_rows = process->children.count();
+    return num_rows;
+}
+
+int ProcessModel::columnCount ( const QModelIndex & ) const
+{
+    return d->mHeadings.count();
+}
+
+bool ProcessModel::hasChildren ( const QModelIndex & parent = QModelIndex() ) const
+{
+
+    if(d->mSimple) {
+        if(parent.isValid()) return 0; //In flat mode, none of the processes have children
+        return !d->mProcesses->getAllProcesses().isEmpty();
+    }
+
+    //Deal with the case that we are showing it as a tree
+    KSysGuard::Process *process;
+    if(parent.isValid()) {
+        if(parent.column() != 0) return false;  //For a treeview we say that only the first column has children
+        process = reinterpret_cast< KSysGuard::Process * > (parent.internalPointer()); //when parent is invalid, it must be the root level which we set as 0
+    } else {
+        process = d->mProcesses->getProcess(-1);
+    }
+    Q_ASSERT(process);
+    bool has_children = !process->children.isEmpty();
+
+    Q_ASSERT((rowCount(parent) > 0) == has_children);
+    return has_children;
+}
+
+QModelIndex ProcessModel::index ( int row, int column, const QModelIndex & parent ) const
+{
+    if(row<0) return QModelIndex();
+    if(column<0 || column >= d->mHeadings.count() ) return QModelIndex();
+
+    if(d->mSimple) {
+        if( parent.isValid()) return QModelIndex();
+        if( d->mProcesses->processCount() <= row) return QModelIndex();
+        return createIndex( row, column, d->mProcesses->getAllProcesses().at(row));
+    }
+
+    //Deal with the case that we are showing it as a tree
+    KSysGuard::Process *parent_process = 0;
+
+    if(parent.isValid()) //not valid for init or children without parents, so use our special item with pid of 0
+        parent_process = reinterpret_cast< KSysGuard::Process * > (parent.internalPointer());
+    else
+        parent_process = d->mProcesses->getProcess(-1);
+    Q_ASSERT(parent_process);
+
+    if(parent_process->children.count() > row)
+        return createIndex(row,column, parent_process->children[row]);
+    else
+    {
+        return QModelIndex();
+    }
+}
+
+bool ProcessModel::isSimpleMode() const
+{
+    return d->mSimple;
+}
+
+void ProcessModelPrivate::processChanged(KSysGuard::Process *process, bool onlyTotalCpu)
+{
+    int row;
+    if(mSimple)
+        row = process->index;
+    else
+        row = process->parent->children.indexOf(process);
+
+    if (!process->timeKillWasSent.isNull()) {
+        int elapsed = process->timeKillWasSent.elapsed();
+        if (elapsed < MILLISECONDS_TO_SHOW_RED_FOR_KILLED_PROCESS) {
+            if (!mPidsToUpdate.contains(process->pid))
+                mPidsToUpdate.append(process->pid);
+            QModelIndex index1 = q->createIndex(row, 0, process);
+            QModelIndex index2 = q->createIndex(row, mHeadings.count()-1, process);
+            emit q->dataChanged(index1, index2);
+            if (!mHaveTimer) {
+                mHaveTimer = true;
+                mTimerId = startTimer(100);
+            }
+        }
+    }
+    int totalUpdated = 0;
+    Q_ASSERT(row != -1);  //Something has gone very wrong
+    if(onlyTotalCpu) {
+        if(mShowChildTotals) {
+            //Only the total cpu usage changed, so only update that
+            QModelIndex index = q->createIndex(row, ProcessModel::HeadingCPUUsage, process);
+            emit q->dataChanged(index, index);
+        }
+        return;
+    } else {
+        if(process->changes == KSysGuard::Process::Nothing) {
+            return; //Nothing changed
+        }
+        if(process->changes & KSysGuard::Process::Uids) {
+            totalUpdated++;
+            QModelIndex index = q->createIndex(row, ProcessModel::HeadingUser, process);
+            emit q->dataChanged(index, index);
+        }
+        if(process->changes & KSysGuard::Process::Tty) {
+            totalUpdated++;
+            QModelIndex index = q->createIndex(row, ProcessModel::HeadingTty, process);
+            emit q->dataChanged(index, index);
+        }
+        if(process->changes & (KSysGuard::Process::Usage | KSysGuard::Process::Status) || (process->changes & KSysGuard::Process::TotalUsage && mShowChildTotals)) {
+            totalUpdated+=2;
+            QModelIndex index = q->createIndex(row, ProcessModel::HeadingCPUUsage, process);
+            emit q->dataChanged(index, index);
+            index = q->createIndex(row, ProcessModel::HeadingCPUTime, process);
+            emit q->dataChanged(index, index);
+            //Because of our sorting, changing usage needs to also invalidate the User column
+            index = q->createIndex(row, ProcessModel::HeadingUser, process);
+            emit q->dataChanged(index, index);
+        }
+        if(process->changes & KSysGuard::Process::NiceLevels) {
+            totalUpdated++;
+            QModelIndex index = q->createIndex(row, ProcessModel::HeadingNiceness, process);
+            emit q->dataChanged(index, index);
+        }
+        if(process->changes & KSysGuard::Process::VmSize) {
+            totalUpdated++;
+            QModelIndex index = q->createIndex(row, ProcessModel::HeadingVmSize, process);
+            emit q->dataChanged(index, index);
+        }
+        if(process->changes & (KSysGuard::Process::VmSize | KSysGuard::Process::VmRSS | KSysGuard::Process::VmURSS)) {
+            totalUpdated+=2;
+            QModelIndex index = q->createIndex(row, ProcessModel::HeadingMemory, process);
+            emit q->dataChanged(index, index);
+            QModelIndex index2 = q->createIndex(row, ProcessModel::HeadingSharedMemory, process);
+            emit q->dataChanged(index2, index2);
+            //Because of our sorting, changing usage needs to also invalidate the User column
+            index = q->createIndex(row, ProcessModel::HeadingUser, process);
+            emit q->dataChanged(index, index);
+        }
+        if(process->changes & KSysGuard::Process::Name) {
+            totalUpdated++;
+            QModelIndex index = q->createIndex(row, ProcessModel::HeadingName, process);
+            emit q->dataChanged(index, index);
+        }
+        if(process->changes & KSysGuard::Process::Command) {
+            totalUpdated++;
+            QModelIndex index = q->createIndex(row, ProcessModel::HeadingCommand, process);
+            emit q->dataChanged(index, index);
+        }
+        if(process->changes & KSysGuard::Process::Login) {
+            totalUpdated++;
+            QModelIndex index = q->createIndex(row, ProcessModel::HeadingUser, process);
+            emit q->dataChanged(index, index);
+        }
+        if(process->changes & KSysGuard::Process::IO) {
+            totalUpdated++;
+            QModelIndex index = q->createIndex(row, ProcessModel::HeadingIoRead, process);
+            emit q->dataChanged(index, index);
+            index = q->createIndex(row, ProcessModel::HeadingIoWrite, process);
+            emit q->dataChanged(index, index);
+        }
+    }
+}
+
+void ProcessModelPrivate::beginInsertRow( KSysGuard::Process *process)
+{
+    Q_ASSERT(process);
+    Q_ASSERT(!mRemovingRow);
+    Q_ASSERT(!mInsertingRow);
+    Q_ASSERT(!mMovingRow);
+    mInsertingRow = true;
+
+#ifdef Q_WS_X11
+    process->hasManagedGuiWindow = mPidToWindowInfo.contains(process->pid);
+#endif
+    if(mSimple) {
+        int row = mProcesses->processCount();
+        q->beginInsertRows( QModelIndex(), row, row );
+        return;
+    }
+
+    //Deal with the case that we are showing it as a tree
+    int row = process->parent->children.count();
+    QModelIndex parentModelIndex = q->getQModelIndex(process->parent, 0);
+
+    //Only here can we actually change the model.  First notify the view/proxy models then modify
+    q->beginInsertRows(parentModelIndex, row, row);
+}
+void ProcessModelPrivate::endInsertRow() {
+    Q_ASSERT(!mRemovingRow);
+    Q_ASSERT(mInsertingRow);
+    Q_ASSERT(!mMovingRow);
+    mInsertingRow = false;
+
+    q->endInsertRows();
+}
+void ProcessModelPrivate::beginRemoveRow( KSysGuard::Process *process )
+{
+    Q_ASSERT(process);
+    Q_ASSERT(process->pid >= 0);
+    Q_ASSERT(!mRemovingRow);
+    Q_ASSERT(!mInsertingRow);
+    Q_ASSERT(!mMovingRow);
+    mRemovingRow = true;
+
+    if(mSimple) {
+        return q->beginRemoveRows(QModelIndex(), process->index, process->index);
+    } else  {
+        int row = process->parent->children.indexOf(process);
+        if(row == -1) {
+            kDebug(1215) << "A serious problem occurred in remove row.";
+            mRemovingRow = false;
+            return;
+        }
+
+        return q->beginRemoveRows(q->getQModelIndex(process->parent,0), row, row);
+    }
+}
+void ProcessModelPrivate::endRemoveRow()
+{
+    Q_ASSERT(!mInsertingRow);
+    Q_ASSERT(!mMovingRow);
+    if(!mRemovingRow)
+        return;
+    mRemovingRow = false;
+
+    q->endRemoveRows();
+}
+
+
+void ProcessModelPrivate::beginMoveProcess(KSysGuard::Process *process, KSysGuard::Process *new_parent)
+{
+    Q_ASSERT(!mRemovingRow);
+    Q_ASSERT(!mInsertingRow);
+    Q_ASSERT(!mMovingRow);
+
+    if(mSimple) return;  //We don't need to move processes when in simple mode
+    mMovingRow = true;
+
+    int current_row = process->parent->children.indexOf(process);
+    Q_ASSERT(current_row != -1);
+    int new_row = new_parent->children.count();
+    QModelIndex sourceParent = q->getQModelIndex( process->parent, 0);
+    QModelIndex destinationParent = q->getQModelIndex( new_parent, 0 );
+    mMovingRow = q->beginMoveRows(sourceParent, current_row, current_row, destinationParent, new_row);
+    Q_ASSERT(mMovingRow);
+}
+void ProcessModelPrivate::endMoveRow()
+{
+    Q_ASSERT(!mInsertingRow);
+    Q_ASSERT(!mRemovingRow);
+    if(!mMovingRow)
+        return;
+    mMovingRow = false;
+
+    q->endMoveRows();
+}
+
+
+QModelIndex ProcessModel::getQModelIndex( KSysGuard::Process *process, int column) const
+{
+    Q_ASSERT(process);
+    int pid = process->pid;
+    if (pid == -1) return QModelIndex(); //pid -1 is our fake process meaning the very root (never drawn).  To represent that, we return QModelIndex() which also means the top element
+    int row = 0;
+    if(d->mSimple) {
+        row = process->index;
+    } else {
+        row = process->parent->children.indexOf(process);
+    }
+    Q_ASSERT(row != -1);
+    return createIndex(row, column, process);
+}
+
+QModelIndex ProcessModel::parent ( const QModelIndex & index ) const
+{
+    if(!index.isValid()) return QModelIndex();
+    KSysGuard::Process *process = reinterpret_cast< KSysGuard::Process * > (index.internalPointer());
+    Q_ASSERT(process);
+
+    if(d->mSimple)
+        return QModelIndex();
+    else
+        return getQModelIndex(process->parent,0);
+}
+
+QVariant ProcessModel::headerData(int section, Qt::Orientation orientation,
+                                  int role) const
+{
+    if(orientation != Qt::Horizontal)
+        return QVariant();
+    if(section < 0 || section >= d->mHeadings.count())
+        return QVariant(); //is this needed?
+    switch( role ) {
+      case Qt::TextAlignmentRole:
+      {
+        switch(section) {
+            case HeadingPid:
+            case HeadingMemory:
+            case HeadingXMemory:
+            case HeadingSharedMemory:
+            case HeadingIoRead:
+            case HeadingIoWrite:
+            case HeadingVmSize:
+            case HeadingNiceness:
+    //            return QVariant(Qt::AlignRight);
+            case HeadingUser:
+            case HeadingCPUUsage:
+                return QVariant(Qt::AlignCenter);
+
+        }
+        return QVariant();
+      }
+      case Qt::ToolTipRole:
+      {
+          if(!d->mShowingTooltips)
+            return QVariant();
+          switch(section) {
+            case HeadingName:
+                return i18n("The process name.");
+            case HeadingUser:
+                return i18n("The user who owns this process.");
+            case HeadingTty:
+                return i18n("The controlling terminal on which this process is running.");
+            case HeadingNiceness:
+                return i18n("The priority with which this process is being run. For the normal scheduler, this ranges from 19 (very nice, least priority) to -19 (top priority).");
+            case HeadingCPUUsage:
+                if(d->mNumProcessorCores == 1)
+                    return i18n("The current CPU usage of the process.");
+                else
+                    // i18n: %1 is always greater than 1, so do not worry about
+                    // nonsensical verbosity of the singular part.
+                    if(d->mNormalizeCPUUsage)
+                        return i18np("The current total CPU usage of the process, divided by the %1 processor core in the machine.", "The current total CPU usage of the process, divided by the %1 processor cores in the machine.", d->mNumProcessorCores);
+                    else
+                        return i18n("The current total CPU usage of the process.");
+            case HeadingCPUTime:
+                return i18n("<qt>The total user and system time that this process has been running for, displayed as minutes:seconds.");
+            case HeadingVmSize:
+                return i18n("<qt>This is the amount of virtual memory space that the process is using, included shared libraries, graphics memory, files on disk, and so on. This number is almost meaningless.</qt>");
+            case HeadingMemory:
+                return i18n("<qt>This is the amount of real physical memory that this process is using by itself, and approximates the Private memory usage of the process.<br>It does not include any swapped out memory, nor the code size of its shared libraries.<br>This is often the most useful figure to judge the memory use of a program.  See What's This for more information.</qt>");
+            case HeadingSharedMemory:
+                return i18n("<qt>This is approximately the amount of real physical memory that this process's shared libraries are using.<br>This memory is shared among all processes that use this library.</qt>");
+            case HeadingCommand:
+                return i18n("<qt>The command with which this process was launched.</qt>");
+            case HeadingXMemory:
+                return i18n("<qt>The amount of pixmap memory that this process is using.</qt>");
+            case HeadingXTitle:
+                return i18n("<qt>The title of any windows that this process is showing.</qt>");
+            case HeadingPid:
+                return i18n("The unique Process ID that identifies this process.");
+            case HeadingIoRead:
+                return i18n("The number of bytes read.  See What's This for more information.");
+            case HeadingIoWrite:
+                return i18n("The number of bytes written.  See What's This for more information.");
+            default:
+                return QVariant();
+          }
+      }
+      case Qt::WhatsThisRole:
+      {
+          switch(section) {
+            case HeadingName:
+                return i18n("<qt><i>Technical information: </i>The kernel process name is a maximum of 8 characters long, so the full command is examined.  If the first word in the full command line starts with the process name, the first word of the command line is shown, otherwise the process name is used.");
+            case HeadingUser:
+                return i18n("<qt>The user who owns this process.  If the effective, setuid etc user is different, the user who owns the process will be shown, followed by the effective user.  The ToolTip contains the full information.  <p>"
+                        "<table>"
+                          "<tr><td>Login Name/Group</td><td>The username of the Real User/Group who created this process</td></tr>"
+                          "<tr><td>Effective User/Group</td><td>The process is running with privileges of the Effective User/Group.  This is shown if different from the real user.</td></tr>"
+                          "<tr><td>Setuid User/Group</td><td>The saved username of the binary.  The process can escalate its Effective User/Group to the Setuid User/Group.</td></tr>"
+#ifdef Q_OS_LINUX
+                          "<tr><td>File System User/Group</td><td>Accesses to the filesystem are checked with the File System User/Group.  This is a Linux specific call. See setfsuid(2) for more information.</td></tr>"
+#endif
+                        "</table>");
+            case HeadingVmSize:
+                return i18n("<qt>This is the size of allocated address space - not memory, but address space. This value in practice means next to nothing. When a process requests a large memory block from the system but uses only a small part of it, the real usage will be low, VIRT will be high. <p><i>Technical information: </i>This is VmSize in proc/*/status and VIRT in top.");
+            case HeadingMemory:
+                return i18n("<qt><i>Technical information: </i>This is an approximation of the Private memory usage, calculated as VmRSS - Shared, from /proc/*/statm.  This tends to underestimate the true Private memory usage of a process (by not including i/o backed memory pages), but is the best estimation that is fast to determine.  This is sometimes known as URSS (Unique Resident Set Size). For an individual process, see \"Detailed  Memory Information\" for a more accurate, but slower, calculation of the true Private memory usage.");
+            case HeadingCPUUsage:
+                return i18n("The CPU usage of a process and all of its threads.");
+            case HeadingCPUTime:
+                return i18n("<qt>The total system and user time that a process and all of its threads have been running on the CPU for. This can be greater than the wall clock time if the process has been across multiple CPU cores.");
+            case HeadingSharedMemory:
+                return i18n("<qt><i>Technical information: </i>This is an approximation of the Shared memory, called SHR in top.  It is the number of pages that are backed by a file (see kernel Documentation/filesystems/proc.txt).  For an individual process, see \"Detailed Memory Information\" for a more accurate, but slower, calculation of the true Shared memory usage.");
+            case HeadingCommand:
+                return i18n("<qt><i>Technical information: </i>This is from /proc/*/cmdline");
+            case HeadingXMemory:
+                return i18n("<qt><i>Technical information: </i>This is the amount of memory used by the Xorg process for images for this process.  This is memory used in addition to Memory and Shared Memory.<br><i>Technical information: </i>This only counts the pixmap memory, and does not include resource memory used by fonts, cursors, glyphsets etc.  See the <code>xrestop</code> program for a more detailed breakdown.");
+            case HeadingXTitle:
+                return i18n("<qt><i>Technical information: </i>For each X11 window, the X11 property _NET_WM_PID is used to map the window to a PID.  If a process' windows are not shown, then that application incorrectly is not setting _NET_WM_PID.");
+            case HeadingPid:
+                return i18n("<qt><i>Technical information: </i>This is the Process ID.  A multi-threaded application is treated a single process, with all threads sharing the same PID.  The CPU usage etc will be the total, accumulated, CPU usage of all the threads.");
+            case HeadingIoRead:
+            case HeadingIoWrite:
+                return i18n("<qt>This column shows the IO statistics for each process. The tooltip provides the following information:<br>"
+                        "<table>"
+                        "<tr><td>Characters Read</td><td>The number of bytes which this task has caused to be read from storage. This is simply the sum of bytes which this process passed to read() and pread(). It includes things like tty IO and it is unaffected by whether or not actual physical disk IO was required (the read might have been satisfied from pagecache).</td></tr>"
+                        "<tr><td>Characters Written</td><td>The number of bytes which this task has caused, or shall cause to be written to disk. Similar caveats apply here as with Characters Read.</td></tr>"
+                        "<tr><td>Read Syscalls</td><td>The number of read I/O operations, i.e. syscalls like read() and pread().</td></tr>"
+                        "<tr><td>Write Syscalls</td><td>The number of write I/O operations, i.e. syscalls like write() and pwrite().</td></tr>"
+                        "<tr><td>Actual Bytes Read</td><td>The number of bytes which this process really did cause to be fetched from the storage layer. Done at the submit_bio() level, so it is accurate for block-backed filesystems. This may not give sensible values for NFS and CIFS filesystems.</td></tr>"
+                        "<tr><td>Actual Bytes Written</td><td>Attempt to count the number of bytes which this process caused to be sent to the storage layer. This is done at page-dirtying time.</td>"
+                        "</table><p>"
+                        "The number in brackets shows the rate at which each value is changing, determined from taking the difference between the previous value and the new value, and dividing by the update interval.<p>"
+                        "<i>Technical information: </i>This data is collected from /proc/*/io and is documented further in Documentation/accounting and Documentation/filesystems/proc.txt in the kernel source.");
+            default:
+                return QVariant();
+          }
+      }
+      case Qt::DisplayRole:
+        return d->mHeadings[section];
+      default:
+        return QVariant();
+    }
+}
+void ProcessModel::setSimpleMode(bool simple)
+{
+    if(d->mSimple == simple) return;
+
+    emit layoutAboutToBeChanged ();
+
+    d->mSimple = simple;
+
+    int flatrow;
+    int treerow;
+    QList<QModelIndex> flatIndexes;
+    QList<QModelIndex> treeIndexes;
+    foreach( KSysGuard::Process *process, d->mProcesses->getAllProcesses()) {
+        flatrow = process->index;
+        treerow = process->parent->children.indexOf(process);
+        flatIndexes.clear();
+        treeIndexes.clear();
+
+        for(int i=0; i < columnCount(); i++) {
+            flatIndexes << createIndex(flatrow, i, process);
+            treeIndexes << createIndex(treerow, i, process);
+        }
+        if(d->mSimple) //change from tree mode to flat mode
+            changePersistentIndexList(treeIndexes, flatIndexes);
+        else // change from flat mode to tree mode
+            changePersistentIndexList(flatIndexes, treeIndexes);
+    }
+
+    emit layoutChanged();
+}
+
+bool ProcessModel::canUserLogin(long uid ) const
+{
+    if(uid == 65534) {
+        //nobody user
+        return false;
+    }
+
+    if(!d->mIsLocalhost) return true; //We only deal with localhost.  Just always return true for non localhost
+
+    int canLogin = d->mUidCanLogin.value(uid, -1); //Returns 0 if we cannot login, 1 if we can, and the default is -1 meaning we don't know
+    if(canLogin != -1) return canLogin; //We know whether they can log in
+
+    //We got the default, -1, so we don't know.  Look it up
+
+    KUser user(uid);
+    if(!user.isValid()) {
+        //for some reason the user isn't recognised.  This might happen under certain security situations.
+        //Just return true to be safe
+        d->mUidCanLogin[uid] = 1;
+        return true;
+    }
+    QString shell = user.shell();
+    if(shell == "/bin/false" )  //FIXME - add in any other shells it could be for false
+    {
+        d->mUidCanLogin[uid] = 0;
+        return false;
+    }
+    d->mUidCanLogin[uid] = 1;
+    return true;
+}
+
+QString ProcessModelPrivate::getTooltipForUser(const KSysGuard::Process *ps) const
+{
+    QString userTooltip = "<qt><p style='white-space:pre'>";
+    if(!mIsLocalhost) {
+        userTooltip += i18n("Login Name: %1<br/>", getUsernameForUser(ps->uid, true));
+    } else {
+        KUser user(ps->uid);
+        if(!user.isValid())
+            userTooltip += i18n("This user is not recognized for some reason.");
+        else {
+            if(!user.property(KUser::FullName).isValid())
+                userTooltip += i18n("<b>%1</b><br/>", user.property(KUser::FullName).toString());
+            userTooltip += i18n("Login Name: %1 (uid: %2)<br/>", user.loginName(), QString::number(ps->uid));
+            if(!user.property(KUser::RoomNumber).isValid())
+                userTooltip += i18n("  Room Number: %1<br/>", user.property(KUser::RoomNumber).toString());
+            if(!user.property(KUser::WorkPhone).isValid())
+                userTooltip += i18n("  Work Phone: %1<br/>", user.property(KUser::WorkPhone).toString());
+        }
+    }
+    if( (ps->uid != ps->euid && ps->euid != -1) ||
+                   (ps->uid != ps->suid && ps->suid != -1) ||
+                   (ps->uid != ps->fsuid && ps->fsuid != -1)) {
+        if(ps->euid != -1)
+            userTooltip += i18n("Effective User: %1<br/>", getUsernameForUser(ps->euid, true));
+        if(ps->suid != -1)
+            userTooltip += i18n("Setuid User: %1<br/>", getUsernameForUser(ps->suid, true));
+        if(ps->fsuid != -1)
+            userTooltip += i18n("File System User: %1<br/>", getUsernameForUser(ps->fsuid, true));
+        userTooltip += "<br/>";
+    }
+    if(ps->gid != -1) {
+        userTooltip += i18n("Group: %1", getGroupnameForGroup(ps->gid));
+        if( (ps->gid != ps->egid && ps->egid != -1) ||
+                       (ps->gid != ps->sgid && ps->sgid != -1) ||
+                       (ps->gid != ps->fsgid && ps->fsgid != -1)) {
+            if(ps->egid != -1)
+                userTooltip += i18n("<br/>Effective Group: %1", getGroupnameForGroup(ps->egid));
+            if(ps->sgid != -1)
+                userTooltip += i18n("<br/>Setuid Group: %1", getGroupnameForGroup(ps->sgid));
+            if(ps->fsgid != -1)
+                userTooltip += i18n("<br/>File System Group: %1", getGroupnameForGroup(ps->fsgid));
+        }
+    }
+    return userTooltip;
+}
+
+QString ProcessModel::getStringForProcess(KSysGuard::Process *process) const {
+    return i18nc("Short description of a process. PID, name, user", "<numid>%1</numid>: %2, owned by user %3", (long)(process->pid), process->name, d->getUsernameForUser(process->uid, false));
+}
+
+QString ProcessModelPrivate::getGroupnameForGroup(long gid) const {
+    if(mIsLocalhost) {
+        QString groupname = KUserGroup(gid).name();
+        if(!groupname.isEmpty())
+            return i18n("%1 (gid: <numid>%2</numid>)", groupname, gid);
+    }
+    return QString::number(gid);
+}
+
+QString ProcessModelPrivate::getUsernameForUser(long uid, bool withuid) const {
+    QString &username = mUserUsername[uid];
+    if(username.isNull()) {
+        if(!mIsLocalhost) {
+            username = ""; //empty, but not null
+        } else {
+            KUser user(uid);
+            if(!user.isValid())
+                username = "";
+            else
+                username = user.loginName();
+        }
+    }
+    if(username.isEmpty())
+        return QString::number(uid);
+    if(withuid)
+        return i18n("%1 (uid: %2)", username, (long int)uid);
+    return username;
+}
+
+QVariant ProcessModel::data(const QModelIndex &index, int role) const
+{
+    //This function must be super duper ultra fast because it's called thousands of times every few second :(
+    //I think it should be optomised for role first, hence the switch statement (fastest possible case)
+
+    if (!index.isValid()) {
+        return QVariant();
+    }
+    if (index.column() >= d->mHeadings.count()) {
+        return QVariant();
+    }
+
+    switch (role){
+    case Qt::DisplayRole: {
+        KSysGuard::Process *process = reinterpret_cast< KSysGuard::Process * > (index.internalPointer());
+        switch(index.column()) {
+        case HeadingName:
+            if(d->mShowCommandLineOptions)
+                return process->name;
+            else
+                return process->name.section(' ', 0,0);
+        case HeadingPid:
+            return (qlonglong)process->pid;
+        case HeadingUser:
+            if(!process->login.isEmpty()) return process->login;
+            if(process->uid == process->euid)
+                return d->getUsernameForUser(process->uid, false);
+            else
+                return QString(d->getUsernameForUser(process->uid, false) + ", " + d->getUsernameForUser(process->euid, false));
+        case HeadingNiceness:
+            switch(process->scheduler) {
+              case KSysGuard::Process::Other:
+                  return process->niceLevel;
+              case KSysGuard::Process::SchedulerIdle:
+                  return i18nc("scheduler", "Idle"); //neither static nor dynamic priority matter
+              case KSysGuard::Process::Batch:
+                  return i18nc("scheduler", "(Batch) %1", process->niceLevel); //only dynamic priority matters
+              case KSysGuard::Process::RoundRobin:
+                  return i18nc("Round robin scheduler", "RR %1", process->niceLevel);
+              case KSysGuard::Process::Fifo:
+                  if(process->niceLevel == 99)
+                      return i18nc("Real Time scheduler", "RT");
+                  else
+                      return i18nc("First in first out scheduler", "FIFO %1", process->niceLevel);
+              case KSysGuard::Process::Interactive:
+                  return i18nc("scheduler", "(IA) %1", process->niceLevel);
+            }
+        case HeadingTty:
+            return process->tty;
+        case HeadingCPUUsage:
+            {
+                double total;
+                if(d->mShowChildTotals && !d->mSimple) total = process->totalUserUsage + process->totalSysUsage;
+                else total = process->userUsage + process->sysUsage;
+                if(d->mNormalizeCPUUsage)
+                    total = total / d->mNumProcessorCores;
+
+                if(total < 1 && process->status != KSysGuard::Process::Sleeping && process->status != KSysGuard::Process::Running && process->status != KSysGuard::Process::Ended)
+                    return process->translatedStatus();  //tell the user when the process is a zombie or stopped
+                if(total < 0.5)
+                    return "";
+
+                return QString(QString::number((int)(total+0.5)) + '%');
+            }
+        case HeadingCPUTime: {
+            qlonglong seconds = (process->userTime + process->sysTime)/100;
+            return QString("%1:%2").arg(seconds/60).arg((int)seconds%60, 2, 10, QLatin1Char('0'));
+        }
+        case HeadingMemory:
+            if(process->vmURSS == -1) {
+                //If we don't have the URSS (the memory used by only the process, not the shared libraries)
+                //then return the RSS (physical memory used by the process + shared library) as the next best thing
+                return formatMemoryInfo(process->vmRSS, d->mUnits, true);
+            } else {
+                return formatMemoryInfo(process->vmURSS, d->mUnits, true);
+            }
+        case HeadingVmSize:
+            return formatMemoryInfo(process->vmSize, d->mUnits, true);
+        case HeadingSharedMemory:
+            if(process->vmRSS - process->vmURSS <= 0 || process->vmURSS == -1) return QVariant(QVariant::String);
+            return formatMemoryInfo(process->vmRSS - process->vmURSS, d->mUnits);
+        case HeadingCommand:
+            {
+		return process->command.replace('\n',' ');
+// It would be nice to embolden the process name in command, but this requires that the itemdelegate to support html text
+//                QString command = process->command;
+//                command.replace(process->name, "<b>" + process->name + "</b>");
+//                return "<qt>" + command;
+            }
+        case HeadingIoRead:
+            {
+                switch(d->mIoInformation) {
+                    case ProcessModel::Bytes:  //divide by 1024 to convert to kB
+                        return formatMemoryInfo(process->ioCharactersRead/1024, d->mIoUnits, true);
+                    case ProcessModel::Syscalls:
+                        if( process->ioReadSyscalls )
+                            return QString::number(process->ioReadSyscalls);
+                        break;
+                    case ProcessModel::ActualBytes:
+                        return formatMemoryInfo(process->ioCharactersActuallyRead/1024, d->mIoUnits, true);
+                    case ProcessModel::BytesRate:
+                        if( process->ioCharactersReadRate/1024 )
+                            return i18n("%1/s", formatMemoryInfo(process->ioCharactersReadRate/1024, d->mIoUnits, true));
+                        break;
+                    case ProcessModel::SyscallsRate:
+                        if( process->ioReadSyscallsRate )
+                            return QString::number(process->ioReadSyscallsRate);
+                        break;
+                    case ProcessModel::ActualBytesRate:
+                        if( process->ioCharactersActuallyReadRate/1024 )
+                            return i18n("%1/s", formatMemoryInfo(process->ioCharactersActuallyReadRate/1024, d->mIoUnits, true));
+                        break;
+                }
+                return QVariant();
+            }
+        case HeadingIoWrite:
+            {
+                switch(d->mIoInformation) {
+                    case ProcessModel::Bytes:
+                        return formatMemoryInfo(process->ioCharactersWritten/1024, d->mIoUnits, true);
+                    case ProcessModel::Syscalls:
+                        if( process->ioWriteSyscalls )
+                            return QString::number(process->ioWriteSyscalls);
+                        break;
+                    case ProcessModel::ActualBytes:
+                        return formatMemoryInfo(process->ioCharactersActuallyWritten/1024, d->mIoUnits, true);
+                    case ProcessModel::BytesRate:
+                        if(process->ioCharactersWrittenRate/1024)
+                            return i18n("%1/s", formatMemoryInfo(process->ioCharactersWrittenRate/1024, d->mIoUnits, true));
+                        break;
+                    case ProcessModel::SyscallsRate:
+                        if( process->ioWriteSyscallsRate )
+                            return QString::number(process->ioWriteSyscallsRate);
+                        break;
+                    case ProcessModel::ActualBytesRate:
+                        if(process->ioCharactersActuallyWrittenRate/1024)
+                            return i18n("%1/s", formatMemoryInfo(process->ioCharactersActuallyWrittenRate/1024, d->mIoUnits, true));
+                        break;
+                }
+                return QVariant();
+            }
+#ifdef Q_WS_X11
+        case HeadingXMemory:
+            return formatMemoryInfo(process->pixmapBytes/1024, d->mUnits, true);
+        case HeadingXTitle:
+            {
+                if(!process->hasManagedGuiWindow)
+                    return QVariant(QVariant::String);
+
+                WindowInfo *w = d->mPidToWindowInfo.value(process->pid, NULL);
+                if(!w)
+                    return QVariant(QVariant::String);
+                else
+                    return w->name;
+            }
+#endif
+        default:
+            return QVariant();
+        }
+        break;
+    }
+    case Qt::ToolTipRole: {
+        if(!d->mShowingTooltips)
+            return QVariant();
+        KSysGuard::Process *process = reinterpret_cast< KSysGuard::Process * > (index.internalPointer());
+        QString tracer;
+        if(process->tracerpid >= 0) {
+            KSysGuard::Process *process_tracer = d->mProcesses->getProcess(process->tracerpid);
+            if(process_tracer) //it is possible for this to be not the case in certain race conditions
+                tracer = i18nc("tooltip. name,pid ","This process is being debugged by %1 (<numid>%2</numid>)", process_tracer->name, (long int)process->tracerpid);
+        }
+        switch(index.column()) {
+        case HeadingName: {
+            QString tooltip = "<qt><p style='white-space:pre'>";
+            /*   It would be nice to be able to show the icon in the tooltip, but Qt4 won't let us put
+             *   a picture in a tooltip :(
+
+            QIcon icon;
+            if(mPidToWindowInfo.contains(process->pid)) {
+                WId wid;
+                wid = mPidToWindowInfo[process->pid].wid;
+                icon = KWindowSystem::icon(wid);
+            }
+            if(icon.isValid()) {
+                tooltip = i18n("<qt><table><tr><td>%1", icon);
+            }
+            */
+            if(process->parent_pid == -1) {
+                //Give a quick explanation of init and kthreadd
+                if(process->name == "init") {
+                    tooltip += i18n("<b>Init</b> is the parent of all other processes and cannot be killed.<br/>");
+                } else if(process->name == "kthreadd") {
+                    tooltip += i18n("<b>KThreadd</b> manages kernel threads. The children processes run in the kernel, controlling hard disk access, etc.<br/>");
+                }
+                tooltip    += i18nc("name column tooltip. first item is the name","<b>%1</b><br />Process ID: <numid>%2</numid>", process->name, (long int)process->pid);
+            }
+            else {
+                KSysGuard::Process *parent_process = d->mProcesses->getProcess(process->parent_pid);
+                if(parent_process) { //In race conditions, it's possible for this process to not exist
+                    tooltip    = i18nc("name column tooltip. first item is the name","<b>%1</b><br />Process ID: <numid>%2</numid><br />Parent: %3<br />Parent's ID: <numid>%4</numid>", process->name, (long int)process->pid, parent_process->name, (long int)process->parent_pid);
+                } else {
+                    tooltip    = i18nc("name column tooltip. first item is the name","<b>%1</b><br />Process ID: <numid>%2</numid><br />Parent's ID: <numid>%3</numid>", process->name, (long int)process->pid, (long int)process->parent_pid);
+                }
+            }
+            if(process->numThreads >= 1)
+                tooltip += i18n("<br/>Number of threads: %1", process->numThreads);
+            if(!process->command.isEmpty()) {
+                tooltip += i18n("<br/>Command: %1", process->command);
+            }
+            if(!process->tty.isEmpty())
+                tooltip += i18n( "<br />Running on: %1", QString(process->tty));
+            if(!tracer.isEmpty())
+                return QString::fromLatin1("%1<br />%2").arg(tooltip).arg(tracer);
+            return tooltip;
+        }
+
+        case HeadingCommand: {
+            QString tooltip =
+                i18n("<qt>This process was run with the following command:<br />%1", process->command);
+            if(!process->tty.isEmpty())
+                tooltip += i18n( "<br /><br />Running on: %1", QString(process->tty));
+            if(tracer.isEmpty()) return tooltip;
+            return QString::fromLatin1("%1<br />%2").arg(tooltip).arg(tracer);
+        }
+        case HeadingUser: {
+            if(!tracer.isEmpty())
+                return QString(d->getTooltipForUser(process) + "<br />" + tracer);
+            return d->getTooltipForUser(process);
+        }
+        case HeadingNiceness: {
+            QString tooltip = "<qt><p style='white-space:pre'>";
+            switch(process->scheduler) {
+              case KSysGuard::Process::Other:
+              case KSysGuard::Process::Batch:
+              case KSysGuard::Process::Interactive:
+                  tooltip += i18n("Nice level: %1 (%2)", process->niceLevel, process->niceLevelAsString() );
+                  break;
+              case KSysGuard::Process::RoundRobin:
+              case KSysGuard::Process::Fifo:
+                  tooltip += i18n("This is a real time process.<br>Scheduler priority: %1", process->niceLevel);
+                  break;
+              case KSysGuard::Process::SchedulerIdle:
+                  break; //has neither dynamic (niceness) or static (scheduler priority) priotiy
+            }
+            if(process->scheduler != KSysGuard::Process::Other)
+                tooltip += i18n("<br/>Scheduler: %1", process->schedulerAsString());
+
+            if(process->ioPriorityClass != KSysGuard::Process::None) {
+                if((process->ioPriorityClass == KSysGuard::Process::RealTime || process->ioPriorityClass == KSysGuard::Process::BestEffort) && process->ioniceLevel != -1)
+                    tooltip += i18n("<br/>I/O Nice level: %1 (%2)", process->ioniceLevel, process->ioniceLevelAsString() );
+                tooltip += i18n("<br/>I/O Class: %1", process->ioPriorityClassAsString() );
+            }
+                if(tracer.isEmpty()) return tooltip;
+            return QString(tooltip + "<br />" + tracer);
+        }
+        case HeadingCPUUsage:
+        case HeadingCPUTime: {
+            int divideby = (d->mNormalizeCPUUsage?d->mNumProcessorCores:1);
+            QString tooltip = ki18n("<qt><p style='white-space:pre'>"
+                        "Process status: %1 %2<br />"
+                        "User CPU usage: %3%<br />"
+                        "System CPU usage: %4%")  /* Please do not add </qt> here - the tooltip is appended to */
+                        .subs(process->translatedStatus())
+                        .subs(d->getStatusDescription(process->status))
+                        .subs((float)(process->userUsage) / divideby)
+                        .subs((float)(process->sysUsage) / divideby)
+                        .toString();
+
+            if(process->numThreads >= 1)
+                tooltip += i18n("<br/>Number of threads: %1", process->numThreads);
+            if(process->numChildren > 0) {
+                tooltip += ki18n("<br />Number of children: %1<br />Total User CPU usage: %2%<br />"
+                        "Total System CPU usage: %3%<br />Total CPU usage: %4%")
+                        .subs(process->numChildren)
+                        .subs((float)(process->totalUserUsage)/ divideby)
+                        .subs((float)(process->totalSysUsage) / divideby)
+                        .subs((float)(process->totalUserUsage + process->totalSysUsage) / divideby)
+                        .toString();
+            }
+            if(process->userTime > 0)
+                tooltip += ki18n("<br /><br />CPU time spent running as user: %1 seconds")
+                        .subs(process->userTime / 100.0, 0, 'f', 1)
+                        .toString();
+            if(process->sysTime > 0)
+                tooltip += ki18n("<br />CPU time spent running in kernel: %1 seconds")
+                        .subs(process->sysTime / 100.0, 0, 'f', 1)
+                        .toString();
+            if(process->niceLevel != 0)
+                tooltip += i18n("<br />Nice level: %1 (%2)", process->niceLevel, process->niceLevelAsString() );
+            if(process->ioPriorityClass != KSysGuard::Process::None) {
+                if((process->ioPriorityClass == KSysGuard::Process::RealTime || process->ioPriorityClass == KSysGuard::Process::BestEffort) && process->ioniceLevel != -1)
+                    tooltip += i18n("<br/>I/O Nice level: %1 (%2)", process->ioniceLevel, process->ioniceLevelAsString() );
+                tooltip += i18n("<br/>I/O Class: %1", process->ioPriorityClassAsString() );
+            }
+
+            if(!tracer.isEmpty())
+                return QString(tooltip + "<br />" + tracer);
+            return tooltip;
+        }
+        case HeadingVmSize: {
+            return QVariant();
+        }
+        case HeadingMemory: {
+            QString tooltip = "<qt><p style='white-space:pre'>";
+            if(process->vmURSS != -1) {
+                //We don't have information about the URSS, so just fallback to RSS
+                if(d->mMemTotal > 0)
+                    tooltip += i18n("Memory usage: %1 out of %2  (%3 %)<br />", KGlobal::locale()->formatByteSize(process->vmURSS * 1024), KGlobal::locale()->formatByteSize(d->mMemTotal*1024), process->vmURSS*100/d->mMemTotal);
+                else
+                    tooltip += i18n("Memory usage: %1<br />", KGlobal::locale()->formatByteSize(process->vmURSS * 1024));
+            }
+            if(d->mMemTotal > 0)
+                tooltip += i18n("RSS Memory usage: %1 out of %2  (%3 %)", KGlobal::locale()->formatByteSize(process->vmRSS * 1024), KGlobal::locale()->formatByteSize(d->mMemTotal*1024), process->vmRSS*100/d->mMemTotal);
+            else
+                tooltip += i18n("RSS Memory usage: %1", KGlobal::locale()->formatByteSize(process->vmRSS * 1024));
+            return tooltip;
+        }
+        case HeadingSharedMemory: {
+            QString tooltip = "<qt><p style='white-space:pre'>";
+            if(process->vmURSS == -1) {
+                tooltip += i18n("Your system does not seem to have this information available to be read.");
+                return tooltip;
+            }
+            if(d->mMemTotal >0)
+                tooltip += i18n("Shared library memory usage: %1 out of %2  (%3 %)", KGlobal::locale()->formatByteSize((process->vmRSS - process->vmURSS) * 1024), KGlobal::locale()->formatByteSize(d->mMemTotal*1024), (process->vmRSS-process->vmURSS)*100/d->mMemTotal);
+            else
+                tooltip += i18n("Shared library memory usage: %1", KGlobal::locale()->formatByteSize((process->vmRSS - process->vmURSS) * 1024));
+
+            return tooltip;
+        }
+        case HeadingIoWrite:
+        case HeadingIoRead: {
+            QString tooltip = "<qt><p style='white-space:pre'>";
+            //FIXME - use the formatByteRate functions when added
+            tooltip += ki18n("Characters read: %1 (%2 KiB/s)<br>Characters written: %3 (%4 KiB/s)<br>Read syscalls: %5 (%6 s⁻¹)<br>Write syscalls: %7 (%8 s⁻¹)<br>Actual bytes read: %9 (%10 KiB/s)<br>Actual bytes written: %11 (%12 KiB/s)")
+                .subs(KGlobal::locale()->formatByteSize(process->ioCharactersRead))
+                .subs(QString::number(process->ioCharactersReadRate/1024))
+                .subs(KGlobal::locale()->formatByteSize(process->ioCharactersWritten))
+                .subs(QString::number(process->ioCharactersWrittenRate/1024))
+                .subs(QString::number(process->ioReadSyscalls))
+                .subs(QString::number(process->ioReadSyscallsRate))
+                .subs(QString::number(process->ioWriteSyscalls))
+                .subs(QString::number(process->ioWriteSyscallsRate))
+                .subs(KGlobal::locale()->formatByteSize(process->ioCharactersActuallyRead))
+                .subs(QString::number(process->ioCharactersActuallyReadRate/1024 ))
+                .subs(KGlobal::locale()->formatByteSize(process->ioCharactersActuallyWritten))
+                .subs(QString::number(process->ioCharactersActuallyWrittenRate/1024))
+                .toString();
+            return tooltip;
+        }
+        case HeadingXTitle: {
+            QString tooltip;
+            QList<WindowInfo *> values = d->mPidToWindowInfo.values(process->pid);
+            if(values.isEmpty()) return QVariant(QVariant::String);
+            for(int i = 0; i < values.size(); i++) {
+                if(!values.at(i)->name.isEmpty())
+                    tooltip += "<li>" + values.at(i)->name + "</li>";
+            }
+            if(!tooltip.isEmpty())
+                return QString("<qt><p style='white-space:pre'><ul>" + tooltip + "</ul>");
+            return QVariant(QVariant::String);
+        }
+
+        default:
+            return QVariant(QVariant::String);
+        }
+    }
+    case Qt::TextAlignmentRole:
+        switch(index.column() ) {
+            case HeadingUser:
+            case HeadingCPUUsage:
+                return QVariant(Qt::AlignCenter);
+            case HeadingNiceness:
+            case HeadingCPUTime:
+            case HeadingPid:
+            case HeadingMemory:
+            case HeadingXMemory:
+            case HeadingSharedMemory:
+            case HeadingVmSize:
+            case HeadingIoWrite:
+            case HeadingIoRead:
+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);
+            default:
+                return QVariant(Qt::AlignLeft | Qt::AlignVCenter);
+        }
+    case UidRole: {
+        if(index.column() != 0) return QVariant();  //If we query with this role, then we want the raw UID for this.
+        KSysGuard::Process *process = reinterpret_cast< KSysGuard::Process * > (index.internalPointer());
+        return process->uid;
+    }
+    case PlainValueRole:  //Used to return a plain value.  For copying to a clipboard etc
+    {
+        KSysGuard::Process *process = reinterpret_cast< KSysGuard::Process * > (index.internalPointer());
+        switch(index.column()) {
+        case HeadingName:
+            return process->name;
+        case HeadingPid:
+            return (qlonglong)process->pid;
+        case HeadingUser:
+            if(!process->login.isEmpty()) return process->login;
+            if(process->uid == process->euid)
+                return d->getUsernameForUser(process->uid, false);
+            else
+                return QString(d->getUsernameForUser(process->uid, false) + ", " + d->getUsernameForUser(process->euid, false));
+        case HeadingNiceness:
+            return process->niceLevel;
+        case HeadingTty:
+            return process->tty;
+        case HeadingCPUUsage:
+            {
+                double total;
+                if(d->mShowChildTotals && !d->mSimple) total = process->totalUserUsage + process->totalSysUsage;
+                else total = process->userUsage + process->sysUsage;
+
+                if(d->mNormalizeCPUUsage)
+                    return total / d->mNumProcessorCores;
+                else
+                    return total;
+            }
+        case HeadingCPUTime:
+            return (qlonglong)(process->userTime + process->sysTime);
+        case HeadingMemory:
+            if(process->vmRSS == 0) return QVariant(QVariant::String);
+            if(process->vmURSS == -1) {
+                return (qlonglong)process->vmRSS;
+            } else {
+                return (qlonglong)process->vmURSS;
+            }
+        case HeadingVmSize:
+            return (qlonglong)process->vmSize;
+        case HeadingSharedMemory:
+            if(process->vmRSS - process->vmURSS < 0 || process->vmURSS == -1) return QVariant(QVariant::String);
+            return (qlonglong)(process->vmRSS - process->vmURSS);
+        case HeadingCommand:
+            return process->command;
+        case HeadingIoRead:
+            switch(d->mIoInformation) {
+                case ProcessModel::Bytes:
+                    return process->ioCharactersRead;
+                case ProcessModel::Syscalls:
+                    return process->ioReadSyscalls;
+                case ProcessModel::ActualBytes:
+                    return process->ioCharactersActuallyRead;
+                case ProcessModel::BytesRate:
+                    return (qlonglong)process->ioCharactersReadRate;
+                case ProcessModel::SyscallsRate:
+                    return (qlonglong)process->ioReadSyscallsRate;
+                case ProcessModel::ActualBytesRate:
+                    return (qlonglong)process->ioCharactersActuallyReadRate;
+
+            }
+        case HeadingIoWrite:
+            switch(d->mIoInformation) {
+                case ProcessModel::Bytes:
+                    return process->ioCharactersWritten;
+                case ProcessModel::Syscalls:
+                    return process->ioWriteSyscalls;
+                case ProcessModel::ActualBytes:
+                    return process->ioCharactersActuallyWritten;
+                case ProcessModel::BytesRate:
+                    return (qlonglong)process->ioCharactersWrittenRate;
+                case ProcessModel::SyscallsRate:
+                    return (qlonglong)process->ioWriteSyscallsRate;
+                case ProcessModel::ActualBytesRate:
+                    return (qlonglong)process->ioCharactersActuallyWrittenRate;
+
+            }
+        case HeadingXMemory:
+            return (qulonglong)process->pixmapBytes;
+#ifdef Q_WS_X11
+        case HeadingXTitle:
+            {
+                WindowInfo *w = d->mPidToWindowInfo.value(process->pid, NULL);
+                if(!w)
+                    return QString();
+                return w->name;
+            }
+#endif
+        default:
+            return QVariant();
+        }
+        break;
+    }
+#ifdef Q_WS_X11
+        case WindowIdRole: {
+        KSysGuard::Process *process = reinterpret_cast< KSysGuard::Process * > (index.internalPointer());
+        WindowInfo *w = d->mPidToWindowInfo.value(process->pid, NULL);
+        if(!w)
+            return (int)0;
+        else
+            return (int)w->wid;
+    }
+#endif
+    case PercentageRole: {
+        KSysGuard::Process *process = reinterpret_cast< KSysGuard::Process * > (index.internalPointer());
+        Q_CHECK_PTR(process);
+        switch(index.column()) {
+            case HeadingCPUUsage: {
+                float cpu;
+                if(d->mSimple || !d->mShowChildTotals)
+                    cpu = process->userUsage + process->sysUsage;
+                else
+                    cpu = process->totalUserUsage + process->totalSysUsage;
+                cpu = cpu / 100.0;
+                if(!d->mNormalizeCPUUsage)
+                    return cpu;
+                return cpu / d->mNumProcessorCores;
+            }
+            case HeadingMemory:
+                if(d->mMemTotal <= 0)
+                    return -1;
+                if(process->vmURSS != -1)
+                    return float(process->vmURSS) / d->mMemTotal;
+                else
+                    return float(process->vmRSS) / d->mMemTotal;
+            case HeadingSharedMemory:
+                if(process->vmURSS == -1 || d->mMemTotal <= 0)
+                    return -1;
+                return float(process->vmRSS - process->vmURSS)/d->mMemTotal;
+            default:
+                return -1;
+        }
+    }
+    case Qt::DecorationRole: {
+        if(index.column() == HeadingName) {
+#ifdef Q_WS_X11
+            KSysGuard::Process *process = reinterpret_cast< KSysGuard::Process * > (index.internalPointer());
+            if(!process->hasManagedGuiWindow) {
+                if(d->mSimple) //When not in tree mode, we need to pad the name column where we do not have an icon
+                    return QIcon(d->mBlankPixmap);
+                else  //When in tree mode, the padding looks bad, so do not pad in this case
+                    return QVariant();
+            }
+            WindowInfo *w = d->mPidToWindowInfo.value(process->pid, NULL);
+            if(w && !w->icon.isNull())
+                return w->icon;
+            return QIcon(d->mBlankPixmap);
+#else
+            return QVariant();
+#endif
+
+        } else if (index.column() == HeadingCPUUsage) {
+            KSysGuard::Process *process = reinterpret_cast< KSysGuard::Process * > (index.internalPointer());
+            if(process->status == KSysGuard::Process::Stopped || process->status == KSysGuard::Process::Zombie) {
+            //        QPixmap pix = KIconLoader::global()->loadIcon("button_cancel", KIconLoader::Small,
+        //                    KIconLoader::SizeSmall, KIconLoader::DefaultState, QStringList(),
+        //                0L, true);
+
+            }
+        }
+        return QVariant();
+    }
+    case Qt::BackgroundRole: {
+        if (index.column() != HeadingUser) {
+            if (!d->mHaveTimer) //If there is no timer, then no processes are being killed, so no point looking for one
+                return QVariant();
+            KSysGuard::Process *process = reinterpret_cast< KSysGuard::Process * > (index.internalPointer());
+            if (!process->timeKillWasSent.isNull()) {
+                int elapsed = process->timeKillWasSent.elapsed();
+                if (elapsed < MILLISECONDS_TO_SHOW_RED_FOR_KILLED_PROCESS) {//Only show red for about 7 seconds
+                    int transparency = 255 - elapsed*250/MILLISECONDS_TO_SHOW_RED_FOR_KILLED_PROCESS;
+
+                    KColorScheme scheme(QPalette::Active, KColorScheme::Selection);
+                    QBrush brush = scheme.background(KColorScheme::NegativeBackground);
+                    QColor color = brush.color();
+                    color.setAlpha(transparency);
+                    brush.setColor(color);
+                    return brush;
+                }
+            }
+            return QVariant();
+        }
+        KSysGuard::Process *process = reinterpret_cast< KSysGuard::Process * > (index.internalPointer());
+        if(process->status == KSysGuard::Process::Ended) {
+            return QColor(Qt::lightGray);
+        }
+        if(process->tracerpid >= 0) {
+            //It's being debugged, so probably important.  Let's mark it as such
+            return QColor(Qt::yellow);
+        }
+        if(d->mIsLocalhost && process->uid == getuid()) { //own user
+            return QColor(0, 208, 214, 50);
+        }
+        if(process->uid < 100 || !canUserLogin(process->uid))
+            return QColor(218, 220,215, 50); //no color for system tasks
+        //other users
+        return QColor(2, 154, 54, 50);
+    }
+    case Qt::FontRole: {
+        if(index.column() == HeadingCPUUsage) {
+            KSysGuard::Process *process = reinterpret_cast< KSysGuard::Process * > (index.internalPointer());
+            if(process->userUsage == 0) {
+                QFont font;
+                font.setItalic(true);
+                return font;
+            }
+        }
+        return QVariant();
+    }
+    default: //This is a very very common case, so the route to this must be very minimal
+        return QVariant();
+    }
+
+    return QVariant(); //never get here, but make compiler happy
+}
+
+bool ProcessModel::hasGUIWindow(qlonglong pid) const
+{
+#ifdef Q_WS_X11
+    return d->mPidToWindowInfo.contains(pid);
+#else
+    return false;
+#endif
+}
+
+bool ProcessModel::isLocalhost() const
+{
+    return d->mIsLocalhost;
+}
+
+
+void ProcessModel::setupHeader() {
+    //These must be in the same order that they are in in the header file
+    QStringList headings;
+    headings << i18nc("process heading", "Name");
+    headings << i18nc("process heading", "Username");
+    headings << i18nc("process heading", "PID");
+    headings << i18nc("process heading", "TTY");
+    headings << i18nc("process heading", "Niceness");
+    // xgettext: no-c-format
+    headings << i18nc("process heading", "CPU %");
+    headings << i18nc("process heading", "CPU Time");
+    headings << i18nc("process heading", "IO Read");
+    headings << i18nc("process heading", "IO Write");
+    headings << i18nc("process heading", "Virtual Size");
+    headings << i18nc("process heading", "Memory");
+    headings << i18nc("process heading", "Shared Mem");
+    headings << i18nc("process heading", "Command");
+#ifdef Q_WS_X11
+    headings << i18nc("process heading", "X11 Memory");
+    headings << i18nc("process heading", "Window Title");
+#endif
+
+    if(d->mHeadings.isEmpty()) { // If it's empty, this is the first time this has been called, so insert the headings
+        beginInsertColumns(QModelIndex(), 0, headings.count()-1);
+        {
+            d->mHeadings = headings;
+        }
+        endInsertColumns();
+    } else {
+        // This was called to retranslate the headings.  Just use the new translations and call headerDataChanged
+        Q_ASSERT(d->mHeadings.count() == headings.count());
+        d->mHeadings = headings;
+        headerDataChanged(Qt::Horizontal, 0 , headings.count()-1);
+
+    }
+}
+
+void ProcessModel::retranslateUi()
+{
+    setupHeader();
+}
+
+KSysGuard::Process *ProcessModel::getProcess(qlonglong pid) {
+    return d->mProcesses->getProcess(pid);
+}
+
+bool ProcessModel::showTotals() const {
+    return d->mShowChildTotals;
+}
+
+void ProcessModel::setShowTotals(bool showTotals)  //slot
+{
+    if(showTotals == d->mShowChildTotals) return;
+    d->mShowChildTotals = showTotals;
+
+    QModelIndex index;
+    foreach( KSysGuard::Process *process, d->mProcesses->getAllProcesses()) {
+        if(process->numChildren > 0) {
+            int row;
+            if(d->mSimple)
+                row = process->index;
+            else
+                row = process->parent->children.indexOf(process);
+            index = createIndex(row, HeadingCPUUsage, process);
+            emit dataChanged(index, index);
+        }
+    }
+}
+
+qlonglong ProcessModel::totalMemory() const
+{
+    return d->mMemTotal;
+}
+void ProcessModel::setUnits(Units units)
+{
+    if(d->mUnits == units)
+        return;
+    d->mUnits = units;
+
+    QModelIndex index;
+    foreach( KSysGuard::Process *process, d->mProcesses->getAllProcesses()) {
+        int row;
+        if(d->mSimple)
+            row = process->index;
+        else
+            row = process->parent->children.indexOf(process);
+        index = createIndex(row, HeadingMemory, process);
+        emit dataChanged(index, index);
+        index = createIndex(row, HeadingXMemory, process);
+        emit dataChanged(index, index);
+        index = createIndex(row, HeadingSharedMemory, process);
+        emit dataChanged(index, index);
+        index = createIndex(row, HeadingVmSize, process);
+        emit dataChanged(index, index);
+    }
+}
+ProcessModel::Units ProcessModel::units() const
+{
+    return (Units) d->mUnits;
+}
+void ProcessModel::setIoUnits(Units units)
+{
+    if(d->mIoUnits == units)
+        return;
+    d->mIoUnits = units;
+
+    QModelIndex index;
+    foreach( KSysGuard::Process *process, d->mProcesses->getAllProcesses()) {
+        int row;
+        if(d->mSimple)
+            row = process->index;
+        else
+            row = process->parent->children.indexOf(process);
+        index = createIndex(row, HeadingIoRead, process);
+        emit dataChanged(index, index);
+        index = createIndex(row, HeadingIoWrite, process);
+        emit dataChanged(index, index);
+    }
+
+}
+ProcessModel::Units ProcessModel::ioUnits() const
+{
+    return (Units) d->mIoUnits;
+}
+void ProcessModel::setIoInformation( ProcessModel::IoInformation ioInformation )
+{
+    d->mIoInformation = ioInformation;
+}
+ProcessModel::IoInformation ProcessModel::ioInformation() const
+{
+    return d->mIoInformation;
+}
+QString ProcessModel::formatMemoryInfo(qlonglong amountInKB, Units units, bool returnEmptyIfValueIsZero) const
+{
+    //We cache the result of i18n for speed reasons.  We call this function
+    //hundreds of times, every second or so
+    if(returnEmptyIfValueIsZero && amountInKB == 0)
+        return QString();
+    static QString percentageString = i18n("%1%", QString::fromLatin1("%1"));
+    if (units == UnitsPercentage) {
+        if(d->mMemTotal == 0)
+            return ""; //memory total not determined yet.  Shouldn't happen, but don't crash if it does
+        float percentage = amountInKB*100.0/d->mMemTotal;
+        if(percentage < 0.1) percentage = 0.1;
+        return percentageString.arg(percentage, 0, 'f', 1);
+    } else
+        return formatByteSize(amountInKB, units);
+}
+
+QString ProcessModel::hostName() const {
+    return d->mHostName;
+}
+QStringList ProcessModel::mimeTypes() const
+{
+    QStringList types;
+    types << "text/plain";
+    types << "text/csv";
+    types << "text/html";
+    return types;
+}
+QMimeData *ProcessModel::mimeData(const QModelIndexList &indexes) const
+{
+    QMimeData *mimeData = new QMimeData();
+    QString textCsv;
+    QString textCsvHeaders;
+    QString textPlain;
+    QString textPlainHeaders;
+    QString textHtml;
+    QString textHtmlHeaders;
+    QString display;
+    int firstColumn = -1;
+    bool firstrow = true;
+    foreach (const QModelIndex &index, indexes) {
+        if (index.isValid()) {
+            if(firstColumn == -1)
+                firstColumn = index.column();
+            else if(firstColumn != index.column())
+                continue;
+            else {
+                textCsv += '\n';
+                textPlain += '\n';
+                textHtml += "</tr><tr>";
+                firstrow = false;
+            }
+            for(int i = 0; i < d->mHeadings.size(); i++) {
+                if(firstrow) {
+                    QString heading = d->mHeadings[i];
+                    textHtmlHeaders += "<th>" + heading + "</th>";
+                    if(i) {
+                        textCsvHeaders += ',';
+                        textPlainHeaders += ", ";
+                    }
+                    textPlainHeaders += heading;
+                    heading.replace('"', "\"\"");
+                    textCsvHeaders += '"' + heading + '"';
+                }
+                QModelIndex index2 = createIndex(index.row(), i, reinterpret_cast< KSysGuard::Process * > (index.internalPointer()));
+                QString display = data(index2, PlainValueRole).toString();
+                if(i) {
+                    textCsv += ',';
+                    textPlain += ", ";
+                }
+                textHtml += "<td>" + Qt::escape(display) + "</td>";
+                textPlain += display;
+                display.replace('"',"\"\"");
+                textCsv += '"' + display + '"';
+            }
+        }
+    }
+    textHtml = "<html><table><tr>" + textHtmlHeaders + "</tr><tr>" + textHtml + "</tr></table>";
+    textCsv = textCsvHeaders + '\n' + textCsv;
+    textPlain = textPlainHeaders + '\n' + textPlain;
+
+    mimeData->setText(textPlain);
+    mimeData->setHtml(textHtml);
+    mimeData->setData("text/csv", textCsv.toUtf8());
+    return mimeData;
+
+}
+Qt::ItemFlags ProcessModel::flags(const QModelIndex &index) const
+{
+    if (!index.isValid())
+        return Qt::NoItemFlags; //Would this ever happen?
+
+    KSysGuard::Process *process = reinterpret_cast< KSysGuard::Process * > (index.internalPointer());
+    if(process->status == KSysGuard::Process::Ended)
+        return Qt::ItemIsDragEnabled | Qt::ItemIsSelectable;
+    else
+        return Qt::ItemIsDragEnabled | Qt::ItemIsSelectable | Qt::ItemIsEnabled;
+
+}
+
+bool ProcessModel::isShowCommandLineOptions() const
+{
+    return d->mShowCommandLineOptions;
+}
+void ProcessModel::setShowCommandLineOptions(bool showCommandLineOptions)
+{
+    d->mShowCommandLineOptions = showCommandLineOptions;
+}
+bool ProcessModel::isShowingTooltips() const
+{
+    return d->mShowingTooltips;
+}
+void ProcessModel::setShowingTooltips(bool showTooltips)
+{
+    d->mShowingTooltips = showTooltips;
+}
+bool ProcessModel::isNormalizedCPUUsage() const
+{
+    return d->mNormalizeCPUUsage;
+}
+void ProcessModel::setNormalizedCPUUsage(bool normalizeCPUUsage)
+{
+    d->mNormalizeCPUUsage = normalizeCPUUsage;
+}
+
+void ProcessModelPrivate::timerEvent( QTimerEvent * event )
+{
+    Q_UNUSED(event);
+    foreach (qlonglong pid, mPidsToUpdate) {
+        KSysGuard::Process *process = mProcesses->getProcess(pid);
+        if (process && !process->timeKillWasSent.isNull() && process->timeKillWasSent.elapsed() < MILLISECONDS_TO_SHOW_RED_FOR_KILLED_PROCESS) {
+            int row;
+            if(mSimple)
+                row = process->index;
+            else
+                row = process->parent->children.indexOf(process);
+
+            QModelIndex index1 = q->createIndex(row, 0, process);
+            QModelIndex index2 = q->createIndex(row, mHeadings.count()-1, process);
+            emit q->dataChanged(index1, index2);
+        } else {
+            mPidsToUpdate.removeAll(pid);
+        }
+    }
+
+    if (mPidsToUpdate.isEmpty()) {
+        mHaveTimer = false;
+        killTimer(mTimerId);
+        mTimerId = -1;
+    }
+}
+
diff --git a/debuggers/gdb/ksysguard/ProcessModel.h b/debuggers/gdb/ksysguard/ProcessModel.h
new file mode 100644
index 0000000..506cc17
--- /dev/null
+++ b/debuggers/gdb/ksysguard/ProcessModel.h
@@ -0,0 +1,189 @@
+/*
+    KSysGuard, the KDE System Guard
+
+	Copyright (c) 1999, 2000 Chris Schlaeger <cs@kde.org>
+	Copyright (c) 2006 John Tapsell <john.tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef PROCESSMODEL_H_
+#define PROCESSMODEL_H_
+
+#include <QtCore/QAbstractItemModel>
+
+#include <kdemacros.h>
+#include "processes.h"
+
+namespace KSysGuard {
+	class Processes;
+	class Process;
+}
+
+class ProcessModelPrivate;
+
+#ifdef Q_OS_WIN
+// this workaround is needed to make krunner link under msvc
+// please keep it this way even if you port this library to have a _export.h header file
+#define KSYSGUARD_EXPORT
+#else
+#define KSYSGUARD_EXPORT KDE_EXPORT
+#endif
+
+class KSYSGUARD_EXPORT ProcessModel : public QAbstractItemModel
+{
+    Q_OBJECT
+    Q_ENUMS(Units)
+
+    public:
+        ProcessModel(QObject* parent = 0, const QString &host = QString() );
+        virtual ~ProcessModel();
+
+        /* Functions for our Model for QAbstractItemModel*/
+        int rowCount(const QModelIndex &parent = QModelIndex()) const;
+        int columnCount ( const QModelIndex & parent = QModelIndex() ) const;
+        QVariant data(const QModelIndex &index, int role) const;
+        QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const;
+        QModelIndex index ( int row, int column, const QModelIndex & parent = QModelIndex() ) const;
+        QModelIndex parent ( const QModelIndex & index ) const;
+
+        bool hasChildren ( const QModelIndex & parent) const;
+        /** Returns if (left < right), used by the sort-filter proxy model to sort the columns */
+        bool lessThan( const QModelIndex & left, const QModelIndex & right) const;
+
+        /* Functions for drag and drop and copying to clipboard, inherited from QAbstractItemModel */
+        QStringList mimeTypes() const;
+        QMimeData *mimeData(const QModelIndexList &indexes) const;
+        Qt::ItemFlags flags(const QModelIndex &index) const;
+
+        /* Functions for setting the model */
+
+        /** Setup the column headings by inserting the appropriate headings into the model.
+         *  Can be called more than once to retranslate the headings if the system language changes.
+         */
+        void setupHeader();
+
+        /** Update data.  You can pass in the time between updates to only update if there hasn't
+         *  been an update within the last @p updateDurationMSecs milliseconds.  0 indicate to update
+         *  regardless of when the last update was.
+         *  The updateFlags indicates what to additional update, as well as the usual details. */
+        void update(long updateDurationMSecs = 0, KSysGuard::Processes::UpdateFlags updateFlags = KSysGuard::Processes::IOStatistics);
+        /** Return a string with the pid of the process and the name of the process.  E.g.  13343: ksysguard
+        */
+        QString getStringForProcess(KSysGuard::Process *process) const;
+        KSysGuard::Process *getProcess(qlonglong pid);
+
+        /** This is used from ProcessFilter to get the process at a given index when in flat mode */
+        KSysGuard::Process *getProcessAtIndex(int index) const;
+
+        /** Returns whether this user can log in or not.
+         *  @see mUidCanLogin
+         */
+        bool canUserLogin(long uid) const;
+        /** In simple mode, everything is flat, with no icons, few if any colors, no xres etc.
+         *  This can be changed at any time.  It is a fairly quick operation.  Basically it resets the model
+         */
+        void setSimpleMode(bool simple);
+        /** In simple mode, everything is flat, with no icons, few if any colors, no xres etc
+        */
+        bool isSimpleMode() const;
+
+        /** Returns the total amount of physical memory in the machine. */
+        qlonglong totalMemory() const;
+
+        /** This returns a QModelIndex for the given process.  It has to look up the parent for this pid, find the offset this
+         *  pid is from the parent, and return that.  It's not that slow, but does involve a couple of hash table lookups.
+         */
+        QModelIndex getQModelIndex ( KSysGuard::Process *process, int column) const;
+
+        /** Whether this is showing the processes for the current machine
+        */
+        bool isLocalhost() const;
+
+        /** The host name that this widget is showing the processes of */
+        QString hostName() const;
+
+        /** Whether this process has a GUI window */
+        bool hasGUIWindow(qlonglong pid) const;
+
+        /** Returns for process controller pointer for this model */
+        KSysGuard::Processes *processController() const;   //The processes instance
+
+        /** Convenience function to get the number of processes.
+         *
+         *  Equivalent to processController->processCount() */
+        int processCount() const { return processController()->processCount(); }
+
+        /** The headings in the model.  The order here is the order that they are shown
+         *  in.  If you change this, make sure you also change the
+         *  setup header function, and make sure you increase PROCESSHEADERVERSION.  This will ensure
+         *  that old saved settings won't be used
+         */
+#define PROCESSHEADERVERSION 5
+        enum { HeadingName=0, HeadingUser, HeadingPid, HeadingTty, HeadingNiceness, HeadingCPUUsage, HeadingCPUTime, HeadingIoRead, HeadingIoWrite, HeadingVmSize, HeadingMemory, HeadingSharedMemory, HeadingCommand, HeadingXMemory, HeadingXTitle };
+
+        enum { UidRole = Qt::UserRole, SortingValueRole, WindowIdRole, PlainValueRole, PercentageRole };
+
+        bool showTotals() const;
+
+        /** When displaying memory sizes, this is the units it should be displayed in */
+        enum Units { UnitsAuto, UnitsKB, UnitsMB, UnitsGB, UnitsTB, UnitsPB, UnitsPercentage  };
+        /** Set the units memory sizes etc should be displayed in */
+        void setUnits(Units units);
+        /** The units memory sizes etc should be displayed in */
+        Units units() const;
+        /** Set the I/O units sizes etc should be displayed in */
+        void setIoUnits(Units units);
+        /** The units I/O sizes etc should be displayed in */
+        Units ioUnits() const;
+
+        enum IoInformation { Bytes, Syscalls, ActualBytes, BytesRate, SyscallsRate, ActualBytesRate };
+        /** Set the information to show in the Io Read and Io Write columns */
+        void setIoInformation( IoInformation ioInformation );
+        /** The information to show in the Io Read and Io Write columns */
+        IoInformation ioInformation() const;
+
+        /** Take an amount in kb, and return a string in the units set by setUnits() */
+        QString formatMemoryInfo(qlonglong amountInKB, Units units, bool returnEmptyIfValueIsZero = false) const;
+        /** Whether to show the command line options in the process name column */
+        bool isShowCommandLineOptions() const;
+        /** Set whether to show the command line options in the process name column */
+        void setShowCommandLineOptions(bool showCommandLineOptions);
+
+        /** Whether to show tooltips when the mouse hovers over a process */
+        bool isShowingTooltips() const;
+        /** Set whether to show tooltips when the mouse hovers over a process */
+        void setShowingTooltips(bool showTooltips);
+        /** Whether to divide CPU usage by the number of CPUs */
+        bool isNormalizedCPUUsage() const;
+        /** Set whether to divide CPU usage by the number of CPUs */
+        void setNormalizedCPUUsage(bool normalizeCPUUsage);
+
+        /** Retranslate the GUI, for when the system language changes */
+        void retranslateUi();
+
+    public Q_SLOTS:
+        /** Whether to show the total cpu for the process plus all of its children */
+        void setShowTotals(bool showTotals);
+
+    private:
+        ProcessModelPrivate*  const d;
+        friend class ProcessModelPrivate;
+};
+
+#endif
+
diff --git a/debuggers/gdb/ksysguard/ProcessModel_p.h b/debuggers/gdb/ksysguard/ProcessModel_p.h
new file mode 100644
index 0000000..fea5004
--- /dev/null
+++ b/debuggers/gdb/ksysguard/ProcessModel_p.h
@@ -0,0 +1,218 @@
+/*
+    KSysGuard, the KDE System Guard
+
+    Copyright (c) 2006-2007 John Tapsell <john.tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef PROCESSMODEL_P_H_
+#define PROCESSMODEL_P_H_
+
+#include "process.h"
+#include "ProcessModel.h"
+
+#include <kapplication.h>
+#include <kuser.h>
+#include <QPixmap>
+#include <QObject>
+#include <QList>
+#include <QVariant>
+#include <QHash>
+#include <QSet>
+#include <QTime>
+#include <QDebug>
+
+#ifdef Q_WS_X11
+#include <kwindowsystem.h>
+#include <netwm.h>
+#include <QtGui/QX11Info>
+#include <X11/Xatom.h>
+#include <kxerrorhandler.h>
+
+struct WindowInfo {
+
+    WindowInfo(WId _wid, qlonglong _pid) {
+        wid = _wid;
+        pid = 0;
+        pid = _pid;
+    }
+    qlonglong pid;
+    QPixmap icon;
+    WId wid;
+    QString name;
+};
+#include "config-ksysguard.h"
+#endif
+
+namespace KSysGuard { class Processes; }
+
+class ProcessModelPrivate : public QObject
+{
+    Q_OBJECT
+    public:
+        ProcessModelPrivate();
+        ~ProcessModelPrivate();
+    public Q_SLOTS:
+
+#ifdef Q_WS_X11
+        /** When an X window is changed, this is called */
+        void windowChanged(WId wid, unsigned int properties);
+        /** When an X window is created, this is called
+        */
+        void windowAdded(WId wid);
+        /** When an X window is closed, this is called
+        */
+        void windowRemoved(WId wid);
+#endif
+
+        /** Change the data for a process.  This is called from KSysGuard::Processes
+         *  if @p onlyCpuOrMem is set, only the total cpu usuage is updated.
+         *  process->changes  contains a bitfield of what has been changed
+         */
+        void processChanged(KSysGuard::Process *process, bool onlyCpuOrMem);
+        /** Called from KSysGuard::Processes
+         *  This indicates we are about to insert a process in the model.  Emit the appropriate signals
+         */
+        void beginInsertRow( KSysGuard::Process *parent);
+        /** Called from KSysGuard::Processes
+         *  We have finished inserting a process
+         */
+        void endInsertRow();
+        /** Called from KSysGuard::Processes
+         *  This indicates we are about to remove a process in the model.  Emit the appropriate signals
+         */
+        void beginRemoveRow( KSysGuard::Process *process);
+        /** Called from KSysGuard::Processes
+         *  We have finished removing a process
+         */
+        void endRemoveRow();
+        /** Called from KSysGuard::Processes
+         *  This indicates we are about to move a process in the model from one parent process to another.  Emit the appropriate signals
+         */
+        void beginMoveProcess(KSysGuard::Process *process, KSysGuard::Process *new_parent);
+        /** Called from KSysGuard::Processes
+         *  We have finished moving a process
+         */
+        void endMoveRow();
+
+    public:
+        /** Connects to the host */
+        void setupProcesses();
+        /** A mapping of running,stopped,etc  to a friendly description like 'Stopped, either by a job control signal or because it is being traced.'*/
+        QString getStatusDescription(KSysGuard::Process::ProcessStatus status) const;
+
+        /** Return a qt markup tooltip string for a local user.  It will have their full name etc.
+         *  This will be slow the first time, as it practically indirectly reads the whole of /etc/passwd
+         *  But the second time will be as fast as hash lookup as we cache the result
+         */
+        inline QString getTooltipForUser(const KSysGuard::Process *process) const;
+
+        /** Return a username for a local user if it can, otherwise just their uid.
+         *  This may have been given from the result of "ps" (but not necessarily).
+         *  If it's not found, then it needs to find out the username from the uid.
+         *  This will be slow the first time, as it practically indirectly reads the whole of /etc/passwd
+         *  But the second time will be as fast as hash lookup as we cache the result
+         *
+         *  If withuid is set, and the username is found, return: "username (Uid: uid)"
+         */
+        inline QString getUsernameForUser(long uid, bool withuid) const;
+
+        /** Return the groupname for a given gid.  This is in the form of "gid" if not known, or
+         *  "groupname (Uid: gid)" if known.
+         */
+        inline QString getGroupnameForGroup(long gid) const;
+#ifdef Q_WS_X11
+        /** On X11 system, connects to the signals emitted when windows are created/destroyed */
+        void setupWindows();
+        void updateWindowInfo(WId wid, unsigned int properties, bool newWindow);
+        QMultiHash< long long, WindowInfo *> mPidToWindowInfo;  ///< Map a process pid to X window info if available
+        QHash< WId, WindowInfo *> mWIdToWindowInfo; ///< Map an X window id to window info
+#ifdef HAVE_XRES
+        bool updateXResClientData();
+        void queryForAndUpdateAllXWindows();
+#endif
+#endif
+        virtual void timerEvent ( QTimerEvent * event ); ///< Call dataChanged() for all the processes in mPidsToUpdate
+        /** @see setIsLocalhost */
+        bool mIsLocalhost;
+
+        /** A caching hash for tooltips for a user.
+         *  @see getTooltipForUser */
+        mutable QHash<long long,QString> mUserTooltips;
+
+        /** A caching hash for username for a user uid, or just their uid if it can't be found (as a long long)
+         *  @see getUsernameForUser */
+        mutable QHash<long long, QString> mUserUsername;
+
+        /** A mapping of a user id to whether this user can log in.  We have to guess based on the shell.
+         *  All are set to true to non localhost.
+         *  It is set to:
+         *    0 if the user cannot login
+         *    1 is the user can login
+         *  The reason for using an int and not a bool is so that we can do
+         *  \code mUidCanLogin.value(uid,-1) \endcode  and thus we get a tristate for whether
+         *  they are logged in, not logged in, or not known yet.
+         *  */
+        mutable QHash<long long, int> mUidCanLogin;
+
+
+        /** A translated list of headings (column titles) in the order we want to display them. Used in headerData() */
+        QStringList mHeadings;
+
+        bool mShowChildTotals; ///< If set to true, a parent will return the CPU usage of all its children recursively
+
+        bool mSimple; //< In simple mode, the model returns everything as flat, with no icons, etc.  This is set by changing cmbFilter
+
+        QTime mLastUpdated; ///< Time that we last updated the processes.
+
+        long long mMemTotal; ///< the total amount of physical memory in kb in the machine.  We can used this to determine the percentage of memory an app is using
+        int mNumProcessorCores;  ///< The number of (enabled) processor cores in the this machine
+
+        KSysGuard::Processes *mProcesses;  ///< The processes instance
+
+        QPixmap mBlankPixmap; ///< Used to pad out process names which don't have an icon
+
+        /** Show the process command line options in the process name column */
+        bool mShowCommandLineOptions;
+
+        bool mShowingTooltips;
+        bool mNormalizeCPUUsage;
+        /** When displaying memory sizes, this is the units it should be displayed in */
+        ProcessModel::Units mUnits;
+        ProcessModel::Units mIoUnits;
+
+        ProcessModel::IoInformation mIoInformation;
+
+        /** The hostname */
+        QString mHostName;
+        bool mHaveTimer;
+        int mTimerId;
+        QList<long> mPidsToUpdate;  ///< A list of pids that we need to emit dataChanged() for regularly
+
+#ifdef HAVE_XRES
+        bool mHaveXRes; ///< True if the XRes extension is available at run time
+        QMap<qlonglong, XID> mXResClientResources;
+#endif
+
+        bool mMovingRow;
+        bool mRemovingRow;
+        bool mInsertingRow;
+
+        ProcessModel* q;
+};
+
+#endif
diff --git a/debuggers/gdb/ksysguard/ProcessWidgetUI.ui b/debuggers/gdb/ksysguard/ProcessWidgetUI.ui
new file mode 100644
index 0000000..362bde9
--- /dev/null
+++ b/debuggers/gdb/ksysguard/ProcessWidgetUI.ui
@@ -0,0 +1,188 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>ProcessWidget</class>
+ <widget class="QWidget" name="ProcessWidget">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>490</width>
+    <height>472</height>
+   </rect>
+  </property>
+  <layout class="QVBoxLayout">
+   <property name="margin">
+    <number>0</number>
+   </property>
+   <item>
+    <layout class="QHBoxLayout">
+     <item>
+      <widget class="QPushButton" name="btnKillProcess">
+       <property name="enabled">
+        <bool>false</bool>
+       </property>
+       <property name="sizePolicy">
+        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
+         <horstretch>0</horstretch>
+         <verstretch>0</verstretch>
+        </sizepolicy>
+       </property>
+       <property name="toolTip">
+        <string/>
+       </property>
+       <property name="whatsThis">
+        <string>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
+&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'DejaVu Sans'; font-size:8pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Attempt to kill the currently selected process by sending it the SIGTERM signal.&lt;/p&gt;
+&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-style:italic;&quot;&gt;Technical information: &lt;/span&gt;&lt;br /&gt;The SIGTERM signal is sent to the given process. If there are insufficient privileges to do so, by default a password is requested.&lt;br /&gt;By running the program &lt;span style=&quot; font-family:'Courier New,courier';&quot;&gt;polkit-kde-authorization&lt;/span&gt; you can give certain (or all) users permission to kill any process, without requiring a password. &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+       </property>
+       <property name="text">
+        <string>&amp;End Process...</string>
+       </property>
+       <property name="autoDefault">
+        <bool>false</bool>
+       </property>
+       <property name="default">
+        <bool>false</bool>
+       </property>
+       <property name="flat">
+        <bool>false</bool>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="KLineEdit" name="txtFilter">
+       <property name="whatsThis">
+        <string>Filter which processes are shown by the text given here.  The text can be a partial string match of the Name, Command or Window Title of the process.  It can also be a Username or a Process ID number.&lt;p&gt;
+For example:
+
+&lt;table&gt;
+&lt;tr&gt;&lt;th&gt;ksys&lt;/th&gt;&lt;td&gt;Show processes containing &quot;&lt;b&gt;ksys&lt;/b&gt;&quot; in the name, for example the processes &quot;&lt;i&gt;ksysguard&lt;/i&gt;&quot; and &quot;&lt;i&gt;ksysguardd&lt;/i&gt;&quot;.&lt;td&gt;&lt;/tr&gt;
+&lt;tr&gt;&lt;th&gt;root&lt;/th&gt;&lt;td&gt;Show processes owned by &lt;b&gt;root&lt;/b&gt;.  For example &lt;i&gt;init&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
+&lt;tr&gt;&lt;th&gt;1234&lt;/th&gt;&lt;td&gt;Show the processes with the PID or Parent PID of &lt;b&gt;1234&lt;/b&gt;.&lt;/td&gt;&lt;/th&gt;&lt;/tr&gt;
+&lt;/table&gt;
+</string>
+       </property>
+       <property name="urlDropsEnabled">
+        <bool>false</bool>
+       </property>
+       <property name="clickMessage">
+        <string>Quick search</string>
+       </property>
+       <property name="showClearButton" stdset="0">
+        <bool>true</bool>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QComboBox" name="cmbFilter">
+       <property name="sizePolicy">
+        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
+         <horstretch>0</horstretch>
+         <verstretch>0</verstretch>
+        </sizepolicy>
+       </property>
+       <property name="whatsThis">
+        <string>&lt;qt&gt;Change which processes are shown, and how they are shown.  The processes can be further filtered by using the Quick Search text filter.&lt;p&gt;
+&lt;table&gt;
+&lt;tr&gt;&lt;td&gt;All Processes&lt;/td&gt;&lt;td&gt;Show all the processes on the system.&lt;/td&gt;&lt;/tr&gt;
+&lt;tr&gt;&lt;td&gt;All Processes, tree&lt;/td&gt;&lt;td&gt;Show all the processes on the system, in a hierarchical manner using the parent PID information.&lt;/td&gt;&lt;/tr&gt;
+&lt;tr&gt;&lt;td&gt;System Processes&lt;/td&gt;&lt;td&gt;Show processes running as root and as a user who cannot login.&lt;/td&gt;&lt;/tr&gt;
+&lt;tr&gt;&lt;td&gt;User Processes&lt;/td&gt;&lt;td&gt;Show processes running as a non-root user who can login.&lt;/td&gt;&lt;/tr&gt;
+&lt;tr&gt;&lt;td&gt;Own Processes&lt;/td&gt;&lt;td&gt;Show processes owned by the same user that this process is owned by.&lt;/td&gt;&lt;/tr&gt;
+&lt;tr&gt;&lt;td&gt;Programs Only&lt;/td&gt;&lt;td&gt;Show processes which are running as a user who can login and are either attached to a TTY or have at least one X11 Window.&lt;/td&gt;&lt;/tr&gt;
+&lt;/table&gt;
+&lt;p&gt;
+&lt;i&gt;Technical Information:&lt;/i&gt;&lt;br&gt;
+Processes with multiple threads are just shown as a single process, and not treated any differently.&lt;br&gt;
+Kernel threads are shown as normal processes, but are actually running inside the kernel and are not real processes.  As such, many of the fields (such as Username) do not apply.
+</string>
+       </property>
+       <property name="maxCount">
+        <number>10</number>
+       </property>
+       <property name="sizeAdjustPolicy">
+        <enum>QComboBox::AdjustToContentsOnFirstShow</enum>
+       </property>
+       <item>
+        <property name="text">
+         <string>All Processes</string>
+        </property>
+       </item>
+       <item>
+        <property name="text">
+         <string>All Processes, Tree</string>
+        </property>
+       </item>
+       <item>
+        <property name="text">
+         <string>System Processes</string>
+        </property>
+       </item>
+       <item>
+        <property name="text">
+         <string>User Processes</string>
+        </property>
+       </item>
+       <item>
+        <property name="text">
+         <string>Own Processes</string>
+        </property>
+       </item>
+       <item>
+        <property name="text">
+         <string>Programs Only</string>
+        </property>
+       </item>
+      </widget>
+     </item>
+    </layout>
+   </item>
+   <item>
+    <widget class="QTreeView" name="treeView">
+     <property name="editTriggers">
+      <set>QAbstractItemView::NoEditTriggers</set>
+     </property>
+     <property name="alternatingRowColors">
+      <bool>true</bool>
+     </property>
+     <property name="selectionMode">
+      <enum>QAbstractItemView::ExtendedSelection</enum>
+     </property>
+     <property name="selectionBehavior">
+      <enum>QAbstractItemView::SelectRows</enum>
+     </property>
+     <property name="rootIsDecorated">
+      <bool>false</bool>
+     </property>
+     <property name="uniformRowHeights">
+      <bool>true</bool>
+     </property>
+     <property name="itemsExpandable">
+      <bool>true</bool>
+     </property>
+     <property name="sortingEnabled">
+      <bool>true</bool>
+     </property>
+     <property name="animated">
+      <bool>false</bool>
+     </property>
+     <property name="allColumnsShowFocus">
+      <bool>true</bool>
+     </property>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <customwidgets>
+  <customwidget>
+   <class>KLineEdit</class>
+   <extends>QLineEdit</extends>
+   <header>klineedit.h</header>
+  </customwidget>
+ </customwidgets>
+ <resources/>
+ <connections/>
+</ui>
diff --git a/debuggers/gdb/ksysguard/ReniceDlg.cpp b/debuggers/gdb/ksysguard/ReniceDlg.cpp
new file mode 100644
index 0000000..d345bf8
--- /dev/null
+++ b/debuggers/gdb/ksysguard/ReniceDlg.cpp
@@ -0,0 +1,192 @@
+/*
+    KSysGuard, the KDE System Guard
+
+	Copyright (c) 1999 Chris Schlaeger <cs@kde.org>
+	Copyright (c) 2007 John Tapsell <tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+
+*/
+
+#include <klocale.h>
+#include <kdebug.h>
+
+#include "ReniceDlg.moc"
+#include <QListWidget>
+#include <QButtonGroup>
+#include "ui_ReniceDlgUi.h"
+#include "process.h"
+
+ReniceDlg::ReniceDlg(QWidget* parent, const QStringList& processes, int currentCpuPrio, int currentCpuSched, int currentIoPrio, int currentIoSched )
+	: KDialog( parent )
+{
+	setObjectName( "Renice Dialog" );
+	setModal( true );
+	setCaption( i18n("Set Priority") );
+	setButtons( Ok | Cancel );
+	previous_cpuscheduler = 0;
+
+	connect( this, SIGNAL(okClicked()), SLOT(slotOk()) );
+
+	if(currentIoSched == KSysGuard::Process::None) {
+		// CurrentIoSched == 0 means that the priority is set automatically.
+		// Using the formula given by the linux kernel Documentation/block/ioprio
+		currentIoPrio = (currentCpuPrio+20)/5;
+	}
+	if(currentIoSched == (int)KSysGuard::Process::BestEffort && currentIoPrio == (currentCpuPrio+20)/5) {
+		// Unfortunately, in linux you can't ever set a process back to being None.  So we fake it :)
+		currentIoSched = KSysGuard::Process::None;
+	}
+	ioniceSupported = (currentIoPrio != -2);
+
+
+	QWidget *widget = new QWidget(this);
+	setMainWidget(widget);
+	ui = new Ui_ReniceDlgUi();
+	ui->setupUi(widget);
+	ui->listWidget->insertItems(0, processes);
+
+	cpuScheduler = new QButtonGroup(this);
+	cpuScheduler->addButton(ui->radioNormal, (int)KSysGuard::Process::Other);
+#ifndef Q_OS_SOLARIS
+	cpuScheduler->addButton(ui->radioBatch, (int)KSysGuard::Process::Batch);
+#else
+	cpuScheduler->addButton(ui->radioBatch, (int)KSysGuard::Process::Interactive);
+    ui->radioBatch->setText( i18nc("Scheduler", "Interactive") );
+#endif
+	cpuScheduler->addButton(ui->radioFIFO, (int)KSysGuard::Process::Fifo);
+	cpuScheduler->addButton(ui->radioRR, (int)KSysGuard::Process::RoundRobin);
+	if(currentCpuSched >= 0) { //negative means none of these
+		QAbstractButton *sched = cpuScheduler->button(currentCpuSched);
+		if(sched) {
+			sched->setChecked(true); //Check the current scheduler
+			previous_cpuscheduler = currentCpuSched;
+		}
+	}
+	cpuScheduler->setExclusive(true);
+
+	ioScheduler = new QButtonGroup(this);
+	ioScheduler->addButton(ui->radioIONormal, (int)KSysGuard::Process::None);
+	ioScheduler->addButton(ui->radioIdle, (int)KSysGuard::Process::Idle);
+	ioScheduler->addButton(ui->radioRealTime, (int)KSysGuard::Process::RealTime);
+	ioScheduler->addButton(ui->radioBestEffort, (int)KSysGuard::Process::BestEffort);
+	if(currentIoSched >= 0) { //negative means none of these
+		QAbstractButton *iosched = ioScheduler->button(currentIoSched);
+		if(iosched)
+		       	iosched->setChecked(true); //Check the current io scheduler
+	}
+
+	ioScheduler->setExclusive(true);
+
+	setSliderRange(); //Update the slider ranges before trying to set their current values
+	if(ioniceSupported)
+		ui->sliderIO->setValue(currentIoPrio);
+	ui->sliderCPU->setValue(currentCpuPrio);
+
+	ui->imgCPU->setPixmap( KIcon("cpu").pixmap(128, 128) );
+	ui->imgIO->setPixmap( KIcon("drive-harddisk").pixmap(128, 128) );
+
+	newCPUPriority = 40;
+
+	connect(cpuScheduler, SIGNAL(buttonClicked(int)), this, SLOT(cpuSchedulerChanged(int)));
+	connect(ioScheduler, SIGNAL(buttonClicked(int)), this, SLOT(updateUi()));
+	connect(ui->sliderCPU, SIGNAL(valueChanged(int)), this, SLOT(cpuSliderChanged(int)));
+	connect(ui->sliderIO, SIGNAL(valueChanged(int)), this, SLOT(ioSliderChanged(int)));
+
+	updateUi();
+}
+
+void ReniceDlg::ioSliderChanged(int value) {
+	ui->sliderIO->setToolTip(QString::number(value));
+}
+
+void ReniceDlg::cpuSchedulerChanged(int value) {
+	if(value != previous_cpuscheduler) {
+		if( (value == (int)KSysGuard::Process::Other || value == KSysGuard::Process::Batch) &&
+		    (previous_cpuscheduler == (int)KSysGuard::Process::Fifo || previous_cpuscheduler == (int)KSysGuard::Process::RoundRobin)) {
+			int slider = -ui->sliderCPU->value() * 2 / 5 + 20;
+			setSliderRange();
+			ui->sliderCPU->setValue( slider );
+		} else if( (previous_cpuscheduler == (int)KSysGuard::Process::Other || previous_cpuscheduler == KSysGuard::Process::Batch) &&
+		    (value == (int)KSysGuard::Process::Fifo || value == (int)KSysGuard::Process::RoundRobin)) {
+			int slider = (-ui->sliderCPU->value() + 20) * 5 / 2;
+			setSliderRange();
+			ui->sliderCPU->setValue( slider );
+		}
+	}
+	previous_cpuscheduler = value;
+	updateUi();
+}
+
+void ReniceDlg::cpuSliderChanged(int value) {
+    if(ioniceSupported) {
+        if(cpuScheduler->checkedId() == (int)KSysGuard::Process::Other || cpuScheduler->checkedId() == (int)KSysGuard::Process::Batch) {
+            if( ioScheduler->checkedId() == -1 || ioScheduler->checkedId() == (int)KSysGuard::Process::None) {
+                //ionice is 'Normal', thus automatically calculated based on cpunice
+                ui->sliderIO->setValue((value+20)/5);
+            }
+        }
+    }
+	ui->sliderCPU->setToolTip(QString::number(value));
+}
+
+void ReniceDlg::updateUi() {
+	bool cpuPrioEnabled = ( cpuScheduler->checkedId() != -1);
+	bool ioPrioEnabled = ( ioniceSupported && ioScheduler->checkedId() != -1 && ioScheduler->checkedId() != (int)KSysGuard::Process::Idle && ioScheduler->checkedId() != (int)KSysGuard::Process::None);
+
+	ui->sliderCPU->setEnabled(cpuPrioEnabled);
+	ui->lblCpuLow->setEnabled(cpuPrioEnabled);
+	ui->lblCpuHigh->setEnabled(cpuPrioEnabled);
+
+	ui->sliderIO->setEnabled(ioPrioEnabled);
+	ui->lblIOLow->setEnabled(ioPrioEnabled);
+	ui->lblIOHigh->setEnabled(ioPrioEnabled);
+
+    ui->radioIONormal->setEnabled(ioniceSupported);
+    ui->radioIdle->setEnabled(ioniceSupported);
+    ui->radioRealTime->setEnabled(ioniceSupported);
+    ui->radioBestEffort->setEnabled(ioniceSupported);
+
+	setSliderRange();
+	cpuSliderChanged(ui->sliderCPU->value());
+	ioSliderChanged(ui->sliderIO->value());
+}
+
+void ReniceDlg::setSliderRange() {
+	if(cpuScheduler->checkedId() == (int)KSysGuard::Process::Other || cpuScheduler->checkedId() == (int)KSysGuard::Process::Batch || cpuScheduler->checkedId() == (int)KSysGuard::Process::Interactive) {
+		//The slider is setting the priority, so goes from 19 to -20.  We cannot actually do this with a slider, so instead we go from -19 to 20, and negate later
+		if(ui->sliderCPU->value() > 20) ui->sliderCPU->setValue(20);
+		ui->sliderCPU->setInvertedAppearance(true);
+		ui->sliderCPU->setMinimum(-19);
+		ui->sliderCPU->setMaximum(20);
+		ui->sliderCPU->setTickInterval(5);
+	} else {
+		if(ui->sliderCPU->value() < 1) ui->sliderCPU->setValue(1);
+		ui->sliderCPU->setInvertedAppearance(false);
+		ui->sliderCPU->setMinimum(1);
+		ui->sliderCPU->setMaximum(99);
+		ui->sliderCPU->setTickInterval(12);
+	}
+}
+
+void ReniceDlg::slotOk()
+{
+	newCPUPriority = ui->sliderCPU->value();
+	newIOPriority = ui->sliderIO->value();
+	newCPUSched = cpuScheduler->checkedId();
+	newIOSched = ioScheduler->checkedId();
+}
diff --git a/debuggers/gdb/ksysguard/ReniceDlg.h b/debuggers/gdb/ksysguard/ReniceDlg.h
new file mode 100644
index 0000000..fa445a5
--- /dev/null
+++ b/debuggers/gdb/ksysguard/ReniceDlg.h
@@ -0,0 +1,67 @@
+/*
+    KSysGuard, the KDE System Guard
+
+    Copyright (c) 2006-2007 John Tapsell <tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef _ReniceDlg_h_
+#define _ReniceDlg_h_
+
+#include <kdialog.h>
+
+class Ui_ReniceDlgUi;
+class QButtonGroup;
+
+/**
+ * This class creates and handles a simple dialog to change the scheduling
+ * priority of a process.
+ */
+class ReniceDlg : public KDialog
+{
+	Q_OBJECT
+
+public:
+	/** Let the user specify the new priorities of the @p processes given, using the given current values.
+	 *  @p currentCpuSched The current Cpu Scheduler of the processes.  Set to -1 to they have different schedulers
+	 *  @p currentIoSched The current I/O Scheduler of the processes.  Set to -1 to they have different schedulers.  Leave as the default -2 if not supported
+	 */
+	ReniceDlg(QWidget* parent, const QStringList& processes, int currentCpuPrio, int currentCpuSched, int currentIoPrio=-2, int currentIoSched=-2);
+	int newCPUPriority;
+	int newIOPriority;
+	int newCPUSched;
+	int newIOSched;
+
+	bool ioniceSupported;
+
+
+public Q_SLOTS:
+	void slotOk();
+	void updateUi();
+	void cpuSliderChanged(int value);
+	void ioSliderChanged(int value);
+	void cpuSchedulerChanged(int value);
+private:
+	void setSliderRange();
+	Ui_ReniceDlgUi *ui;
+	QButtonGroup *cpuScheduler;
+	QButtonGroup *ioScheduler;
+	int previous_cpuscheduler;
+};
+
+#endif
diff --git a/debuggers/gdb/ksysguard/ReniceDlgUi.ui b/debuggers/gdb/ksysguard/ReniceDlgUi.ui
new file mode 100644
index 0000000..456643c
--- /dev/null
+++ b/debuggers/gdb/ksysguard/ReniceDlgUi.ui
@@ -0,0 +1,489 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>ReniceDlgUi</class>
+ <widget class="QWidget" name="ReniceDlgUi">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>652</width>
+    <height>397</height>
+   </rect>
+  </property>
+  <layout class="QVBoxLayout">
+   <property name="spacing">
+    <number>0</number>
+   </property>
+   <property name="margin">
+    <number>0</number>
+   </property>
+   <item>
+    <widget class="QLabel" name="lblMessage1">
+     <property name="text">
+      <string>Change scheduling priority for:</string>
+     </property>
+     <property name="alignment">
+      <set>Qt::AlignVCenter</set>
+     </property>
+     <property name="wordWrap">
+      <bool>true</bool>
+     </property>
+    </widget>
+   </item>
+   <item>
+    <widget class="QListWidget" name="listWidget">
+     <property name="sizePolicy">
+      <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
+       <horstretch>0</horstretch>
+       <verstretch>1</verstretch>
+      </sizepolicy>
+     </property>
+     <property name="contextMenuPolicy">
+      <enum>Qt::NoContextMenu</enum>
+     </property>
+     <property name="selectionMode">
+      <enum>QAbstractItemView::NoSelection</enum>
+     </property>
+     <property name="uniformItemSizes">
+      <bool>true</bool>
+     </property>
+    </widget>
+   </item>
+   <item>
+    <layout class="QGridLayout">
+     <item row="0" column="0">
+      <widget class="QLabel" name="imgCPU">
+       <property name="minimumSize">
+        <size>
+         <width>128</width>
+         <height>128</height>
+        </size>
+       </property>
+       <property name="maximumSize">
+        <size>
+         <width>128</width>
+         <height>128</height>
+        </size>
+       </property>
+       <property name="text">
+        <string/>
+       </property>
+       <property name="textFormat">
+        <enum>Qt::AutoText</enum>
+       </property>
+      </widget>
+     </item>
+     <item row="0" column="1">
+      <layout class="QVBoxLayout">
+       <item>
+        <spacer name="verticalSpacer">
+         <property name="orientation">
+          <enum>Qt::Vertical</enum>
+         </property>
+         <property name="sizeHint" stdset="0">
+          <size>
+           <width>0</width>
+           <height>0</height>
+          </size>
+         </property>
+        </spacer>
+       </item>
+       <item>
+        <widget class="QLabel" name="label">
+         <property name="font">
+          <font>
+           <weight>75</weight>
+           <bold>true</bold>
+          </font>
+         </property>
+         <property name="text">
+          <string>CPU Scheduler</string>
+         </property>
+         <property name="alignment">
+          <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignTop</set>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <spacer name="verticalSpacer_3">
+         <property name="orientation">
+          <enum>Qt::Vertical</enum>
+         </property>
+         <property name="sizeType">
+          <enum>QSizePolicy::Preferred</enum>
+         </property>
+         <property name="sizeHint" stdset="0">
+          <size>
+           <width>0</width>
+           <height>8</height>
+          </size>
+         </property>
+        </spacer>
+       </item>
+       <item>
+        <widget class="QRadioButton" name="radioNormal">
+         <property name="toolTip">
+          <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Sans Serif'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;The standard time-sharing scheduler for processes without special requirements.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+         </property>
+         <property name="whatsThis">
+          <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Sans Serif'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-weight:600;&quot;&gt;Normal Scheduling: Default Linux time-sharing  (Other)&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-weight:600;&quot;&gt;Normal&lt;span style=&quot; font-weight:400;&quot;&gt; is the standard Linux time-sharing scheduler that is intended for all processes that do not  require special static priority real-time mechanisms. The process to run is chosen from the list of other&lt;/span&gt; Normal&lt;span style=&quot; font-weight:400;&quot;&gt; or &lt;/span&gt;Batch&lt;span style=&quot; font-weight:400;&quot;&gt; processes based on a dynamic priority that is determined only inside this list. The dynamic priority is based on the priority level given and increased for each time-quantum the process is ready to run, but denied to run by the scheduler. This ensures fair progress among all Normal processes.&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+         </property>
+         <property name="text">
+          <string>Normal</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QRadioButton" name="radioBatch">
+         <property name="toolTip">
+          <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Sans Serif'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;For CPU-intensive non-interactive processes.  Process is mildly disfavored in scheduling decisions.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+         </property>
+         <property name="whatsThis">
+          <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Sans Serif'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-weight:600;&quot;&gt;Batch Scheduling&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-weight:600;&quot;&gt;&lt;span style=&quot; font-weight:400; font-style:italic;&quot;&gt;(Since Linux 2.6.16.)&lt;/span&gt;&lt;span style=&quot; font-weight:400;&quot;&gt; This policy is similar to &lt;/span&gt;Normal&lt;span style=&quot; font-weight:400;&quot;&gt;, except that this policy will cause the scheduler to always assume that the process is CPU-intensive.  Consequently, the scheduler will apply a small scheduling penalty so that this process is mildly disfavored in scheduling decisions. This policy is useful for workloads that are non-interactive, but do not want to lower their nice value, and for workloads that want a deterministic scheduling policy without interactivity causing extra preemptions (between the workload's tasks).&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+         </property>
+         <property name="text">
+          <string>Batch</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QRadioButton" name="radioRR">
+         <property name="toolTip">
+          <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Sans Serif'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Process will run whenever runnable.  Higher priority than Normal or Batch.  Has Timeslicing.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+         </property>
+         <property name="whatsThis">
+          <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Sans Serif'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-weight:600;&quot;&gt;Round Robin Scheduling&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-weight:600;&quot;&gt;Round Robin&lt;/span&gt; is a simple enhancement of &lt;span style=&quot; font-weight:600;&quot;&gt;FIFO&lt;/span&gt;.  Everything described below for &lt;span style=&quot; font-weight:600;&quot;&gt;FIFO&lt;/span&gt; also applies to &lt;span style=&quot; font-weight:600;&quot;&gt;Round Robin&lt;/span&gt;, except that each process is only allowed to run for a maximum time quantum.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+         </property>
+         <property name="text">
+          <string>Round robin</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QRadioButton" name="radioFIFO">
+         <property name="toolTip">
+          <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Sans Serif'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Process will run whenever runnable.  Higher priority than Normal or Batch.  No timeslicing.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+         </property>
+         <property name="whatsThis">
+          <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Sans Serif'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-weight:600;&quot;&gt;First In-First Out Scheduling&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;When  a  &lt;span style=&quot; font-weight:600;&quot;&gt;FIFO&lt;/span&gt; process  becomes  runnable,  it  will always immediately preempt any currently running &lt;span style=&quot; font-weight:600;&quot;&gt;Normal&lt;/span&gt; or &lt;span style=&quot; font-weight:600;&quot;&gt;Batch&lt;/span&gt; process.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+         </property>
+         <property name="text">
+          <string>FIFO</string>
+         </property>
+        </widget>
+       </item>
+      </layout>
+     </item>
+     <item row="0" column="2">
+      <spacer>
+       <property name="orientation">
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeType">
+        <enum>QSizePolicy::MinimumExpanding</enum>
+       </property>
+       <property name="sizeHint" stdset="0">
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item row="0" column="3">
+      <widget class="QLabel" name="imgIO">
+       <property name="minimumSize">
+        <size>
+         <width>128</width>
+         <height>128</height>
+        </size>
+       </property>
+       <property name="maximumSize">
+        <size>
+         <width>128</width>
+         <height>128</height>
+        </size>
+       </property>
+       <property name="text">
+        <string/>
+       </property>
+      </widget>
+     </item>
+     <item row="0" column="4">
+      <layout class="QVBoxLayout">
+       <item>
+        <spacer name="verticalSpacer_2">
+         <property name="orientation">
+          <enum>Qt::Vertical</enum>
+         </property>
+         <property name="sizeHint" stdset="0">
+          <size>
+           <width>0</width>
+           <height>0</height>
+          </size>
+         </property>
+        </spacer>
+       </item>
+       <item>
+        <widget class="QLabel" name="label_3">
+         <property name="font">
+          <font>
+           <weight>75</weight>
+           <bold>true</bold>
+          </font>
+         </property>
+         <property name="text">
+          <string>I/O Scheduler</string>
+         </property>
+         <property name="alignment">
+          <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignTop</set>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <spacer name="verticalSpacer_4">
+         <property name="orientation">
+          <enum>Qt::Vertical</enum>
+         </property>
+         <property name="sizeType">
+          <enum>QSizePolicy::Preferred</enum>
+         </property>
+         <property name="sizeHint" stdset="0">
+          <size>
+           <width>0</width>
+           <height>8</height>
+          </size>
+         </property>
+        </spacer>
+       </item>
+       <item>
+        <widget class="QRadioButton" name="radioIONormal">
+         <property name="toolTip">
+          <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Sans Serif'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Process's priority is based on the CPU priority.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+         </property>
+         <property name="whatsThis">
+          <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Sans Serif'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-weight:600;&quot;&gt;Normal Scheduling&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;This is the same as &lt;span style=&quot; font-weight:600;&quot;&gt;Best Effort&lt;/span&gt; scheduling, except that the priority is calculated automatically based on the CPU priority.  Processes with a higher priority will take priority for access to the hard disk.  Programs running at the same &lt;span style=&quot; font-weight:600;&quot;&gt;Best Effort/Normal&lt;/span&gt; priority are served in a &lt;span style=&quot; font-weight:600;&quot;&gt;Round Robin&lt;/span&gt; fashion.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+         </property>
+         <property name="text">
+          <string>Normal</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QRadioButton" name="radioIdle">
+         <property name="toolTip">
+          <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Sans Serif'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Process can only use the hard disk when no other process has used it very recently.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+         </property>
+         <property name="whatsThis">
+          <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Sans Serif'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-weight:600;&quot;&gt;Idle Scheduling&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;A  program running with &lt;span style=&quot; font-weight:600;&quot;&gt;Idle&lt;/span&gt; I/O priority will only get disk time when no other program has asked for disk I/O for a defined grace period. The impact of &lt;span style=&quot; font-weight:600;&quot;&gt;Idle&lt;/span&gt; I/O processes on normal system activity should be zero. Priority is not applicable to this scheduling class.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+         </property>
+         <property name="text">
+          <string>Idle</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QRadioButton" name="radioBestEffort">
+         <property name="toolTip">
+          <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Sans Serif'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Process is given higher priority to access the hard disk than Normal.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+         </property>
+         <property name="whatsThis">
+          <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Sans Serif'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-weight:600;&quot;&gt;Best Effort Scheduling&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Processes with a higher priority will take priority for access to the hard disk.  Programs running at the same &lt;span style=&quot; font-weight:600;&quot;&gt;Best Effort/Normal&lt;/span&gt; priority are served in a &lt;span style=&quot; font-weight:600;&quot;&gt;Round Robin&lt;/span&gt; fashion.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+         </property>
+         <property name="text">
+          <string>Best effort</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QRadioButton" name="radioRealTime">
+         <property name="toolTip">
+          <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Sans Serif'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Process gets immediate access to the hard disk whenever needed, regardless of what else is going on.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+         </property>
+         <property name="whatsThis">
+          <string>&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Sans Serif'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-weight:600;&quot;&gt;Real Time Scheduling&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;The &lt;span style=&quot; font-weight:600;&quot;&gt;Real Time&lt;/span&gt; scheduling class is given first access to the disk, regardless of what else is going on in the system. Thus the &lt;span style=&quot; font-weight:600;&quot;&gt;Real Time&lt;/span&gt; class needs to be used with some care, as it can starve other processes. As with the &lt;span style=&quot; font-weight:600;&quot;&gt;Best Effort&lt;/span&gt; class, 8 priority levels are defined denoting how big a time slice a given process will receive on each scheduling window.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+         </property>
+         <property name="text">
+          <string>Real time</string>
+         </property>
+        </widget>
+       </item>
+      </layout>
+     </item>
+     <item row="1" column="0" colspan="2">
+      <layout class="QGridLayout">
+       <item row="0" column="0" colspan="2">
+        <widget class="QSlider" name="sliderCPU">
+         <property name="minimum">
+          <number>-19</number>
+         </property>
+         <property name="maximum">
+          <number>20</number>
+         </property>
+         <property name="value">
+          <number>0</number>
+         </property>
+         <property name="orientation">
+          <enum>Qt::Horizontal</enum>
+         </property>
+         <property name="invertedAppearance">
+          <bool>true</bool>
+         </property>
+         <property name="tickPosition">
+          <enum>QSlider::TicksBelow</enum>
+         </property>
+         <property name="tickInterval">
+          <number>5</number>
+         </property>
+        </widget>
+       </item>
+       <item row="1" column="0">
+        <widget class="QLabel" name="lblCpuLow">
+         <property name="text">
+          <string>Low Priority</string>
+         </property>
+        </widget>
+       </item>
+       <item row="1" column="1">
+        <widget class="QLabel" name="lblCpuHigh">
+         <property name="text">
+          <string>High Priority</string>
+         </property>
+         <property name="alignment">
+          <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+         </property>
+        </widget>
+       </item>
+      </layout>
+     </item>
+     <item row="1" column="2">
+      <spacer>
+       <property name="orientation">
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeType">
+        <enum>QSizePolicy::MinimumExpanding</enum>
+       </property>
+       <property name="sizeHint" stdset="0">
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item row="1" column="3" colspan="2">
+      <layout class="QGridLayout">
+       <item row="0" column="0" colspan="2">
+        <widget class="QSlider" name="sliderIO">
+         <property name="maximum">
+          <number>7</number>
+         </property>
+         <property name="pageStep">
+          <number>1</number>
+         </property>
+         <property name="value">
+          <number>3</number>
+         </property>
+         <property name="sliderPosition">
+          <number>3</number>
+         </property>
+         <property name="orientation">
+          <enum>Qt::Horizontal</enum>
+         </property>
+         <property name="invertedAppearance">
+          <bool>true</bool>
+         </property>
+         <property name="tickPosition">
+          <enum>QSlider::TicksBelow</enum>
+         </property>
+         <property name="tickInterval">
+          <number>1</number>
+         </property>
+        </widget>
+       </item>
+       <item row="1" column="0">
+        <widget class="QLabel" name="lblIOLow">
+         <property name="text">
+          <string>Low Priority</string>
+         </property>
+        </widget>
+       </item>
+       <item row="1" column="1">
+        <widget class="QLabel" name="lblIOHigh">
+         <property name="text">
+          <string>High Priority</string>
+         </property>
+         <property name="alignment">
+          <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+         </property>
+        </widget>
+       </item>
+      </layout>
+     </item>
+    </layout>
+   </item>
+  </layout>
+ </widget>
+ <tabstops>
+  <tabstop>listWidget</tabstop>
+ </tabstops>
+ <resources/>
+ <connections/>
+</ui>
diff --git a/debuggers/gdb/ksysguard/atop_p.h b/debuggers/gdb/ksysguard/atop_p.h
new file mode 100644
index 0000000..b993f9e
--- /dev/null
+++ b/debuggers/gdb/ksysguard/atop_p.h
@@ -0,0 +1,162 @@
+/*
+** This program is free software; you can redistribute it and/or modify it
+** under the terms of the GNU General Public License as published by the
+** Free Software Foundation; either version 2, or (at your option) any
+** later version.
+**
+** This program is distributed in the hope that it will be useful, but
+** WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+** See the GNU General Public License for more details.
+**
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+/*
+** structure which describes the raw file contents
+**
+** layout raw file:    rawheader
+**
+**                     rawrecord                           \
+**                     compressed system-level statistics   | sample 1
+**                     compressed process-level statistics /
+**
+**                     rawrecord                           \
+**                     compressed system-level statistics   | sample 2
+**                     compressed process-level statistics /
+**
+** etcetera .....
+*/
+#define ATOPLOGMAGIC     (unsigned int) 0xfeedbeef
+#define PNAMLEN     15
+#define CMDLEN      68
+
+#include <sys/utsname.h>
+#include <time.h>
+typedef long long   count_t;
+
+/* These structures come from rawlog.c in ATop source */
+
+struct RawHeader {
+    unsigned int    magic;
+
+    unsigned short  aversion;   /* creator atop version with MSB */
+    unsigned short  sstatlen;   /* length of struct sstat        */
+    unsigned short  pstatlen;   /* length of struct pstat        */
+    unsigned short  rawheadlen; /* length of struct rawheader    */
+    unsigned short  rawreclen;  /* length of struct rawrecord    */
+    unsigned short  hertz;      /* clock interrupts per second   */
+    unsigned short  sfuture[5]; /* future use                    */
+    struct utsname  utsname;    /* info about this system        */
+    char        cfuture[8]; /* future use                    */
+
+    unsigned int    pagesize;   /* size of memory page (bytes)   */
+    int     supportflags;   /* used features                 */
+    int     osrel;      /* OS release number             */
+    int     osvers;     /* OS version number             */
+    int     ossub;      /* OS version subnumber          */
+    int     ifuture[6]; /* future use                    */
+};
+
+struct RawRecord {
+    time_t      curtime;    /* current time (epoch)         */
+
+    unsigned short  flags;      /* various flags                */
+    unsigned short  sfuture[3]; /* future use                   */
+
+    unsigned int    scomplen;   /* length of compressed sstat   */
+    unsigned int    pcomplen;   /* length of compressed pstat's */
+    unsigned int    interval;   /* interval (number of seconds) */
+    unsigned int    nlist;      /* number of processes in list  */
+    unsigned int    npresent;   /* total number of processes    */
+    unsigned int    nexit;      /* number of exited processes   */
+    unsigned int    nzombie;    /* number of zombie processes   */
+    unsigned int    ifuture[6]; /* future use                   */
+};
+
+/* 
+** structure containing only relevant process-info extracted 
+** from kernel's process-administration
+*/
+struct PStat {
+    /* GENERAL PROCESS INFO                     */
+    struct gen {
+        int pid;        /* process identification   */
+        int ruid;       /* real user  identification    */
+        int rgid;       /* real group identification    */
+        int ppid;           /* parent process identification*/
+        int nthr;       /* number of threads in tgroup  */
+        char    name[PNAMLEN+1];/* process name string          */
+        char    state;      /* process state ('E' = exited) */
+        int excode;     /* process exit status      */
+        time_t  btime;      /* process start time (epoch)   */
+        char    cmdline[CMDLEN+1];/* command-line string        */
+        int nthrslpi;   /* # threads in state 'S'       */
+        int nthrslpu;   /* # threads in state 'D'       */
+        int nthrrun;    /* # threads in state 'R'       */
+        int ifuture[1];     /* reserved                     */
+    } gen;
+
+    /* CPU STATISTICS                       */
+    struct cpu {
+        count_t utime;      /* time user   text (ticks)     */
+        count_t stime;      /* time system text (ticks)     */
+        int nice;       /* nice value                   */
+        int prio;       /* priority                     */
+        int rtprio;     /* realtime priority            */
+        int policy;     /* scheduling policy            */
+        int curcpu;     /* current processor            */
+        int sleepavg;       /* sleep average percentage     */
+        int ifuture[4]; /* reserved for future use  */
+        count_t cfuture[4]; /* reserved for future use  */
+    } cpu;
+
+    /* DISK STATISTICS                      */
+    struct dsk {
+        count_t rio;        /* number of read requests  */
+        count_t rsz;        /* cumulative # sectors read    */
+        count_t wio;        /* number of write requests     */
+        count_t wsz;        /* cumulative # sectors written */
+        count_t cwsz;       /* cumulative # written sectors */
+                    /* being cancelled              */
+        count_t cfuture[4]; /* reserved for future use  */
+    } dsk;
+
+    /* MEMORY STATISTICS                        */
+    struct mem {
+        count_t minflt;     /* number of page-reclaims  */
+        count_t majflt;     /* number of page-faults    */
+        count_t shtext;     /* text     memory (Kb)         */
+        count_t vmem;       /* virtual  memory (Kb)     */
+        count_t rmem;       /* resident memory (Kb)     */
+        count_t vgrow;      /* virtual  growth (Kb)     */
+        count_t rgrow;      /* resident growth (Kb)         */
+        count_t cfuture[4]; /* reserved for future use  */
+    } mem;
+
+    /* NETWORK STATISTICS                       */
+    struct net {
+        count_t tcpsnd;     /* number of TCP-packets sent   */
+        count_t tcpssz;     /* cumulative size packets sent */
+        count_t tcprcv;     /* number of TCP-packets recved */
+        count_t tcprsz;     /* cumulative size packets rcvd */
+        count_t udpsnd;     /* number of UDP-packets sent   */
+        count_t udpssz;     /* cumulative size packets sent */
+        count_t udprcv;     /* number of UDP-packets recved */
+        count_t udprsz;     /* cumulative size packets sent */
+        count_t rawsnd;     /* number of raw packets sent   */
+        count_t rawrcv;     /* number of raw packets recved */
+        count_t cfuture[4]; /* reserved for future use  */
+    } net;
+};
+
+struct PInfo;
+struct PInfo {
+    PInfo    *phnext;    /* next process in hash    chain */
+    PInfo    *prnext;    /* next process in residue chain */
+    PInfo    *prprev;    /* prev process in residue chain */
+    PStat    pstat;      /* per-process statistics        */
+};
+
+
diff --git a/debuggers/gdb/ksysguard/ksysguardprocesslist.cpp b/debuggers/gdb/ksysguard/ksysguardprocesslist.cpp
new file mode 100644
index 0000000..524fb55
--- /dev/null
+++ b/debuggers/gdb/ksysguard/ksysguardprocesslist.cpp
@@ -0,0 +1,1473 @@
+/*
+    KSysGuard, the KDE System Guard
+
+	Copyright (c) 1999 - 2001 Chris Schlaeger <cs@kde.org>
+	Copyright (c) 2006 - 2007 John Tapsell <john.tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include "ksysguardprocesslist.moc"
+#include "ksysguardprocesslist.h"
+
+#include "config-ksysguard.h"
+
+#include <QApplication>
+#include <QTimer>
+#include <QList>
+#include <QShowEvent>
+#include <QHideEvent>
+#include <QHeaderView>
+#include <QAction>
+#include <QMenu>
+#include <QSet>
+#include <QComboBox>
+#include <QStyle>
+#include <QStyledItemDelegate>
+#include <QPainter>
+#include <QLineEdit>
+#include <QSignalMapper>
+#include <QToolTip>
+#include <QAbstractItemModel>
+#include <QtDBus>
+
+#include <signal.h> //For SIGTERM
+
+#include <kauth.h>
+#include <kaction.h>
+#include <klocale.h>
+#include <kmessagebox.h>
+#include <kdialog.h>
+#include <kicon.h>
+#include <kdebug.h>
+#include <KWindowSystem>
+
+#include "ReniceDlg.h"
+#include "ui_ProcessWidgetUI.h"
+
+#include <sys/types.h>
+#include <unistd.h>
+
+//Trolltech have a testing class for classes that inherit QAbstractItemModel.  If you want to run with this run-time testing enabled, put the modeltest.* files in this directory and uncomment the next line
+//#define DO_MODELCHECK
+#ifdef DO_MODELCHECK
+#include "modeltest.h"
+#endif
+
+class ProgressBarItemDelegate : public QStyledItemDelegate
+{
+    public:
+        ProgressBarItemDelegate(QObject *parent) : QStyledItemDelegate(parent) {
+        }
+
+        virtual void paint(QPainter *painter, const QStyleOptionViewItem &opt, const QModelIndex &index) const
+        {
+            QStyleOptionViewItemV4 option = opt;
+            initStyleOption(&option,index);
+
+            float percentage = index.data(ProcessModel::PercentageRole).toFloat();
+            if (percentage >= 0)
+                drawPercentageDisplay(painter,option, percentage);
+            else
+                QStyledItemDelegate::paint(painter, option, index);
+        }
+
+    private:
+        inline void drawPercentageDisplay(QPainter *painter, QStyleOptionViewItemV4 &option, float percentage) const
+        {
+            QStyle *style = option.widget ? option.widget->style() : QApplication::style();
+
+            // draw the background
+            style->drawPrimitive(QStyle::PE_PanelItemViewItem, &option, painter, option.widget);
+
+            QPalette::ColorGroup cg = option.state & QStyle::State_Enabled
+                ? QPalette::Normal : QPalette::Disabled;
+            if (cg == QPalette::Normal && !(option.state & QStyle::State_Active))
+                cg = QPalette::Inactive;
+
+            //Now draw our percentage thingy
+            const QRect &rect = option.rect;
+            int size = qMin(percentage,1.0f) * rect.width();
+            if(size > 2 ) { //make sure the line will have a width of more than 1 pixel
+                painter->setPen(Qt::NoPen);
+                QColor color = option.palette.color(cg, QPalette::Link);
+                color.setAlpha(50);
+
+                painter->fillRect( rect.x(), rect.y(), size, rect.height(), color);
+            }
+
+            // draw the text
+            if (!option.text.isEmpty()) {
+                QRect textRect = style->subElementRect(QStyle::SE_ItemViewItemText, &option, option.widget);
+
+
+                if (option.state & QStyle::State_Selected) {
+                    painter->setPen(option.palette.color(cg, QPalette::HighlightedText));
+                } else {
+                    painter->setPen(option.palette.color(cg, QPalette::Text));
+                }
+
+                painter->setFont(option.font);
+                QTextOption textOption;
+                textOption.setWrapMode(QTextOption::ManualWrap);
+                textOption.setTextDirection(option.direction);
+                textOption.setAlignment(QStyle::visualAlignment(option.direction, option.displayAlignment));
+
+                painter->drawText(textRect, option.text, textOption);
+            }
+
+            // draw the focus rect
+             if (option.state & QStyle::State_HasFocus) {
+                QStyleOptionFocusRect o;
+                o.QStyleOption::operator=(option);
+                o.rect = style->subElementRect(QStyle::SE_ItemViewItemFocusRect, &option, option.widget);
+                o.state |= QStyle::State_KeyboardFocusChange;
+                o.state |= QStyle::State_Item;
+                QPalette::ColorGroup cg = (option.state & QStyle::State_Enabled)
+                              ? QPalette::Normal : QPalette::Disabled;
+                o.backgroundColor = option.palette.color(cg, (option.state & QStyle::State_Selected)
+                                             ? QPalette::Highlight : QPalette::Window);
+                style->drawPrimitive(QStyle::PE_FrameFocusRect, &o, painter, option.widget);
+            }
+        }
+};
+
+struct KSysGuardProcessListPrivate {
+
+    KSysGuardProcessListPrivate(KSysGuardProcessList* q, const QString &hostName)
+        : mModel(q, hostName), mFilterModel(q), mUi(new Ui::ProcessWidget()), mProcessContextMenu(NULL), mUpdateTimer(NULL)
+    {
+        mNeedToExpandInit = false;
+        mNumItemsSelected = -1;
+        mResortCountDown = 2; //The items added initially will be already sorted, but without CPU info.  On the second refresh we will have CPU usage, so /then/ we can resort
+        renice = new KAction(i18np("Set Priority...", "Set Priority...", 1), q);
+        renice->setShortcut(Qt::Key_F8);
+        selectParent = new KAction(i18n("Jump to Parent Process"), q);
+
+        selectTracer = new KAction(i18n("Jump to Process Debugging This One"), q);
+        window = new KAction(i18n("Show Application Window"), q);
+        resume = new KAction(i18n("Resume Stopped Process"), q);
+        terminate = new KAction(i18np("End Process", "End Processes", 1), q);
+        terminate->setIcon(KIcon("process-stop"));
+        terminate->setShortcut(Qt::Key_Delete);
+        kill = new KAction(i18np("Forcibly Kill Process", "Forcibly Kill Processes", 1), q);
+        kill->setIcon(KIcon("process-stop"));
+        kill->setShortcut(Qt::SHIFT + Qt::Key_Delete);
+
+        sigStop = new KAction(i18n("Suspend (STOP)"), q);
+        sigCont = new KAction(i18n("Continue (CONT)"), q);
+        sigHup = new KAction(i18n("Hangup (HUP)"), q);
+        sigInt = new KAction(i18n("Interrupt (INT)"), q);
+        sigTerm = new KAction(i18n("Terminate (TERM)"), q);
+        sigKill = new KAction(i18n("Kill (KILL)"), q);
+        sigUsr1 = new KAction(i18n("User 1 (USR1)"), q);
+        sigUsr2 = new KAction(i18n("User 2 (USR2)"), q);
+
+        //Set up '/' as a shortcut to jump to the quick search text widget
+        jumpToSearchFilter = new KAction(i18n("Focus on Quick Search"), q);
+        jumpToSearchFilter->setShortcuts(QList<QKeySequence>() << QKeySequence::Find << '/');
+    }
+
+    ~KSysGuardProcessListPrivate() { delete mUi; mUi = NULL; }
+
+    /** The number rows and their children for the given parent in the mFilterModel model */
+    int totalRowCount(const QModelIndex &parent) const;
+
+    /** Helper function to setup 'action' with the given pids */
+    void setupKAuthAction(KAuth::Action *action, const QList<long long> & pids) const;
+
+    /** fire a timer event if we are set to use our internal timer*/
+    void fireTimerEvent();
+
+    /** The process model.  This contains all the data on all the processes running on the system */
+    ProcessModel mModel;
+
+    /** The process filter.  The mModel is connected to this, and this filter model connects to the view.  This lets us
+     *  sort the view and filter (by using the combo box or the search line)
+     */
+    ProcessFilter mFilterModel;
+
+    /** The graphical user interface for this process list widget, auto-generated by Qt Designer */
+    Ui::ProcessWidget *mUi;
+
+    /** The context menu when you right click on a process */
+    QMenu *mProcessContextMenu;
+
+    /** A timer to call updateList() every mUpdateIntervalMSecs.
+     *  NULL is mUpdateIntervalMSecs is <= 0. */
+    QTimer *mUpdateTimer;
+
+    /** The time to wait, in milliseconds, between updating the process list */
+    int mUpdateIntervalMSecs;
+
+    /** Number of items that are selected */
+    int mNumItemsSelected;
+
+    /** A counter to mark when to resort, so that we do not resort on every update */
+    int mResortCountDown;
+
+    bool mNeedToExpandInit;
+
+    KAction *renice;
+    KAction *terminate;
+    KAction *kill;
+    KAction *selectParent;
+    KAction *selectTracer;
+    KAction *jumpToSearchFilter;
+    KAction *window;
+    KAction *resume;
+    KAction *sigStop;
+    KAction *sigCont;
+    KAction *sigHup;
+    KAction *sigInt;
+    KAction *sigTerm;
+    KAction *sigKill;
+    KAction *sigUsr1;
+    KAction *sigUsr2;
+};
+
+KSysGuardProcessList::KSysGuardProcessList(QWidget* parent, const QString &hostName)
+    : QWidget(parent), d(new KSysGuardProcessListPrivate(this, hostName))
+{
+    qRegisterMetaType<QList<long long> >();
+    qDBusRegisterMetaType<QList<long long> >();
+
+    d->mUpdateIntervalMSecs = 0; //Set process to not update manually by default
+    d->mUi->setupUi(this);
+    d->mFilterModel.setSourceModel(&d->mModel);
+    d->mUi->treeView->setModel(&d->mFilterModel);
+#ifdef DO_MODELCHECK
+    new ModelTest(&d->mModel, this);
+#endif
+    d->mUi->treeView->setItemDelegate(new ProgressBarItemDelegate(d->mUi->treeView));
+
+    d->mUi->treeView->header()->setContextMenuPolicy(Qt::CustomContextMenu);
+    connect(d->mUi->treeView->header(), SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(showColumnContextMenu(QPoint)));
+
+    d->mProcessContextMenu = new QMenu(d->mUi->treeView);
+    d->mUi->treeView->setContextMenuPolicy(Qt::CustomContextMenu);
+    connect(d->mUi->treeView, SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(showProcessContextMenu(QPoint)));
+
+    d->mUi->treeView->header()->setClickable(true);
+    d->mUi->treeView->header()->setSortIndicatorShown(true);
+    d->mUi->treeView->header()->setCascadingSectionResizes(false);
+    connect(d->mUi->btnKillProcess, SIGNAL(clicked()), this, SLOT(killSelectedProcesses()));
+    connect(d->mUi->txtFilter, SIGNAL(textChanged(QString)), this, SLOT(filterTextChanged(QString)));
+    connect(d->mUi->cmbFilter, SIGNAL(currentIndexChanged(int)), this, SLOT(setStateInt(int)));
+    connect(d->mUi->treeView, SIGNAL(expanded(QModelIndex)), this, SLOT(expandAllChildren(QModelIndex)));
+    connect(d->mUi->treeView->selectionModel(), SIGNAL(selectionChanged(QItemSelection,QItemSelection)), this, SLOT(selectionChanged()));
+    connect(&d->mFilterModel, SIGNAL(rowsInserted(QModelIndex,int,int)), this, SLOT(rowsInserted(QModelIndex,int,int)));
+    connect(&d->mFilterModel, SIGNAL(rowsRemoved(QModelIndex,int,int)), this, SIGNAL(processListChanged()));
+    setMinimumSize(sizeHint());
+
+    d->mFilterModel.setFilterKeyColumn(-1);
+
+    /*  Hide various columns by default, to reduce information overload */
+    d->mUi->treeView->header()->hideSection(ProcessModel::HeadingVmSize);
+    d->mUi->treeView->header()->hideSection(ProcessModel::HeadingNiceness);
+    d->mUi->treeView->header()->hideSection(ProcessModel::HeadingTty);
+    d->mUi->treeView->header()->hideSection(ProcessModel::HeadingCommand);
+    d->mUi->treeView->header()->hideSection(ProcessModel::HeadingPid);
+    d->mUi->treeView->header()->hideSection(ProcessModel::HeadingCPUTime);
+    d->mUi->treeView->header()->hideSection(ProcessModel::HeadingIoRead);
+    d->mUi->treeView->header()->hideSection(ProcessModel::HeadingIoWrite);
+    d->mUi->treeView->header()->hideSection(ProcessModel::HeadingXMemory);
+    // NOTE!  After this is all setup, the settings for the header are restored
+    // from the user's last run.  (in restoreHeaderState)
+    // So making changes here only affects the default settings.  To
+    // test changes temporarily, comment out the lines in restoreHeaderState.
+    // When you are happy with the changes and want to commit, increase the
+    // value of PROCESSHEADERVERSION.  This will force the header state
+    // to be reset back to the defaults for all users.
+    d->mUi->treeView->header()->resizeSection(ProcessModel::HeadingCPUUsage, d->mUi->treeView->header()->sectionSizeHint(ProcessModel::HeadingCPUUsage));
+    d->mUi->treeView->header()->resizeSection(ProcessModel::HeadingMemory, d->mUi->treeView->header()->sectionSizeHint(ProcessModel::HeadingMemory));
+    d->mUi->treeView->header()->resizeSection(ProcessModel::HeadingSharedMemory, d->mUi->treeView->header()->sectionSizeHint(ProcessModel::HeadingSharedMemory));
+    d->mUi->treeView->header()->setResizeMode(0, QHeaderView::Interactive);
+    d->mUi->treeView->header()->setStretchLastSection(true);
+
+    //Process names can have mixed case. Make the filter case insensitive.
+    d->mFilterModel.setFilterCaseSensitivity(Qt::CaseInsensitive);
+    d->mFilterModel.setSortCaseSensitivity(Qt::CaseInsensitive);
+
+    d->mUi->txtFilter->installEventFilter(this);
+    d->mUi->treeView->installEventFilter(this);
+
+    d->mUi->treeView->setDragEnabled(true);
+    d->mUi->treeView->setDragDropMode(QAbstractItemView::DragOnly);
+
+
+    //Sort by username by default
+    d->mUi->treeView->sortByColumn(ProcessModel::HeadingUser, Qt::AscendingOrder);
+
+    // Add all the actions to the main widget, and get all the actions to call actionTriggered when clicked
+    QSignalMapper *signalMapper = new QSignalMapper(this);
+    QList<QAction *> actions;
+    actions << d->renice << d->kill << d->terminate << d->selectParent << d->selectTracer << d->window << d->jumpToSearchFilter;
+    actions << d->resume << d->sigStop << d->sigCont << d->sigHup << d->sigInt << d->sigTerm << d->sigKill << d->sigUsr1 << d->sigUsr2;
+
+    foreach(QAction *action, actions) {
+        addAction(action);
+        connect(action, SIGNAL(triggered(bool)), signalMapper, SLOT(map()));
+        signalMapper->setMapping(action, action);
+    }
+    connect(signalMapper, SIGNAL(mapped(QObject*)), SLOT(actionTriggered(QObject*)));
+
+    retranslateUi();
+
+    d->mUi->btnKillProcess->setIcon(KIcon("process-stop"));
+    d->mUi->btnKillProcess->setToolTip(i18n("<qt>End the selected process. Warning - you may lose unsaved work.<br>Right click on a process to send other signals.<br>See What's This for technical information.<br>To target a specific window to kill, press Ctrl+Alt+Esc at any time."));
+}
+
+KSysGuardProcessList::~KSysGuardProcessList()
+{
+    delete d;
+}
+
+QTreeView *KSysGuardProcessList::treeView() const {
+    return d->mUi->treeView;
+}
+
+QLineEdit *KSysGuardProcessList::filterLineEdit() const {
+    return d->mUi->txtFilter;
+}
+
+ProcessFilter::State KSysGuardProcessList::state() const
+{
+    return d->mFilterModel.filter();
+}
+void KSysGuardProcessList::setStateInt(int state) {
+    setState((ProcessFilter::State) state);
+    d->mUi->treeView->scrollTo( d->mUi->treeView->currentIndex());
+}
+void KSysGuardProcessList::setState(ProcessFilter::State state)
+{  //index is the item the user selected in the combo box
+    d->mFilterModel.setFilter(state);
+    d->mModel.setSimpleMode( (state != ProcessFilter::AllProcessesInTreeForm) );
+    d->mUi->cmbFilter->setCurrentIndex( (int)state);
+    if(isVisible())
+        expandInit();
+}
+void KSysGuardProcessList::filterTextChanged(const QString &newText) {
+    d->mFilterModel.setFilterRegExp(newText.trimmed());
+    if(isVisible())
+        expandInit();
+    d->mUi->btnKillProcess->setEnabled( d->mUi->treeView->selectionModel()->hasSelection() );
+    d->mUi->treeView->scrollTo( d->mUi->treeView->currentIndex());
+}
+
+int KSysGuardProcessList::visibleProcessesCount() const  {
+    //This assumes that all the visible rows are processes.  This is true currently, but might not be
+    //true if we add support for showing threads etc
+    if(d->mModel.isSimpleMode())
+        return d->mFilterModel.rowCount();
+    return d->totalRowCount(QModelIndex());
+}
+
+int KSysGuardProcessListPrivate::totalRowCount(const QModelIndex &parent ) const {
+    int numRows = mFilterModel.rowCount(parent);
+    int total = numRows;
+    for (int i = 0; i < numRows; ++i) {
+        QModelIndex index = mFilterModel.index(i, 0,parent);
+        //if it has children add the total
+        if (mFilterModel.hasChildren(index))
+            total += totalRowCount(index);
+    }
+    return total;
+}
+
+void KSysGuardProcessListPrivate::setupKAuthAction(KAuth::Action *action, const QList<long long> & pids) const
+{
+    action->setHelperID("org.kde.ksysguard.processlisthelper");
+
+    int processCount = pids.count();
+    for(int i = 0; i < processCount; i++) {
+        action->addArgument(QString("pid%1").arg(i), pids[i]);
+    }
+    action->addArgument("pidcount", processCount);
+}
+void KSysGuardProcessList::selectionChanged()
+{
+    int numSelected =  d->mUi->treeView->selectionModel()->selectedRows().size();
+    if(numSelected == d->mNumItemsSelected)
+        return;
+    d->mNumItemsSelected = numSelected;
+    d->mUi->btnKillProcess->setEnabled( numSelected != 0 );
+
+    d->renice->setText(i18np("Set Priority...", "Set Priority...", numSelected));
+    d->kill->setText(i18np("Forcibly Kill Process", "Forcibly Kill Processes", numSelected));
+    d->terminate->setText(i18ncp("Context menu", "End Process", "End Processes", numSelected));
+}
+void KSysGuardProcessList::showProcessContextMenu(const QModelIndex &index) {
+    if(!index.isValid()) return;
+    QRect rect = d->mUi->treeView->visualRect(index);
+    QPoint point(rect.x() + rect.width()/4, rect.y() + rect.height()/2 );
+    showProcessContextMenu(point);
+}
+void KSysGuardProcessList::showProcessContextMenu(const QPoint &point) {
+    d->mProcessContextMenu->clear();
+
+    QModelIndexList selectedIndexes = d->mUi->treeView->selectionModel()->selectedRows();
+    int numProcesses = selectedIndexes.size();
+
+    if(numProcesses == 0) {
+        //No processes selected, so no process context menu
+
+        //Check just incase we have no columns visible.  In which case show the column context menu
+        //so that users can unhide columns if there are no columns visible
+        for(int i = 0; i < d->mFilterModel.columnCount(); ++i) {
+            if(!d->mUi->treeView->header()->isSectionHidden(i))
+                return;
+        }
+        showColumnContextMenu(point);
+        return;
+    }
+
+    QModelIndex realIndex = d->mFilterModel.mapToSource(selectedIndexes.at(0));
+    KSysGuard::Process *process = reinterpret_cast<KSysGuard::Process *> (realIndex.internalPointer());
+
+
+
+    //If the selected process is a zombie, do not bother offering renice and kill options
+    bool showSignalingEntries = numProcesses != 1 || process->status != KSysGuard::Process::Zombie;
+    if(showSignalingEntries) {
+        d->mProcessContextMenu->addAction(d->renice);
+        QMenu *signalMenu = d->mProcessContextMenu->addMenu(i18n("Send Signal"));
+        signalMenu->addAction(d->sigStop);
+        signalMenu->addAction(d->sigCont);
+        signalMenu->addAction(d->sigHup);
+        signalMenu->addAction(d->sigInt);
+        signalMenu->addAction(d->sigTerm);
+        signalMenu->addAction(d->sigKill);
+        signalMenu->addAction(d->sigUsr1);
+        signalMenu->addAction(d->sigUsr2);
+    }
+
+    if(numProcesses == 1 && process->parent_pid > 1) {
+        //As a design decision, I do not show the 'Jump to parent process' option when the
+        //parent is just 'init'.
+
+        KSysGuard::Process *parent_process = d->mModel.getProcess(process->parent_pid);
+        if(parent_process) { //it should not be possible for this process to not exist, but check just incase
+            QString parent_name = parent_process->name;
+            if(parent_name.size() > 20) //Elide the text if it is too long
+                parent_name = parent_process->name.left(15) + QString::fromUtf8("…");
+            d->selectParent->setText(i18n("Jump to Parent Process (%1)", parent_name));
+            d->mProcessContextMenu->addAction(d->selectParent);
+        }
+    }
+
+    if(numProcesses == 1 && process->tracerpid >= 0) {
+        //If the process is being debugged, offer to select it
+        d->mProcessContextMenu->addAction(d->selectTracer);
+    }
+
+    if (numProcesses == 1 && !d->mModel.data(realIndex, ProcessModel::WindowIdRole).isNull()) {
+        d->mProcessContextMenu->addAction(d->window);
+    }
+
+    if(numProcesses == 1 && process->status == KSysGuard::Process::Stopped) {
+        //If the process is stopped, offer to resume it
+        d->mProcessContextMenu->addAction(d->resume);
+    }
+
+    if (showSignalingEntries) {
+        d->mProcessContextMenu->addSeparator();
+        d->mProcessContextMenu->addAction(d->terminate);
+        if (numProcesses == 1 && !process->timeKillWasSent.isNull())
+            d->mProcessContextMenu->addAction(d->kill);
+    }
+
+    d->mProcessContextMenu->popup(d->mUi->treeView->viewport()->mapToGlobal(point));
+}
+void KSysGuardProcessList::actionTriggered(QObject *object) {
+    if(!isVisible()) //Ignore triggered actions if we are not visible!
+        return;
+    //Reset the text back to normal
+    d->selectParent->setText(i18n("Jump to Parent Process"));
+    QAction *result = qobject_cast<QAction *>(object);
+    if(result == 0) {
+        //Escape was pressed. Do nothing.
+    } else if(result == d->renice) {
+        reniceSelectedProcesses();
+    } else if(result == d->terminate) {
+        sendSignalToSelectedProcesses(SIGTERM, true);
+    } else if(result == d->kill) {
+        sendSignalToSelectedProcesses(SIGKILL, true);
+    } else if(result == d->selectParent) {
+        QModelIndexList selectedIndexes = d->mUi->treeView->selectionModel()->selectedRows();
+        int numProcesses = selectedIndexes.size();
+        if(numProcesses == 0) return;  //No processes selected
+        QModelIndex realIndex = d->mFilterModel.mapToSource(selectedIndexes.at(0));
+        KSysGuard::Process *process = reinterpret_cast<KSysGuard::Process *> (realIndex.internalPointer());
+        if(process)
+            selectAndJumpToProcess(process->parent_pid);
+    } else if(result == d->selectTracer) {
+        QModelIndexList selectedIndexes = d->mUi->treeView->selectionModel()->selectedRows();
+        int numProcesses = selectedIndexes.size();
+        if(numProcesses == 0) return;  //No processes selected
+        QModelIndex realIndex = d->mFilterModel.mapToSource(selectedIndexes.at(0));
+        KSysGuard::Process *process = reinterpret_cast<KSysGuard::Process *> (realIndex.internalPointer());
+        if(process)
+            selectAndJumpToProcess(process->tracerpid);
+    } else if(result == d->window) {
+        QModelIndexList selectedIndexes = d->mUi->treeView->selectionModel()->selectedRows();
+        int numProcesses = selectedIndexes.size();
+        if(numProcesses == 0) return;  //No processes selected
+        foreach( const QModelIndex &index, selectedIndexes) {
+            QModelIndex realIndex = d->mFilterModel.mapToSource(index);
+            QVariant widVar= d->mModel.data(realIndex, ProcessModel::WindowIdRole);
+            if( !widVar.isNull() ) {
+                int wid = widVar.toInt();
+                KWindowSystem::activateWindow(wid);
+            }
+        }
+    } else if(result == d->jumpToSearchFilter) {
+        d->mUi->txtFilter->setFocus();
+    } else {
+        int sig;
+        if(result == d->resume || result == d->sigCont)
+            sig = SIGCONT;  //Despite the function name, this sends a signal, rather than kill it.  Silly unix :)
+        else if(result == d->sigStop)
+            sig = SIGSTOP;
+        else if(result == d->sigHup)
+            sig = SIGHUP;
+        else if(result == d->sigInt)
+            sig = SIGINT;
+        else if(result == d->sigTerm)
+            sig = SIGTERM;
+        else if(result == d->sigKill)
+            sig = SIGKILL;
+        else if(result == d->sigUsr1)
+            sig = SIGUSR1;
+        else if(result == d->sigUsr2)
+            sig = SIGUSR2;
+        else
+            return;
+        sendSignalToSelectedProcesses(sig, false);
+    }
+}
+
+void KSysGuardProcessList::selectAndJumpToProcess(int pid) {
+    KSysGuard::Process *process = d->mModel.getProcess(pid);
+    if(!process) return;
+    QModelIndex sourceIndex = d->mModel.getQModelIndex(process, 0);
+    QModelIndex filterIndex = d->mFilterModel.mapFromSource( sourceIndex );
+    if(!filterIndex.isValid() && !d->mUi->txtFilter->text().isEmpty()) {
+        //The filter is preventing us from finding the parent.  Clear the filter
+        //(It could also be the combo box - should we deal with that case as well?)
+        d->mUi->txtFilter->clear();
+        filterIndex = d->mFilterModel.mapFromSource( sourceIndex );
+    }
+    d->mUi->treeView->clearSelection();
+    d->mUi->treeView->setCurrentIndex(filterIndex);
+    d->mUi->treeView->scrollTo( filterIndex, QAbstractItemView::PositionAtCenter);
+
+}
+
+void KSysGuardProcessList::showColumnContextMenu(const QPoint &point){
+    QMenu menu;
+
+    QAction *action;
+
+    int num_headings = d->mFilterModel.columnCount();
+
+    int index = d->mUi->treeView->header()->logicalIndexAt(point);
+    if(index >= 0) {
+        bool anyOtherVisibleColumns = false;
+        for(int i = 0; i < num_headings; ++i) {
+            if(i != index && !d->mUi->treeView->header()->isSectionHidden(i)) {
+                anyOtherVisibleColumns = true;
+                break;
+            }
+        }
+        if(anyOtherVisibleColumns) {
+            //selected a column.  Give the option to hide it
+            action = new QAction(&menu);
+            action->setData(-index-1); //We set data to be negative (and minus 1) to hide a column, and positive to show a column
+            action->setText(i18n("Hide Column '%1'", d->mFilterModel.headerData(index, Qt::Horizontal, Qt::DisplayRole).toString()));
+            menu.addAction(action);
+            if(d->mUi->treeView->header()->sectionsHidden()) {
+                menu.addSeparator();
+            }
+        }
+    }
+
+    if(d->mUi->treeView->header()->sectionsHidden()) {
+        for(int i = 0; i < num_headings; ++i) {
+            if(d->mUi->treeView->header()->isSectionHidden(i)) {
+#ifndef HAVE_XRES
+                if(i == ProcessModel::HeadingXMemory)
+                    continue;
+#endif
+                action = new QAction(&menu);
+                action->setText(i18n("Show Column '%1'", d->mFilterModel.headerData(i, Qt::Horizontal, Qt::DisplayRole).toString()));
+                action->setData(i); //We set data to be negative (and minus 1) to hide a column, and positive to show a column
+                menu.addAction(action);
+            }
+        }
+    }
+    QAction *actionAuto = NULL;
+    QAction *actionKB = NULL;
+    QAction *actionMB = NULL;
+    QAction *actionGB = NULL;
+    QAction *actionPercentage = NULL;
+    QAction *actionShowCmdlineOptions = NULL;
+    QAction *actionShowTooltips = NULL;
+    QAction *actionNormalizeCPUUsage = NULL;
+
+    QAction *actionIoCharacters = NULL;
+    QAction *actionIoSyscalls = NULL;
+    QAction *actionIoActualCharacters = NULL;
+    QAction *actionIoShowRate = NULL;
+    bool showIoRate = false;
+    if(index == ProcessModel::HeadingIoRead || index == ProcessModel::HeadingIoWrite)
+        showIoRate = d->mModel.ioInformation() == ProcessModel::BytesRate ||
+                     d->mModel.ioInformation() == ProcessModel::SyscallsRate ||
+                     d->mModel.ioInformation() == ProcessModel::ActualBytesRate;
+
+    if( index == ProcessModel::HeadingVmSize || index == ProcessModel::HeadingMemory || index == ProcessModel::HeadingXMemory || index == ProcessModel::HeadingSharedMemory || ( (index == ProcessModel::HeadingIoRead || index == ProcessModel::HeadingIoWrite) && d->mModel.ioInformation() != ProcessModel::Syscalls)) {
+        //If the user right clicks on a column that contains a memory size, show a toggle option for displaying
+        //the memory in different units.  e.g.  "2000 k" or "2 m"
+        menu.addSeparator()->setText(i18n("Display Units"));
+        QActionGroup *unitsGroup = new QActionGroup(&menu);
+        /* Automatic (human readable)*/
+        actionAuto = new QAction(&menu);
+        actionAuto->setText(i18n("Mixed"));
+        actionAuto->setCheckable(true);
+        menu.addAction(actionAuto);
+        unitsGroup->addAction(actionAuto);
+        /* Kilobytes */
+        actionKB = new QAction(&menu);
+        actionKB->setText((showIoRate)?i18n("Kilobytes per second"):i18n("Kilobytes"));
+        actionKB->setCheckable(true);
+        menu.addAction(actionKB);
+        unitsGroup->addAction(actionKB);
+        /* Megabytes */
+        actionMB = new QAction(&menu);
+        actionMB->setText((showIoRate)?i18n("Megabytes per second"):i18n("Megabytes"));
+        actionMB->setCheckable(true);
+        menu.addAction(actionMB);
+        unitsGroup->addAction(actionMB);
+        /* Gigabytes */
+        actionGB = new QAction(&menu);
+        actionGB->setText((showIoRate)?i18n("Gigabytes per second"):i18n("Gigabytes"));
+        actionGB->setCheckable(true);
+        menu.addAction(actionGB);
+        unitsGroup->addAction(actionGB);
+        ProcessModel::Units currentUnit;
+        if(index == ProcessModel::HeadingIoRead || index == ProcessModel::HeadingIoWrite) {
+            currentUnit = d->mModel.ioUnits();
+        } else {
+            actionPercentage = new QAction(&menu);
+            actionPercentage->setText(i18n("Percentage"));
+            actionPercentage->setCheckable(true);
+            menu.addAction(actionPercentage);
+            unitsGroup->addAction(actionPercentage);
+            currentUnit = d->mModel.units();
+        }
+        switch(currentUnit) {
+            case ProcessModel::UnitsAuto:
+                actionAuto->setChecked(true);
+                break;
+            case ProcessModel::UnitsKB:
+                actionKB->setChecked(true);
+                break;
+            case ProcessModel::UnitsMB:
+                actionMB->setChecked(true);
+                break;
+            case ProcessModel::UnitsGB:
+                actionGB->setChecked(true);
+                break;
+            case ProcessModel::UnitsPercentage:
+                actionPercentage->setChecked(true);
+                break;
+            default:
+                break;
+        }
+        unitsGroup->setExclusive(true);
+    } else if(index == ProcessModel::HeadingName) {
+        menu.addSeparator();
+        actionShowCmdlineOptions = new QAction(&menu);
+        actionShowCmdlineOptions->setText(i18n("Display command line options"));
+        actionShowCmdlineOptions->setCheckable(true);
+        actionShowCmdlineOptions->setChecked(d->mModel.isShowCommandLineOptions());
+        menu.addAction(actionShowCmdlineOptions);
+    } else if(index == ProcessModel::HeadingCPUUsage) {
+        menu.addSeparator();
+        actionNormalizeCPUUsage = new QAction(&menu);
+        actionNormalizeCPUUsage->setText(i18n("Divide CPU usage by number of CPUs"));
+        actionNormalizeCPUUsage->setCheckable(true);
+        actionNormalizeCPUUsage->setChecked(d->mModel.isNormalizedCPUUsage());
+        menu.addAction(actionNormalizeCPUUsage);
+    }
+
+    if(index == ProcessModel::HeadingIoRead || index == ProcessModel::HeadingIoWrite) {
+        menu.addSeparator()->setText(i18n("Displayed Information"));
+        QActionGroup *ioInformationGroup = new QActionGroup(&menu);
+        actionIoCharacters = new QAction(&menu);
+        actionIoCharacters->setText(i18n("Characters read/written"));
+        actionIoCharacters->setCheckable(true);
+        menu.addAction(actionIoCharacters);
+        ioInformationGroup->addAction(actionIoCharacters);
+        actionIoSyscalls = new QAction(&menu);
+        actionIoSyscalls->setText(i18n("Number of Read/Write operations"));
+        actionIoSyscalls->setCheckable(true);
+        menu.addAction(actionIoSyscalls);
+        ioInformationGroup->addAction(actionIoSyscalls);
+        actionIoActualCharacters = new QAction(&menu);
+        actionIoActualCharacters->setText(i18n("Bytes actually read/written"));
+        actionIoActualCharacters->setCheckable(true);
+        menu.addAction(actionIoActualCharacters);
+        ioInformationGroup->addAction(actionIoActualCharacters);
+
+        actionIoShowRate = new QAction(&menu);
+        actionIoShowRate->setText(i18n("Show I/O rate"));
+        actionIoShowRate->setCheckable(true);
+        actionIoShowRate->setChecked(showIoRate);
+        menu.addAction(actionIoShowRate);
+
+        switch(d->mModel.ioInformation()) {
+            case ProcessModel::Bytes:
+            case ProcessModel::BytesRate:
+                actionIoCharacters->setChecked(true);
+                break;
+            case ProcessModel::Syscalls:
+            case ProcessModel::SyscallsRate:
+                actionIoSyscalls->setChecked(true);
+                break;
+            case ProcessModel::ActualBytes:
+            case ProcessModel::ActualBytesRate:
+                actionIoActualCharacters->setChecked(true);
+                break;
+            default:
+                break;
+        }
+    }
+
+    menu.addSeparator();
+    actionShowTooltips = new QAction(&menu);
+    actionShowTooltips->setCheckable(true);
+    actionShowTooltips->setChecked(d->mModel.isShowingTooltips());
+    actionShowTooltips->setText(i18n("Show Tooltips"));
+    menu.addAction(actionShowTooltips);
+
+
+    QAction *result = menu.exec(d->mUi->treeView->header()->mapToGlobal(point));
+    if(!result) return; //Menu cancelled
+    if(result == actionAuto) {
+        if(index == ProcessModel::HeadingIoRead || index == ProcessModel::HeadingIoWrite)
+            d->mModel.setIoUnits(ProcessModel::UnitsAuto);
+        else
+            d->mModel.setUnits(ProcessModel::UnitsAuto);
+        return;
+    } else if(result == actionKB) {
+        if(index == ProcessModel::HeadingIoRead || index == ProcessModel::HeadingIoWrite)
+            d->mModel.setIoUnits(ProcessModel::UnitsKB);
+        else
+            d->mModel.setUnits(ProcessModel::UnitsKB);
+        return;
+    } else if(result == actionMB) {
+        if(index == ProcessModel::HeadingIoRead || index == ProcessModel::HeadingIoWrite)
+            d->mModel.setIoUnits(ProcessModel::UnitsMB);
+        else
+            d->mModel.setUnits(ProcessModel::UnitsMB);
+        return;
+    } else if(result == actionGB) {
+        if(index == ProcessModel::HeadingIoRead || index == ProcessModel::HeadingIoWrite)
+            d->mModel.setIoUnits(ProcessModel::UnitsGB);
+        else
+            d->mModel.setUnits(ProcessModel::UnitsGB);
+        return;
+    } else if(result == actionPercentage) {
+        d->mModel.setUnits(ProcessModel::UnitsPercentage);
+        return;
+    } else if(result == actionShowCmdlineOptions) {
+        d->mModel.setShowCommandLineOptions(actionShowCmdlineOptions->isChecked());
+        return;
+    } else if(result == actionNormalizeCPUUsage) {
+        d->mModel.setNormalizedCPUUsage(actionNormalizeCPUUsage->isChecked());
+        return;
+    } else if(result == actionShowTooltips) {
+        d->mModel.setShowingTooltips(actionShowTooltips->isChecked());
+        return;
+    } else if(result == actionIoCharacters) {
+        d->mModel.setIoInformation((showIoRate)?ProcessModel::BytesRate:ProcessModel::Bytes);
+        return;
+    } else if(result == actionIoSyscalls) {
+        d->mModel.setIoInformation((showIoRate)?ProcessModel::SyscallsRate:ProcessModel::Syscalls);
+        return;
+    } else if(result == actionIoActualCharacters) {
+        d->mModel.setIoInformation((showIoRate)?ProcessModel::ActualBytesRate:ProcessModel::ActualBytes);
+        return;
+    } else if(result == actionIoShowRate) {
+        showIoRate = actionIoShowRate->isChecked();
+        switch(d->mModel.ioInformation()) {
+            case ProcessModel::Bytes:
+            case ProcessModel::BytesRate:
+                d->mModel.setIoInformation((showIoRate)?ProcessModel::BytesRate:ProcessModel::Bytes);
+                break;
+            case ProcessModel::Syscalls:
+            case ProcessModel::SyscallsRate:
+                d->mModel.setIoInformation((showIoRate)?ProcessModel::SyscallsRate:ProcessModel::Syscalls);
+                break;
+            case ProcessModel::ActualBytes:
+            case ProcessModel::ActualBytesRate:
+                d->mModel.setIoInformation((showIoRate)?ProcessModel::ActualBytesRate:ProcessModel::ActualBytes);
+                break;
+            default:
+                break;
+        }
+    }
+
+    int i = result->data().toInt();
+    //We set data to be negative to hide a column, and positive to show a column
+    if(i < 0)
+        d->mUi->treeView->hideColumn(-1-i);
+    else {
+        d->mUi->treeView->showColumn(i);
+        updateList();
+        d->mUi->treeView->resizeColumnToContents(i);
+        d->mUi->treeView->resizeColumnToContents(d->mFilterModel.columnCount());
+    }
+    menu.deleteLater();
+}
+
+void KSysGuardProcessList::expandAllChildren(const QModelIndex &parent)
+{
+    //This is called when the user expands a node.  This then expands all of its
+    //children.  This will trigger this function again recursively.
+    QModelIndex sourceParent = d->mFilterModel.mapToSource(parent);
+    for(int i = 0; i < d->mModel.rowCount(sourceParent); i++) {
+        d->mUi->treeView->expand(d->mFilterModel.mapFromSource(d->mModel.index(i,0, sourceParent)));
+    }
+}
+
+void KSysGuardProcessList::rowsInserted(const QModelIndex & parent, int start, int end )
+{
+    if(d->mModel.isSimpleMode() || parent.isValid()) {
+        emit processListChanged();
+        return; //No tree or not a root node - no need to expand init
+    }
+    disconnect(&d->mFilterModel, SIGNAL(rowsInserted(QModelIndex,int,int)), this, SLOT(rowsInserted(QModelIndex,int,int)));
+    //It is a root node that we just inserted - expand it
+    bool expanded = false;
+    for(int i = start; i <= end; i++) {
+        QModelIndex index = d->mFilterModel.index(i, 0, QModelIndex());
+        if(!d->mUi->treeView->isExpanded(index)) {
+            if(!expanded) {
+                disconnect(d->mUi->treeView, SIGNAL(expanded(QModelIndex)), this, SLOT(expandAllChildren(QModelIndex)));
+                expanded = true;
+            }
+            d->mUi->treeView->expand(index);
+            d->mNeedToExpandInit = true;
+        }
+    }
+    if(expanded)
+        connect(d->mUi->treeView, SIGNAL(expanded(QModelIndex)), this, SLOT(expandAllChildren(QModelIndex)));
+    connect(&d->mFilterModel, SIGNAL(rowsInserted(QModelIndex,int,int)), this, SLOT(rowsInserted(QModelIndex,int,int)));
+    emit processListChanged();
+}
+
+void KSysGuardProcessList::expandInit()
+{
+    if(d->mModel.isSimpleMode()) return; //No tree - no need to expand init
+
+    bool expanded = false;
+    for(int i = 0; i < d->mFilterModel.rowCount(QModelIndex()); i++) {
+        QModelIndex index = d->mFilterModel.index(i, 0, QModelIndex());
+        if(!d->mUi->treeView->isExpanded(index)) {
+            if(!expanded) {
+                disconnect(d->mUi->treeView, SIGNAL(expanded(QModelIndex)), this, SLOT(expandAllChildren(QModelIndex)));
+                expanded = true;
+            }
+
+            d->mUi->treeView->expand(index);
+        }
+    }
+    if(expanded)
+        connect(d->mUi->treeView, SIGNAL(expanded(QModelIndex)), this, SLOT(expandAllChildren(QModelIndex)));
+}
+
+void KSysGuardProcessList::hideEvent ( QHideEvent * event )  //virtual protected from QWidget
+{
+    //Stop updating the process list if we are hidden
+    if(d->mUpdateTimer)
+        d->mUpdateTimer->stop();
+    QWidget::hideEvent(event);
+}
+
+void KSysGuardProcessList::showEvent ( QShowEvent * event )  //virtual protected from QWidget
+{
+    //Start updating the process list again if we are shown again
+    updateList();
+    QHeaderView *header = d->mUi->treeView->header();
+    d->mUi->treeView->sortByColumn(header->sortIndicatorSection(), header->sortIndicatorOrder());
+    QWidget::showEvent(event);
+}
+
+void KSysGuardProcessList::changeEvent( QEvent * event )
+{
+    if (event->type() == QEvent::LanguageChange) {
+        d->mModel.retranslateUi();
+        d->mUi->retranslateUi(this);
+        retranslateUi();
+    }
+    QWidget::changeEvent(event);
+}
+void KSysGuardProcessList::retranslateUi()
+{
+    d->mUi->cmbFilter->setItemIcon(ProcessFilter::AllProcesses, KIcon("view-process-all"));
+    d->mUi->cmbFilter->setItemIcon(ProcessFilter::AllProcessesInTreeForm, KIcon("view-process-all-tree"));
+    d->mUi->cmbFilter->setItemIcon(ProcessFilter::SystemProcesses, KIcon("view-process-system"));
+    d->mUi->cmbFilter->setItemIcon(ProcessFilter::UserProcesses, KIcon("view-process-users"));
+    d->mUi->cmbFilter->setItemIcon(ProcessFilter::OwnProcesses, KIcon("view-process-own"));
+    d->mUi->cmbFilter->setItemIcon(ProcessFilter::ProgramsOnly, KIcon("view-process-all"));
+}
+
+void KSysGuardProcessList::updateList()
+{
+    if(isVisible()) {
+        KSysGuard::Processes::UpdateFlags updateFlags = KSysGuard::Processes::StandardInformation;
+        if(!d->mUi->treeView->isColumnHidden(ProcessModel::HeadingIoRead) || !d->mUi->treeView->isColumnHidden(ProcessModel::HeadingIoWrite))
+            updateFlags |= KSysGuard::Processes::IOStatistics;
+        if(!d->mUi->treeView->isColumnHidden(ProcessModel::HeadingXMemory))
+            updateFlags |= KSysGuard::Processes::XMemory;
+        d->mModel.update(d->mUpdateIntervalMSecs, updateFlags);
+        if(d->mUpdateTimer)
+            d->mUpdateTimer->start(d->mUpdateIntervalMSecs);
+        emit updated();
+        if (QToolTip::isVisible() && qApp->topLevelAt(QCursor::pos()) == window()) {
+            QWidget *w = d->mUi->treeView->viewport();
+            if(w->geometry().contains(d->mUi->treeView->mapFromGlobal( QCursor::pos() ))) {
+                QHelpEvent event(QEvent::ToolTip, w->mapFromGlobal( QCursor::pos() ), QCursor::pos());
+                qApp->notify(w, &event);
+            }
+        }
+        if(--d->mResortCountDown <= 0) {
+            d->mResortCountDown = 2;  //resort every second time
+            //resort now
+            QHeaderView *header= d->mUi->treeView->header();
+            d->mUi->treeView->sortByColumn(header->sortIndicatorSection(), header->sortIndicatorOrder());
+        }
+        if( d->mNeedToExpandInit ) {
+            expandInit();
+            d->mNeedToExpandInit = false;
+        }
+    }
+}
+
+int KSysGuardProcessList::updateIntervalMSecs() const
+{
+    return d->mUpdateIntervalMSecs;
+}
+
+void KSysGuardProcessList::setUpdateIntervalMSecs(int intervalMSecs)
+{
+    if(intervalMSecs == d->mUpdateIntervalMSecs)
+        return;
+
+    d->mUpdateIntervalMSecs = intervalMSecs;
+    if(intervalMSecs <= 0) { //no point keep the timer around if we aren't updating automatically
+        delete d->mUpdateTimer;
+        d->mUpdateTimer = NULL;
+        return;
+    }
+
+    if(!d->mUpdateTimer) {
+        //intervalMSecs is a valid time, so set up a timer
+        d->mUpdateTimer = new QTimer(this);
+        d->mUpdateTimer->setSingleShot(true);
+        connect(d->mUpdateTimer, SIGNAL(timeout()), SLOT(updateList()));
+        if(isVisible())
+            d->mUpdateTimer->start(d->mUpdateIntervalMSecs);
+    } else
+        d->mUpdateTimer->setInterval(d->mUpdateIntervalMSecs);
+}
+
+bool KSysGuardProcessList::reniceProcesses(const QList<long long> &pids, int niceValue)
+{
+    QList< long long> unreniced_pids;
+    for (int i = 0; i < pids.size(); ++i) {
+        bool success = d->mModel.processController()->setNiceness(pids.at(i), niceValue);
+        if(!success) {
+            unreniced_pids << pids.at(i);
+        }
+    }
+    if(unreniced_pids.isEmpty()) return true; //All processes were reniced successfully
+    if(!d->mModel.isLocalhost()) return false; //We can't use kauth to renice non-localhost processes
+
+
+    KAuth::Action *action = new KAuth::Action("org.kde.ksysguard.processlisthelper.renice");
+    action->setParentWidget(window());
+    d->setupKAuthAction( action, unreniced_pids);
+    action->addArgument("nicevalue", niceValue);
+    KAuth::ActionReply reply = action->execute();
+
+    if (reply == KAuth::ActionReply::SuccessReply) {
+        updateList();
+        delete action;
+    } else if (reply != KAuth::ActionReply::UserCancelled && reply != KAuth::ActionReply::AuthorizationDenied) {
+        KMessageBox::sorry(this, i18n("You do not have the permission to renice the process and there "
+                    "was a problem trying to run as root.  Error %1 %2", reply.errorCode(), reply.errorDescription()));
+        delete action;
+        return false;
+    }
+    return true;
+}
+
+QList<KSysGuard::Process *> KSysGuardProcessList::selectedProcesses() const
+{
+    QList<KSysGuard::Process *> processes;
+    QModelIndexList selectedIndexes = d->mUi->treeView->selectionModel()->selectedRows();
+    for(int i = 0; i < selectedIndexes.size(); ++i) {
+        KSysGuard::Process *process = reinterpret_cast<KSysGuard::Process *> (d->mFilterModel.mapToSource(selectedIndexes.at(i)).internalPointer());
+        processes << process;
+    }
+    return processes;
+
+}
+
+void KSysGuardProcessList::reniceSelectedProcesses()
+{
+    QList<long long> pids;
+    QPointer<ReniceDlg> reniceDlg;
+    {
+        QList<KSysGuard::Process *> processes = selectedProcesses();
+        QStringList selectedAsStrings;
+
+        if (processes.isEmpty()) {
+            KMessageBox::sorry(this, i18n("You must select a process first."));
+            return;
+        }
+
+        int sched = -2;
+        int iosched = -2;
+        foreach(KSysGuard::Process *process, processes) {
+            pids << process->pid;
+            selectedAsStrings << d->mModel.getStringForProcess(process);
+            if(sched == -2) sched = (int)process->scheduler;
+            else if(sched != -1 && sched != (int)process->scheduler) sched = -1;  //If two processes have different schedulers, disable the cpu scheduler stuff
+            if(iosched == -2) iosched = (int)process->ioPriorityClass;
+            else if(iosched != -1 && iosched != (int)process->ioPriorityClass) iosched = -1;  //If two processes have different schedulers, disable the cpu scheduler stuff
+
+        }
+        int firstPriority = processes.first()->niceLevel;
+        int firstIOPriority = processes.first()->ioniceLevel;
+
+        bool supportsIoNice = d->mModel.processController()->supportsIoNiceness();
+        if(!supportsIoNice) { iosched = -2; firstIOPriority = -2; }
+        reniceDlg = new ReniceDlg(d->mUi->treeView, selectedAsStrings, firstPriority, sched, firstIOPriority, iosched);
+        if(reniceDlg->exec() == QDialog::Rejected) {
+            delete reniceDlg;
+            return;
+        }
+    }
+
+    //Because we've done into ReniceDlg, which calls processEvents etc, our processes list is no
+    //longer valid
+
+    QList<long long> renicePids;
+    QList<long long> changeCPUSchedulerPids;
+    QList<long long> changeIOSchedulerPids;
+    foreach (long long pid, pids) {
+        KSysGuard::Process *process = d->mModel.getProcess(pid);
+        if (!process)
+            continue;
+
+        switch(reniceDlg->newCPUSched) {
+            case -2:
+            case -1:  //Invalid, not changed etc.
+                break;  //So do nothing
+            case KSysGuard::Process::Other:
+            case KSysGuard::Process::Fifo:
+                if(reniceDlg->newCPUSched != (int)process->scheduler) {
+                    changeCPUSchedulerPids << pid;
+                    renicePids << pid;
+                } else if(reniceDlg->newCPUPriority != process->niceLevel)
+                    renicePids << pid;
+                break;
+
+            case KSysGuard::Process::RoundRobin:
+            case KSysGuard::Process::Batch:
+                if(reniceDlg->newCPUSched != (int)process->scheduler || reniceDlg->newCPUPriority != process->niceLevel) {
+                    changeCPUSchedulerPids << pid;
+                }
+                break;
+        }
+        switch(reniceDlg->newIOSched) {
+            case -2:
+            case -1:  //Invalid, not changed etc.
+                break;  //So do nothing
+            case KSysGuard::Process::None:
+                if(reniceDlg->newIOSched != (int)process->ioPriorityClass) {
+                    // Unfortunately linux doesn't actually let us set the ioniceness back to none after being set to something else
+                    if(process->ioPriorityClass != KSysGuard::Process::BestEffort || reniceDlg->newIOPriority != process->ioniceLevel)
+                        changeIOSchedulerPids << pid;
+                }
+                break;
+            case KSysGuard::Process::Idle:
+                if(reniceDlg->newIOSched != (int)process->ioPriorityClass) {
+                    changeIOSchedulerPids << pid;
+                }
+                break;
+            case KSysGuard::Process::BestEffort:
+                if(process->ioPriorityClass == KSysGuard::Process::None && reniceDlg->newIOPriority  == (process->niceLevel + 20)/5)
+                    break;  //Don't set to BestEffort if it's on None and the nicelevel wouldn't change
+            case KSysGuard::Process::RealTime:
+                if(reniceDlg->newIOSched != (int)process->ioPriorityClass || reniceDlg->newIOPriority != process->ioniceLevel) {
+                    changeIOSchedulerPids << pid;
+                }
+                break;
+        }
+
+    }
+    if(!changeCPUSchedulerPids.isEmpty()) {
+        Q_ASSERT(reniceDlg->newCPUSched >= 0);
+        if(!changeCpuScheduler(changeCPUSchedulerPids, (KSysGuard::Process::Scheduler) reniceDlg->newCPUSched, reniceDlg->newCPUPriority)) {
+            delete reniceDlg;
+            return;
+        }
+
+    }
+    if(!renicePids.isEmpty()) {
+        Q_ASSERT(reniceDlg->newCPUPriority <= 20 && reniceDlg->newCPUPriority >= -20);
+        if(!reniceProcesses(renicePids, reniceDlg->newCPUPriority)) {
+            delete reniceDlg;
+            return;
+        }
+    }
+    if(!changeIOSchedulerPids.isEmpty()) {
+        if(!changeIoScheduler(changeIOSchedulerPids, (KSysGuard::Process::IoPriorityClass) reniceDlg->newIOSched, reniceDlg->newIOPriority)) {
+            delete reniceDlg;
+            return;
+        }
+    }
+    delete reniceDlg;
+    updateList();
+}
+
+bool KSysGuardProcessList::changeIoScheduler(const QList< long long> &pids, KSysGuard::Process::IoPriorityClass newIoSched, int newIoSchedPriority)
+{
+    if(newIoSched == KSysGuard::Process::None) newIoSched = KSysGuard::Process::BestEffort;
+    if(newIoSched == KSysGuard::Process::Idle) newIoSchedPriority = 0;
+    QList< long long> unchanged_pids;
+    for (int i = 0; i < pids.size(); ++i) {
+        bool success = d->mModel.processController()->setIoNiceness(pids.at(i), newIoSched, newIoSchedPriority);
+        if(!success) {
+            unchanged_pids << pids.at(i);
+        }
+    }
+    if(unchanged_pids.isEmpty()) return true;
+    if(!d->mModel.isLocalhost()) return false; //We can't use kauth to affect non-localhost processes
+
+    KAuth::Action *action = new KAuth::Action("org.kde.ksysguard.processlisthelper.changeioscheduler");
+    action->setParentWidget(window());
+
+    d->setupKAuthAction( action, unchanged_pids);
+    action->addArgument("ioScheduler", (int)newIoSched);
+    action->addArgument("ioSchedulerPriority", newIoSchedPriority);
+
+    KAuth::ActionReply reply = action->execute();
+
+    if (reply == KAuth::ActionReply::SuccessReply) {
+        updateList();
+        delete action;
+    } else if (reply != KAuth::ActionReply::UserCancelled && reply != KAuth::ActionReply::AuthorizationDenied) {
+        KMessageBox::sorry(this, i18n("You do not have the permission to change the I/O priority of the process and there "
+                    "was a problem trying to run as root.  Error %1 %2", reply.errorCode(), reply.errorDescription()));
+        delete action;
+        return false;
+    }
+    return true;
+}
+
+bool KSysGuardProcessList::changeCpuScheduler(const QList< long long> &pids, KSysGuard::Process::Scheduler newCpuSched, int newCpuSchedPriority)
+{
+    if(newCpuSched == KSysGuard::Process::Other || newCpuSched == KSysGuard::Process::Batch) newCpuSchedPriority = 0;
+    QList< long long> unchanged_pids;
+    for (int i = 0; i < pids.size(); ++i) {
+        bool success = d->mModel.processController()->setScheduler(pids.at(i), newCpuSched, newCpuSchedPriority);
+        if(!success) {
+            unchanged_pids << pids.at(i);
+        }
+    }
+    if(unchanged_pids.isEmpty()) return true;
+    if(!d->mModel.isLocalhost()) return false; //We can't use KAuth to affect non-localhost processes
+
+    KAuth::Action *action = new KAuth::Action("org.kde.ksysguard.processlisthelper.changecpuscheduler");
+    action->setParentWidget(window());
+    d->setupKAuthAction( action, unchanged_pids);
+    action->addArgument("cpuScheduler", (int)newCpuSched);
+    action->addArgument("cpuSchedulerPriority", newCpuSchedPriority);
+    KAuth::ActionReply reply = action->execute();
+
+    if (reply == KAuth::ActionReply::SuccessReply) {
+        updateList();
+        delete action;
+    } else if (reply != KAuth::ActionReply::UserCancelled && reply != KAuth::ActionReply::AuthorizationDenied) {
+        KMessageBox::sorry(this, i18n("You do not have the permission to change the CPU Scheduler for the process and there "
+                    "was a problem trying to run as root.  Error %1 %2", reply.errorCode(), reply.errorDescription()));
+        delete action;
+        return false;
+    }
+    return true;
+}
+
+bool KSysGuardProcessList::killProcesses(const QList< long long> &pids, int sig)
+{
+    QList< long long> unkilled_pids;
+    for (int i = 0; i < pids.size(); ++i) {
+        bool success = d->mModel.processController()->sendSignal(pids.at(i), sig);
+        // If we failed due to a reason other than insufficient permissions, elevating to root can't
+        // help us
+        if(!success && (d->mModel.processController()->lastError() == KSysGuard::Processes::InsufficientPermissions || d->mModel.processController()->lastError() == KSysGuard::Processes::Unknown)) {
+            unkilled_pids << pids.at(i);
+        }
+    }
+    if(unkilled_pids.isEmpty()) return true;
+    if(!d->mModel.isLocalhost()) return false; //We can't elevate privileges to kill non-localhost processes
+
+    KAuth::Action action("org.kde.ksysguard.processlisthelper.sendsignal");
+    action.setParentWidget(window());
+    d->setupKAuthAction( &action, unkilled_pids);
+    action.addArgument("signal", sig);
+    KAuth::ActionReply reply = action.execute();
+
+    if (reply == KAuth::ActionReply::SuccessReply) {
+        updateList();
+    } else if (reply.type() == KAuth::ActionReply::HelperError) {
+        if (reply.errorCode() > 0)
+            KMessageBox::sorry(this, i18n("You do not have the permission to kill the process and there "
+                        "was a problem trying to run as root. %1", reply.errorDescription()));
+        return false;
+    } else if (reply != KAuth::ActionReply::UserCancelled && reply != KAuth::ActionReply::AuthorizationDenied) {
+        KMessageBox::sorry(this, i18n("You do not have the permission to kill the process and there "
+                    "was a problem trying to run as root.  Error %1 %2", reply.errorCode(), reply.errorDescription()));
+        return false;
+    }
+    return true;
+}
+
+void KSysGuardProcessList::killSelectedProcesses()
+{
+    sendSignalToSelectedProcesses(SIGTERM, true);
+}
+
+void KSysGuardProcessList::sendSignalToSelectedProcesses(int sig, bool confirm)
+{
+    QModelIndexList selectedIndexes = d->mUi->treeView->selectionModel()->selectedRows();
+    QStringList selectedAsStrings;
+    QList< long long> selectedPids;
+
+    QList<KSysGuard::Process *> processes = selectedProcesses();
+    foreach(KSysGuard::Process *process, processes) {
+        selectedPids << process->pid;
+        if (!confirm)
+            continue;
+        QString name = d->mModel.getStringForProcess(process);
+        if(name.size() > 100)
+            name = name.left(95) + QString::fromUtf8("…");
+        selectedAsStrings << name;
+    }
+
+    if (selectedPids.isEmpty()) {
+        if (confirm)
+            KMessageBox::sorry(this, i18n("You must select a process first."));
+        return;
+    } else if (confirm && (sig == SIGTERM || sig == SIGKILL)) {
+        int count = selectedAsStrings.count();
+        QString msg;
+        QString title;
+        QString dontAskAgainKey;
+        QString closeButton;
+        if (sig == SIGTERM) {
+            msg = i18np("Are you sure you want to end this process?  Any unsaved work may be lost.",
+                "Are you sure you want to end these %1 processes?  Any unsaved work may be lost",
+                count);
+            title =  i18ncp("Dialog title", "End Process", "End %1 Processes", count);
+            dontAskAgainKey = "endconfirmation";
+            closeButton = i18n("End");
+        } else if (sig == SIGKILL) {
+            msg = i18np("<qt>Are you sure you want to <b>immediately and forcibly kill</b> this process?  Any unsaved work may be lost.",
+                "<qt>Are you sure you want to <b>immediately and forcibly kill</b> these %1 processes?  Any unsaved work may be lost",
+                count);
+            title =  i18ncp("Dialog title", "Forcibly Kill Process", "Forcibly Kill %1 Processes", count);
+            dontAskAgainKey = "killconfirmation";
+            closeButton = i18n("Kill");
+        }
+
+        int res = KMessageBox::warningContinueCancelList(this, msg, selectedAsStrings,
+                title,
+                KGuiItem(closeButton, "process-stop"),
+                KStandardGuiItem::cancel(),
+                dontAskAgainKey);
+        if (res != KMessageBox::Continue)
+            return;
+    }
+
+    //We have shown a GUI dialog box, which processes events etc.
+    //So processes is NO LONGER VALID
+
+    if (!killProcesses(selectedPids, sig))
+        return;
+    if (sig == SIGTERM || sig == SIGKILL) {
+        foreach (long long pid, selectedPids) {
+            KSysGuard::Process *process = d->mModel.getProcess(pid);
+            if (process)
+                process->timeKillWasSent.start();
+            d->mUi->treeView->selectionModel()->clearSelection();
+        }
+    }
+    updateList();
+}
+
+bool KSysGuardProcessList::showTotals() const {
+    return d->mModel.showTotals();
+}
+
+void KSysGuardProcessList::setShowTotals(bool showTotals)  //slot
+{
+    d->mModel.setShowTotals(showTotals);
+}
+
+ProcessModel::Units KSysGuardProcessList::units() const {
+    return d->mModel.units();
+}
+
+void KSysGuardProcessList::setUnits(ProcessModel::Units unit) {
+    d->mModel.setUnits(unit);
+}
+
+void KSysGuardProcessList::saveSettings(KConfigGroup &cg) {
+    /* Note that the ksysguard program does not use these functions.  It saves the settings itself to an xml file instead */
+    cg.writeEntry("units", (int)(units()));
+    cg.writeEntry("ioUnits", (int)(d->mModel.ioUnits()));
+    cg.writeEntry("ioInformation", (int)(d->mModel.ioInformation()));
+    cg.writeEntry("showCommandLineOptions", d->mModel.isShowCommandLineOptions());
+    cg.writeEntry("normalizeCPUUsage", d->mModel.isNormalizedCPUUsage());
+    cg.writeEntry("showTooltips", d->mModel.isShowingTooltips());
+    cg.writeEntry("showTotals", showTotals());
+    cg.writeEntry("filterState", (int)(state()));
+    cg.writeEntry("updateIntervalMSecs", updateIntervalMSecs());
+    cg.writeEntry("headerState", d->mUi->treeView->header()->saveState());
+    //If we change, say, the header between versions of ksysguard, then the old headerState settings will not be valid.
+    //The version property lets us keep track of which version we are
+    cg.writeEntry("version", PROCESSHEADERVERSION);
+}
+
+void KSysGuardProcessList::loadSettings(const KConfigGroup &cg) {
+    /* Note that the ksysguard program does not use these functions.  It saves the settings itself to an xml file instead */
+    setUnits((ProcessModel::Units) cg.readEntry("units", (int)ProcessModel::UnitsKB));
+    d->mModel.setIoUnits((ProcessModel::Units) cg.readEntry("ioUnits", (int)ProcessModel::UnitsKB));
+    d->mModel.setIoInformation((ProcessModel::IoInformation) cg.readEntry("ioInformation", (int)ProcessModel::ActualBytesRate));
+    d->mModel.setShowCommandLineOptions(cg.readEntry("showCommandLineOptions", false));
+    d->mModel.setNormalizedCPUUsage(cg.readEntry("normalizeCPUUsage", true));
+    d->mModel.setShowingTooltips(cg.readEntry("showTooltips", true));
+    setShowTotals(cg.readEntry("showTotals", true));
+    setStateInt(cg.readEntry("filterState", (int)ProcessFilter::AllProcesses));
+    setUpdateIntervalMSecs(cg.readEntry("updateIntervalMSecs", 2000));
+    int version = cg.readEntry("version", 0);
+    if(version == PROCESSHEADERVERSION) {  //If the header has changed, the old settings are no longer valid.  Only restore if version is the same
+        restoreHeaderState(cg.readEntry("headerState", QByteArray()));
+    }
+}
+
+void KSysGuardProcessList::restoreHeaderState(const QByteArray & state) {
+    d->mUi->treeView->header()->restoreState(state);
+}
+
+bool KSysGuardProcessList::eventFilter(QObject *obj, QEvent *event) {
+    if (event->type() == QEvent::KeyPress) {
+        QKeyEvent *keyEvent = static_cast<QKeyEvent *>(event);
+        if(obj == d->mUi->treeView) {
+            if(keyEvent->key() == Qt::Key_Enter || keyEvent->key() == Qt::Key_Return) {
+                d->mUi->treeView->selectionModel()->select(d->mUi->treeView->currentIndex(), QItemSelectionModel::Select | QItemSelectionModel::Rows);
+                showProcessContextMenu(d->mUi->treeView->currentIndex());
+                return true;
+
+            } else if(keyEvent->matches(QKeySequence::MoveToPreviousLine) || keyEvent->matches(QKeySequence::SelectPreviousLine) ||
+                    keyEvent->matches(QKeySequence::MoveToPreviousPage) ||  keyEvent->matches(QKeySequence::SelectPreviousPage)) {
+
+                if (d->mUi->treeView->selectionModel()->selectedRows().size() == 1 &&
+                        d->mUi->treeView->selectionModel()->selectedRows().first().row() == 0) {
+                    // when first row is selected, pressing up or pgup moves to the textfield
+                    d->mUi->txtFilter->setFocus();
+                    return true;
+                }
+
+            } else if (!keyEvent->text().isEmpty() && keyEvent->key() != Qt::Key_Tab) {
+                // move to textfield and forward keyevent if user starts typing from treeview
+                d->mUi->txtFilter->setFocus();
+                QApplication::sendEvent(d->mUi->txtFilter, event);
+                return true;
+            }
+        } else {
+            Q_ASSERT(obj == d->mUi->txtFilter);
+            if (d->mUi->treeView->model()->rowCount() == 0) {
+                // treeview is empty, do nothing
+                return false;
+            }
+
+            if (keyEvent->key() == Qt::Key_Enter || keyEvent->key() == Qt::Key_Return) {
+                // pressing enter will send enter to the first row in the list
+                // the focusin eventfilter will make sure the first row is selected if there was
+                // no previous selection
+                d->mUi->treeView->setFocus();
+                QApplication::sendEvent(d->mUi->treeView, event);
+                return true;
+
+            } else if(keyEvent->matches(QKeySequence::MoveToNextLine) || keyEvent->matches(QKeySequence::SelectNextLine) ||
+                    keyEvent->matches(QKeySequence::MoveToNextPage) ||  keyEvent->matches(QKeySequence::SelectNextPage)) {
+                // attempting to move down by down-key or pgdown, or pressing enter will move focus
+                // to the treeview
+                d->mUi->treeView->setFocus();
+                return true;
+            }
+        }
+    } else if (event->type() == QEvent::FocusIn) {
+        if (obj == d->mUi->treeView && !d->mUi->treeView->selectionModel()->hasSelection()) {
+            // treeview is focused, but there is no current selection. select the first row
+            d->mUi->treeView->setCurrentIndex(d->mUi->treeView->model()->index(0, 0));
+        } else if (obj == d->mUi->txtFilter) {
+            // text field is focused, so clear treeview selection to communicate that you will not
+            // interact with any elements in the view until the view is focused explicitly
+            d->mUi->treeView->setCurrentIndex(QModelIndex());
+        }
+    }
+    return false;
+}
+
+ProcessModel *KSysGuardProcessList::processModel() {
+    return &d->mModel;
+}
+
+void KSysGuardProcessList::setKillButtonVisible(bool visible)
+{
+    d->mUi->btnKillProcess->setVisible(visible);
+}
+
+bool KSysGuardProcessList::isKillButtonVisible() const
+{
+    return d->mUi->btnKillProcess->isVisible();
+}
+bool KSysGuardProcessList::scriptingEnabled() const
+{
+    return false;
+}
+void KSysGuardProcessList::setScriptingEnabled(bool enabled)
+{
+}
diff --git a/debuggers/gdb/ksysguard/ksysguardprocesslist.h b/debuggers/gdb/ksysguard/ksysguardprocesslist.h
new file mode 100644
index 0000000..9690ade
--- /dev/null
+++ b/debuggers/gdb/ksysguard/ksysguardprocesslist.h
@@ -0,0 +1,233 @@
+/*
+    KSysGuard, the KDE System Guard
+
+	Copyright (c) 1999, 2000 Chris Schlaeger <cs@kde.org>
+	Copyright (c) 2006 John Tapsell <john.tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef _KSysGuardProcessList_h_
+#define _KSysGuardProcessList_h_
+
+#include <QtGui/QWidget>
+#include <QMetaType>
+#include <kapplication.h>
+#include "ProcessModel.h"
+#include "ProcessFilter.h"
+#include "processes.h"
+
+class QShowEvent;
+class QHideEvent;
+class QLineEdit;
+class QTreeView;
+struct KSysGuardProcessListPrivate;
+
+/**
+ * This widget implements a process list page. Besides the process
+ * list which is implemented as a ProcessList, it contains two
+ * combo boxes and two buttons.  The combo boxes are used to set the
+ * update rate and the process filter.  The buttons are used to force
+ * an immediate update and to kill a process.
+ */
+class KDE_EXPORT KSysGuardProcessList : public QWidget
+{
+    Q_OBJECT
+        Q_PROPERTY( bool showTotalsInTree READ showTotals WRITE setShowTotals )
+        Q_PROPERTY( ProcessFilter::State state READ state WRITE setState )
+        Q_PROPERTY( int updateIntervalMSecs READ updateIntervalMSecs WRITE setUpdateIntervalMSecs )
+        Q_PROPERTY( ProcessModel::Units units READ units WRITE setUnits )
+        Q_PROPERTY( bool killButtonVisible READ isKillButtonVisible WRITE setKillButtonVisible )
+        Q_PROPERTY( bool scriptingEnabled READ scriptingEnabled WRITE setScriptingEnabled )
+        Q_ENUMS( ProcessFilter::State )
+        Q_ENUMS( ProcessModel::Units )
+
+    public:
+        KSysGuardProcessList(QWidget* parent = NULL, const QString &hostName = QString());
+        virtual ~KSysGuardProcessList();
+
+        QLineEdit *filterLineEdit() const;
+        QTreeView *treeView() const;
+
+        /** Returns which processes we are currently filtering for and the way in which we show them.
+         *  @see setState()
+         */
+        ProcessFilter::State state() const;
+
+        /** Returns the number of milliseconds that have to elapse before updating the list of processes.
+         *  If this is 0, the processes will not be automatically updated. */
+        int updateIntervalMSecs() const;
+
+        /** Whether the widget will show child totals for CPU and Memory etc usage */
+        bool showTotals() const;
+
+        /** The units to display memory sizes etc in.  E.g. kb/mb/gb */
+        ProcessModel::Units units() const;
+
+        /** Returns a list of the processes that have been selected by the user. */
+        QList<KSysGuard::Process *> selectedProcesses() const;
+
+        /** Returns the number of processes currently being displayed
+         *
+         *  To get the total number processes, visible or not, use processModel()->
+         * */
+        int visibleProcessesCount() const;
+
+        /** Save the current state of the widget to the given config group
+         *
+         *  @param[in] cg Config group to add these settings to
+         * */
+        void saveSettings(KConfigGroup &cg);
+
+        /** Load the saved state of the widget from the given config group */
+        void loadSettings(const KConfigGroup &cg);
+
+        /** Returns the process model used. Use with caution. */
+        ProcessModel *processModel();
+
+        /** Restore the headings to the given state. */
+        void restoreHeaderState(const QByteArray & state);
+
+        /** @returns whether the Kill Process button is visible. */
+        bool isKillButtonVisible() const;
+
+        /** @param visible defines whether the Kill Process button is shown or not. */
+        void setKillButtonVisible(bool visible);
+
+        /** Whether scripting support is enabled.
+         *
+         *  Default is false. */
+        bool scriptingEnabled() const;
+        /** Set whether scripting support is enabled.
+         *
+         *  Default is false. */
+        void setScriptingEnabled(bool enabled);
+
+    Q_SIGNALS:
+        /** Emitted when the display has been updated */
+        void updated();
+        void processListChanged();
+
+    public Q_SLOTS:
+        /** Inform the view that the user has changed the selection */
+        void selectionChanged();
+
+        /** Send a kill signal to all the processes that the user has selected.  Pops up a dialog box to confirm with the user */
+        void killSelectedProcesses();
+
+        /** Send a signal to all the processes that the user has selected.
+         * @p confirm - If true, pops up a dialog box to confirm with the user
+         */
+        void sendSignalToSelectedProcesses(int sig, bool confirm);
+
+        /** Send a signal to a list of given processes.
+         *   @p pids A list of PIDs that should be sent the signal
+         *   @p sig  The signal to send.
+         *   @return Whether the kill went ahead. True if successful or user cancelled.  False if there was a problem
+         */
+        bool killProcesses(const QList< long long> &pids, int sig);
+
+        /** Renice all the processes that the user has selected.  Pops up a dialog box to ask for the nice value and confirm */
+        void reniceSelectedProcesses();
+
+        /** Change the CPU scheduler for the given of processes to the given scheduler, with the given scheduler priority.
+         *  If the scheduler is Other or Batch, @p newCpuSchedPriority is ignored.
+         *   @return Whether the cpu scheduler changing went ahead.  True if successful or user cancelled.  False if there was a problem
+         */
+        bool changeCpuScheduler(const QList< long long> &pids, KSysGuard::Process::Scheduler newCpuSched, int newCpuSchedPriority);
+
+        /** Change the I/O scheduler for the given of processes to the given scheduler, with the given scheduler priority.
+         *  If the scheduler is Other or Batch, @p newCpuSchedPriority is ignored.
+         *   @return Whether the cpu scheduler changing went ahead.  True if successful or user cancelled.  False if there was a problem
+         */
+        bool changeIoScheduler(const QList< long long> &pids, KSysGuard::Process::IoPriorityClass newIoSched, int newIoSchedPriority);
+        /** Renice the processes given to the given niceValue.
+         *   @return Whether the kill went ahead.  True if successful or user cancelled.  False if there was a problem
+         * */
+        bool reniceProcesses(const QList<long long> &pids, int niceValue);
+
+        /** Fetch new process information and redraw the display */
+        void updateList();
+
+        /** Set which processes we are currently filtering for and the way in which we show them. */
+        void setState(ProcessFilter::State state);
+
+        /** Set the number of milliseconds that have to elapse before updating the list of processes.
+         *  If this is set to 0, the process list will not be automatically updated and the owner can call
+         *  updateList() manually. */
+        void setUpdateIntervalMSecs(int intervalMSecs);
+
+        /** Set whether to show child totals for CPU and Memory etc usage */
+        void setShowTotals(bool showTotals);
+
+        /** Focus on a particular process, and select it */
+        void selectAndJumpToProcess(int pid);
+
+        /** The units to display memory sizes etc in. */
+        void setUnits(ProcessModel::Units unit);
+
+        /** Row was just inserted in the filter model */
+        void rowsInserted ( const QModelIndex & parent, int start, int end );
+
+    private Q_SLOTS:
+        /** Expand all the children, recursively, of the node given.  Pass an empty QModelIndex to expand all the top level children */
+        void expandAllChildren(const QModelIndex &parent);
+
+        /** Expand init to show its children, but not the sub children processes. */
+        void expandInit();
+
+        /** Display a context menu for the column headings allowing the user to show or hide columns. */
+        void showColumnContextMenu(const QPoint &point);
+
+        /**  Display a context menu for the given process allowing the user to kill etc the process */
+        void showProcessContextMenu(const QModelIndex &index);
+
+        /** Display a context menu for the selected processes allowing the user to kill etc the process */
+        void showProcessContextMenu(const QPoint &point);
+
+        /** Set state from combo box int value */
+        void setStateInt(int state);
+
+        /** Called when the text in the gui filter text box has changed */
+        void filterTextChanged(const QString &newText);
+
+        /** Called when one of the actions (kill, renice etc) is clicked etc */
+        void actionTriggered(QObject *object);
+
+    protected:
+        /** Inherit QWidget::showEvent(QShowEvent *) to enable the timer, for updates, when visible */
+        virtual void showEvent(QShowEvent*);
+
+        /** Inherit QWidget::hideEvent(QShowEvent *) to disable the timer, for updates, when not visible */
+        virtual void hideEvent(QHideEvent*);
+
+        /** Capture any change events sent to this widget.  In particular QEvent::LanguageChange */
+        virtual void changeEvent ( QEvent * event );
+
+        bool eventFilter(QObject *obj, QEvent *event);
+
+        /** Retranslate the Ui as needed */
+        void retranslateUi();
+
+    private:
+        KSysGuardProcessListPrivate* const d;
+};
+
+Q_DECLARE_METATYPE( long long )
+Q_DECLARE_METATYPE( QList<long long> )
+
+#endif
diff --git a/debuggers/gdb/ksysguard/process.cpp b/debuggers/gdb/ksysguard/process.cpp
new file mode 100644
index 0000000..b63c514
--- /dev/null
+++ b/debuggers/gdb/ksysguard/process.cpp
@@ -0,0 +1,340 @@
+/*  This file is part of the KDE project
+
+    Copyright (C) 2007 John Tapsell <tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include "process.h"
+
+
+KSysGuard::Process::Process() {
+    clear();
+}
+KSysGuard::Process::Process(qlonglong _pid, qlonglong _ppid, Process *_parent)  {
+    clear();
+    pid = _pid;
+    parent_pid = _ppid;
+    parent = _parent;
+}
+
+QString KSysGuard::Process::niceLevelAsString() const {
+    // Just some rough heuristic to map a number to how nice it is
+    if( niceLevel == 0) return i18nc("Process Niceness", "Normal");
+    if( niceLevel >= 10) return i18nc("Process Niceness", "Very low priority");
+    if( niceLevel > 0) return i18nc("Process Niceness", "Low priority");
+    if( niceLevel <= -10) return i18nc("Process Niceness", "Very high priority");
+    if( niceLevel < 0) return i18nc("Process Niceness", "High priority");
+    return QString(); //impossible;
+}
+
+QString KSysGuard::Process::ioniceLevelAsString() const {
+    // Just some rough heuristic to map a number to how nice it is
+    if( ioniceLevel == 4) return i18nc("Process Niceness", "Normal");
+    if( ioniceLevel >= 6) return i18nc("Process Niceness", "Very low priority");
+    if( ioniceLevel > 4) return i18nc("Process Niceness", "Low priority");
+    if( ioniceLevel <= 2) return i18nc("Process Niceness", "Very high priority");
+    if( ioniceLevel < 4) return i18nc("Process Niceness", "High priority");
+    return QString(); //impossible;
+
+}
+
+QString KSysGuard::Process::ioPriorityClassAsString() const {
+    switch( ioPriorityClass ) {
+        case None: return i18nc("Priority Class", "None");
+        case RealTime: return i18nc("Priority Class", "Real Time");
+        case BestEffort: return i18nc("Priority Class", "Best Effort");
+        case Idle: return i18nc("Priority Class", "Idle");
+        default: return i18nc("Priority Class", "Unknown");
+    }
+}
+
+QString KSysGuard::Process::translatedStatus() const {
+    switch( status ) {
+        case Running: return i18nc("process status", "running");
+        case Sleeping: return i18nc("process status", "sleeping");
+        case DiskSleep: return i18nc("process status", "disk sleep");
+        case Zombie: return i18nc("process status", "zombie");
+        case Stopped: return i18nc("process status", "stopped");
+        case Paging: return i18nc("process status", "paging");
+        case Ended: return i18nc("process status", "finished");
+        default: return i18nc("process status", "unknown");
+    }
+}
+
+QString KSysGuard::Process::schedulerAsString() const {
+    switch( scheduler ) {
+        case Fifo: return i18nc("Scheduler", "FIFO");
+        case RoundRobin: return i18nc("Scheduler", "Round Robin");
+        case Interactive: return i18nc("Scheduler", "Interactive");
+        case Batch: return i18nc("Scheduler", "Batch");
+        case SchedulerIdle: return i18nc("Scheduler", "Idle");
+        default: return QString();
+    }
+}
+
+void KSysGuard::Process::clear() {
+    pid = -1;
+    parent_pid = -1;
+    uid = 0;
+    gid = -1;
+    numThreads = 0;
+    suid = euid = fsuid = -1;
+    sgid = egid = fsgid = -1;
+    tracerpid = -1;
+    userTime = 0;
+    sysTime = 0;
+    elapsedTimeMilliSeconds = 0;
+    userUsage=0;
+    sysUsage=0;
+    totalUserUsage=0;
+    totalSysUsage=0;
+    numChildren=0;
+    niceLevel=0;
+    vmSize=0;
+    vmRSS = 0;
+    vmURSS = 0;
+    vmSizeChange = 0;
+    vmRSSChange = 0;
+    vmURSSChange = 0;
+    pixmapBytes = 0;
+    hasManagedGuiWindow = false;
+    status=OtherStatus;
+    parent = NULL;
+    ioPriorityClass = None;
+    ioniceLevel = -1;
+    scheduler = Other;
+    ioCharactersRead = 0;
+    ioCharactersWritten = 0;
+    ioReadSyscalls = 0;
+    ioWriteSyscalls = 0;
+    ioCharactersActuallyRead = 0;
+    ioCharactersActuallyWritten = 0;
+    ioCharactersReadRate = 0;
+    ioCharactersWrittenRate = 0;
+    ioReadSyscallsRate = 0;
+    ioWriteSyscallsRate = 0;
+    ioCharactersActuallyReadRate = 0;
+    ioCharactersActuallyWrittenRate = 0;
+
+    changes = Process::Nothing;
+}
+void KSysGuard::Process::setLogin(QString _login) {
+    if(login == _login) return;
+    login = _login;
+    changes |= Process::Login;
+}
+void KSysGuard::Process::setUid(qlonglong _uid) {
+    if(uid == _uid) return;
+    uid = _uid;
+    changes |= Process::Uids;
+}
+void KSysGuard::Process::setEuid(qlonglong _euid) {
+    if(euid == _euid) return;
+    euid = _euid;
+    changes |= Process::Uids;
+}
+void KSysGuard::Process::setSuid(qlonglong _suid) {
+    if(suid == _suid) return;
+    suid = _suid;
+    changes |= Process::Uids;
+}
+void KSysGuard::Process::setFsuid(qlonglong _fsuid) {
+    if(fsuid == _fsuid) return;
+    fsuid = _fsuid;
+    changes |= Process::Uids;
+}
+
+void KSysGuard::Process::setGid(qlonglong _gid) {
+    if(gid == _gid) return;
+    gid = _gid;
+    changes |= Process::Gids;
+}
+void KSysGuard::Process::setEgid(qlonglong _egid) {
+    if(egid == _egid) return;
+    egid = _egid;
+    changes |= Process::Gids;
+}
+void KSysGuard::Process::setSgid(qlonglong _sgid) {
+    if(sgid == _sgid) return;
+    sgid = _sgid;
+    changes |= Process::Gids;
+}
+void KSysGuard::Process::setFsgid(qlonglong _fsgid) {
+    if(fsgid == _fsgid) return;
+    fsgid = _fsgid;
+    changes |= Process::Gids;
+}
+
+void KSysGuard::Process::setTracerpid(qlonglong _tracerpid) {
+    if(tracerpid == _tracerpid) return;
+    tracerpid = _tracerpid;
+    changes |= Process::Tracerpid;
+}
+void KSysGuard::Process::setTty(QByteArray _tty) {
+    if(tty == _tty) return;
+    tty = _tty;
+    changes |= Process::Tty;
+}
+void KSysGuard::Process::setUserTime(qlonglong _userTime) {
+    userTime = _userTime;
+}
+void KSysGuard::Process::setSysTime(qlonglong _sysTime) {
+    sysTime = _sysTime;
+}
+void KSysGuard::Process::setUserUsage(int _userUsage) {
+    if(userUsage == _userUsage) return;
+    userUsage = _userUsage;
+    changes |= Process::Usage;
+}
+void KSysGuard::Process::setSysUsage(int _sysUsage) {
+    if(sysUsage == _sysUsage) return;
+    sysUsage = _sysUsage;
+    changes |= Process::Usage;
+}
+void KSysGuard::Process::setTotalUserUsage(int _totalUserUsage) {
+    if(totalUserUsage == _totalUserUsage) return;
+    totalUserUsage = _totalUserUsage;
+    changes |= Process::TotalUsage;
+}
+void KSysGuard::Process::setTotalSysUsage(int _totalSysUsage) {
+    if(totalSysUsage == _totalSysUsage) return;
+    totalSysUsage = _totalSysUsage;
+    changes |= Process::TotalUsage;
+}
+void KSysGuard::Process::setNiceLevel(int _niceLevel) {
+    if(niceLevel == _niceLevel) return;
+    niceLevel = _niceLevel;
+    changes |= Process::NiceLevels;
+}
+void KSysGuard::Process::setscheduler(Scheduler _scheduler) {
+    if(scheduler == _scheduler) return;
+    scheduler = _scheduler;
+    changes |= Process::NiceLevels;
+}
+void KSysGuard::Process::setIoPriorityClass(IoPriorityClass _ioPriorityClass) {
+    if(ioPriorityClass == _ioPriorityClass) return;
+    ioPriorityClass = _ioPriorityClass;
+    changes |= Process::NiceLevels;
+}
+void KSysGuard::Process::setIoniceLevel(int _ioniceLevel) {
+    if(ioniceLevel == _ioniceLevel) return;
+    ioniceLevel = _ioniceLevel;
+    changes |= Process::NiceLevels;
+}
+void KSysGuard::Process::setVmSize(qlonglong _vmSize) {
+    if(vmSizeChange != 0 || vmSize != 0)
+        vmSizeChange = _vmSize - vmSize;
+    if(vmSize == _vmSize) return;
+    vmSize = _vmSize;
+    changes |= Process::VmSize;
+}
+void KSysGuard::Process::setVmRSS(qlonglong _vmRSS) {
+    if(vmRSSChange != 0 || vmRSS != 0)
+        vmRSSChange = _vmRSS - vmRSS;
+    if(vmRSS == _vmRSS) return;
+    vmRSS = _vmRSS;
+    changes |= Process::VmRSS;
+}
+void KSysGuard::Process::setVmURSS(qlonglong _vmURSS) {
+    if(vmURSSChange != 0 || vmURSS != 0)
+        vmURSSChange = _vmURSS - vmURSS;
+    if(vmURSS == _vmURSS) return;
+    vmURSS = _vmURSS;
+    changes |= Process::VmURSS;
+}
+void KSysGuard::Process::setName(QString _name) {
+    if(name == _name) return;
+    name = _name;
+    changes |= Process::Name;
+}
+void KSysGuard::Process::setCommand(QString _command) {
+    if(command == _command) return;
+    command = _command;
+    changes |= Process::Command;
+}
+void KSysGuard::Process::setStatus(ProcessStatus _status) {
+    if(status == _status) return;
+    status = _status;
+    changes |= Process::Status;
+}
+void KSysGuard::Process::setIoCharactersRead(qlonglong number) {
+    if(number == ioCharactersRead) return;
+    ioCharactersRead = number;
+    changes |= Process::IO;
+}
+void KSysGuard::Process::setIoCharactersWritten(qlonglong number) {
+    if(number == ioCharactersWritten) return;
+    ioCharactersWritten = number;
+    changes |= Process::IO;
+}
+void KSysGuard::Process::setIoReadSyscalls(qlonglong number) {
+    if(number == ioReadSyscalls) return;
+    ioReadSyscalls = number;
+    changes |= Process::IO;
+}
+void KSysGuard::Process::setIoWriteSyscalls(qlonglong number) {
+    if(number == ioWriteSyscalls) return;
+    ioWriteSyscalls = number;
+    changes |= Process::IO;
+}
+void KSysGuard::Process::setIoCharactersActuallyRead(qlonglong number) {
+    if(number == ioCharactersActuallyRead) return;
+    ioCharactersActuallyRead = number;
+    changes |= Process::IO;
+}
+void KSysGuard::Process::setIoCharactersActuallyWritten(qlonglong number) {
+    if(number == ioCharactersActuallyWritten) return;
+    ioCharactersActuallyWritten = number;
+    changes |= Process::IO;
+}
+void KSysGuard::Process::setIoCharactersReadRate(long number) {
+    if(number == ioCharactersReadRate) return;
+    ioCharactersReadRate = number;
+    changes |= Process::IO;
+}
+void KSysGuard::Process::setIoCharactersWrittenRate(long number) {
+    if(number == ioCharactersWrittenRate) return;
+    ioCharactersWrittenRate = number;
+    changes |= Process::IO;
+}
+void KSysGuard::Process::setIoReadSyscallsRate(long number) {
+    if(number == ioReadSyscallsRate) return;
+    ioReadSyscallsRate = number;
+    changes |= Process::IO;
+}
+void KSysGuard::Process::setIoWriteSyscallsRate(long number) {
+    if(number == ioWriteSyscallsRate) return;
+    ioWriteSyscallsRate = number;
+    changes |= Process::IO;
+}
+void KSysGuard::Process::setIoCharactersActuallyReadRate(long number) {
+    if(number == ioCharactersActuallyReadRate) return;
+    ioCharactersActuallyReadRate = number;
+    changes |= Process::IO;
+}
+void KSysGuard::Process::setIoCharactersActuallyWrittenRate(long number) {
+    if(number == ioCharactersActuallyWrittenRate) return;
+    ioCharactersActuallyWrittenRate = number;
+    changes |= Process::IO;
+}
+void KSysGuard::Process::setNumThreads(int number) {
+    if(number == numThreads) return;
+    numThreads = number;
+    changes |= Process::NumThreads;
+}
+
diff --git a/debuggers/gdb/ksysguard/process.h b/debuggers/gdb/ksysguard/process.h
new file mode 100644
index 0000000..940765e
--- /dev/null
+++ b/debuggers/gdb/ksysguard/process.h
@@ -0,0 +1,208 @@
+/*  This file is part of the KDE project
+
+    Copyright (C) 2007 John Tapsell <tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef PROCESS_H_
+#define PROCESS_H_
+
+#include <kdemacros.h>
+
+#include <QtCore/QList>
+#include <QtCore/QTime>
+#include <QtCore/QFlags>
+
+#include <klocale.h>
+
+namespace KSysGuard
+{
+
+  class KDE_EXPORT Process {
+    public:
+    enum ProcessStatus { Running, Sleeping, DiskSleep, Zombie, Stopped, Paging, Ended, OtherStatus=99 };
+    enum IoPriorityClass { None, RealTime, BestEffort, Idle };
+    enum Scheduler { Other = 0, Fifo, RoundRobin, Batch, SchedulerIdle, Interactive }; ///< Interactive is Solaris only
+    Process();
+    Process(qlonglong _pid, qlonglong _ppid, Process *_parent);
+
+    long pid;    ///< The system's ID for this process.  1 for init.  -1 for our virtual 'parent of init' process used just for convenience.
+    long parent_pid;  ///< The system's ID for the parent of this process.  Set to -1 if it has no parent (e.g. 'init' on Linux).
+
+    /** A guaranteed NON-NULL pointer for all real processes to the parent process except for the fake process with pid -1.
+     *  The Parent's pid is the same value as the parent_pid.  The parent process will be also pointed
+     *  to by ProcessModel::mPidToProcess to there is no need to worry about mem management in using parent.
+     *  For process without a parent (such as 'init' on Linux, parent will point to a (fake) process with pid -1 to simplify things.
+     *  For the fake process, this will point to NULL
+     */
+    Process *parent;
+
+    void setNumThreads(int number); ///< The number of threads that this process has, including this process.
+    void setLogin(QString login); ///< The user login name.  Only used for processes on remote machines.  Otherwise use uid to get the name
+    void setUid(qlonglong uid); ///< The user id that the process is running as
+    void setEuid(qlonglong euid); ///< The effective user id that the process is running as
+    void setSuid(qlonglong suid); ///< The set user id that the process is running as
+    void setFsuid(qlonglong fsuid); ///< The file system user id that the process is running as.
+
+    void setGid(qlonglong gid); ///< The process group id that the process is running as
+    void setEgid(qlonglong egid); ///< The effective group id that the process is running as
+    void setSgid(qlonglong sgid); ///< The set group id that the process is running as
+    void setFsgid(qlonglong fsgid); ///< The file system group id that the process is running as
+
+    void setTracerpid(qlonglong tracerpid); ///< If this is being debugged, this is the process that is debugging it, or 0 otherwise
+    void setTty(QByteArray tty); ///< The name of the tty the process owns
+    void setUserTime(qlonglong userTime); ///< The time, in 100ths of a second, spent in total on user calls. -1 if not known
+    void setSysTime(qlonglong sysTime);  ///< The time, in 100ths of a second, spent in total on system calls.  -1 if not known
+    void setUserUsage(int userUsage); ///< Percentage (0 to 100).  It might be more than 100% on multiple cpu core systems
+    void setSysUsage(int sysUsage);  ///< Percentage (0 to 100).  It might be more than 100% on multiple cpu core systems
+    void setTotalUserUsage(int totalUserUsage); ///< Percentage (0 to 100) from the sum of itself and all its children recursively.  If there's no children, it's equal to userUsage.  It might be more than 100% on multiple cpu core systems
+    void setTotalSysUsage(int totalSysUsage); ///< Percentage (0 to 100) from the sum of itself and all its children recursively. If there's no children, it's equal to sysUsage. It might be more than 100% on multiple cpu core systems
+    void setNiceLevel(int niceLevel);      ///< If Scheduler = Other, niceLevel is the niceness (-20 to 20) of this process.  A lower number means a higher priority.  Otherwise sched priority (1 to 99)
+    void setscheduler(Scheduler scheduler); ///< The scheduler this process is running in.  See man sched_getscheduler for more info
+    void setIoPriorityClass(IoPriorityClass ioPriorityClass); ///< The IO priority class.  See man ionice for detailed information.
+    void setIoniceLevel(int ioniceLevel);    ///< IO Niceness (0 to 7) of this process.  A lower number means a higher io priority.  -1 if not known or not applicable because ioPriorityClass is Idle or None
+    void setVmSize(qlonglong vmSize);   ///< Virtual memory size in KiloBytes, including memory used, mmap'ed files, graphics memory etc,
+    void setVmRSS(qlonglong vmRSS);    ///< Physical memory used by the process and its shared libraries.  If the process and libraries are swapped to disk, this could be as low as 0
+    void setVmURSS(qlonglong vmURSS);   ///< Physical memory used only by the process, and not counting the code for shared libraries. Set to -1 if unknown
+    void setName(QString name);  ///< The name (e.g. "ksysguard", "konversation", "init")
+    void setCommand(QString command); ///< The command the process was launched with
+    void setStatus( ProcessStatus status); ///< Whether the process is running/sleeping/etc
+
+    void setIoCharactersRead(qlonglong number); ///< The number of bytes which this task has caused to be read from storage
+    void setIoCharactersWritten(qlonglong number); ///< The number of bytes which this task has caused, or shall cause to be written to disk.
+    void setIoReadSyscalls(qlonglong number); ///< Number of read I/O operations, i.e. syscalls like read() and pread().
+    void setIoWriteSyscalls(qlonglong number); ///< Number of write I/O operations, i.e. syscalls like write() and pwrite().
+    void setIoCharactersActuallyRead(qlonglong number); ///< Number of bytes which this process really did cause to be fetched from the storage layer.
+    void setIoCharactersActuallyWritten(qlonglong number); ///< Attempt to count the number of bytes which this process caused to be sent to the storage layer.
+
+    void setIoCharactersReadRate(long number); ///< The rate, in bytes per second, which this task has caused to be read from storage
+    void setIoCharactersWrittenRate(long number); ///< The rate, in bytes per second, which this task has caused, or shall cause to be written to disk.
+    void setIoReadSyscallsRate(long number); ///< Number of read I/O operations per second, i.e. syscalls like read() and pread().
+    void setIoWriteSyscallsRate(long number); ///< Number of write I/O operations per second, i.e. syscalls like write() and pwrite().
+    void setIoCharactersActuallyReadRate(long number); ///< Number of bytes per second which this process really did cause to be fetched from the storage layer.
+    void setIoCharactersActuallyWrittenRate(long number); ///< Attempt to count the number of bytes per second which this process caused to be sent to the storage layer.
+
+    /* The member variables are made to public for efficiency, but should only be read from. */
+    QString login;
+    qlonglong uid;
+    qlonglong euid;
+    qlonglong suid;
+    qlonglong fsuid;
+
+    qlonglong gid;
+    qlonglong egid;
+    qlonglong sgid;
+    qlonglong fsgid;
+
+    qlonglong tracerpid;
+    QByteArray tty;
+    qlonglong userTime;
+    qlonglong sysTime;
+    int userUsage;
+    int sysUsage;
+    int totalUserUsage;
+    int totalSysUsage;
+    unsigned long numChildren;
+    int niceLevel;
+    Scheduler scheduler;
+    IoPriorityClass ioPriorityClass;
+    int ioniceLevel;
+
+    qlonglong vmSize;
+    qlonglong vmRSS;
+    qlonglong vmURSS;
+
+    qlonglong vmSizeChange; ///< The change in vmSize since last update, in KiB
+    qlonglong vmRSSChange;  ///< The change in vmRSS since last update, in KiB
+    qlonglong vmURSSChange; ///< The change in vmURSS since last update, in KiB
+
+    unsigned long pixmapBytes; ///< The number of bytes used for pixmaps/images and not counted by vmRSS or vmURSS
+    bool hasManagedGuiWindow;
+    QString name;
+    QString command;
+    ProcessStatus status;
+    qlonglong ioCharactersRead;
+    qlonglong ioCharactersWritten;
+    qlonglong ioReadSyscalls;
+    qlonglong ioWriteSyscalls;
+    qlonglong ioCharactersActuallyRead;
+    qlonglong ioCharactersActuallyWritten;
+
+    long ioCharactersReadRate;
+    long ioCharactersWrittenRate;
+    long ioReadSyscallsRate;
+    long ioWriteSyscallsRate;
+    long ioCharactersActuallyReadRate;
+    long ioCharactersActuallyWrittenRate;
+
+    QList<Process *> children;  ///< A list of all the direct children that the process has.  Children of children are not listed here, so note that children_pids <= numChildren
+    QTime timeKillWasSent; ///< This is usually a NULL time.  When trying to kill a process, this is the time that the kill signal was sent to the process.
+
+    QString translatedStatus() const;  ///< Returns a translated string of the status. e.g. "Running" etc
+    QString niceLevelAsString() const; ///< Returns a simple translated string of the nice priority.  e.g. "Normal", "High", etc
+    QString ioniceLevelAsString() const; ///< Returns a simple translated string of the io nice priority.  e.g. "Normal", "High", etc
+    QString ioPriorityClassAsString() const; ///< Returns a translated string of the io nice class.  i.e. "None", "Real Time", "Best Effort", "Idle"
+    QString schedulerAsString() const; ///< Returns a translated string of the scheduler class.  e.g. "FIFO", "Round Robin", "Batch"
+
+    int index;  ///< Each process has a parent process.  Each sibling has a unique number to identify it under that parent.  This is that number.
+
+    /** An enum to keep track of what changed since the last update.  Note that we
+     * the maximum we can use is 0x4000, so some of the enums represent multiple variables
+     */
+    enum Change {
+        Nothing = 0x0,
+        Uids = 0x1,
+        Gids = 0x2,
+        Tracerpid = 0x4,
+        Tty = 0x8,
+        Usage = 0x10,
+        TotalUsage = 0x20,
+        NiceLevels = 0x40,
+        VmSize = 0x80,
+        VmRSS = 0x100,
+        VmURSS = 0x200,
+        Name = 0x400,
+        Command = 0x800,
+        Status = 0x1000,
+        Login = 0x2000,
+        IO = 0x4000,
+        NumThreads = 0x8000
+    };
+    Q_DECLARE_FLAGS(Changes, Change)
+
+    Changes changes;  /**< A QFlags representing what has changed */
+
+    /** This is the number of 1/1000ths of a second since this
+     *  particular process was last updated compared to when all the processes
+     *  were updated. The purpose is to allow a more fine tracking of the time
+     *  a process has been running for.
+     *
+     *  This is updated in processes.cpp and so shouldn't be touched by the
+     *  OS dependant classes.
+     */
+    int elapsedTimeMilliSeconds;
+
+    int numThreads; ///< Number of threads that this process has, including the main one.  0 if not known
+
+  private:
+    void clear();
+
+  };
+  Q_DECLARE_OPERATORS_FOR_FLAGS(Process::Changes)
+}
+
+#endif
diff --git a/debuggers/gdb/ksysguard/processes.cpp b/debuggers/gdb/ksysguard/processes.cpp
new file mode 100644
index 0000000..481c680
--- /dev/null
+++ b/debuggers/gdb/ksysguard/processes.cpp
@@ -0,0 +1,547 @@
+/*  This file is part of the KDE project
+
+    Copyright (C) 2007 John Tapsell <tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include "processes.h"
+#include "processes_base_p.h"
+#include "processes_local_p.h"
+#include "processes_remote_p.h"
+#include "processes_atop_p.h"
+#include "process.h"
+
+#include <klocale.h>
+#include <kglobal.h>
+#include <kdebug.h>
+
+#include <QHash>
+#include <QSet>
+#include <QMutableSetIterator>
+#include <QByteArray>
+
+//for sysconf
+#include <unistd.h>
+
+/* if porting to an OS without signal.h  please #define SIGTERM to something */
+#include <signal.h>
+
+
+namespace KSysGuard
+{
+  class Processes::Private
+  {
+    public:
+      Private(Processes *q_ptr) {
+        mFakeProcess.parent = &mFakeProcess;
+        mAbstractProcesses = 0;
+        mHistoricProcesses = 0;
+        mIsLocalHost = true;
+        mProcesses.insert(-1, &mFakeProcess);
+        mElapsedTimeMilliSeconds = 0;
+        mHavePreviousIoValues = false;
+        mUpdateFlags = 0;
+        mUsingHistoricalData = false;
+        q = q_ptr;
+    }
+      ~Private();
+      void markProcessesAsEnded(long pid);
+
+      QSet<long> mToBeProcessed;
+      QSet<long> mProcessedLastTime;
+      QSet<long> mEndedProcesses; ///< Processes that have finished
+
+      QHash<long, Process *> mProcesses; ///< This must include mFakeProcess at pid -1
+      QList<Process *> mListProcesses;   ///< A list of the processes.  Does not include mFakeProcesses
+      Process mFakeProcess; ///< A fake process with pid -1 just so that even init points to a parent
+
+      AbstractProcesses *mAbstractProcesses; ///< The OS specific code to get the process information
+      ProcessesATop *mHistoricProcesses; ///< A way to get historic information about processes
+      bool mIsLocalHost; ///< Whether this is localhost or not
+
+      QTime mLastUpdated; ///< This is the time we last updated.  Used to calculate cpu usage.
+      long mElapsedTimeMilliSeconds; ///< The number of milliseconds  (1000ths of a second) that passed since the last update
+
+      Processes::UpdateFlags mUpdateFlags;
+      bool mHavePreviousIoValues; ///< This is whether we updated the IO value on the last update
+      bool mUsingHistoricalData; ///< Whether to return historical data for updateProcess() etc
+      Processes *q;
+  };
+
+Processes::Private::~Private() {
+  Q_FOREACH(Process *process, mProcesses) {
+    if(process != &mFakeProcess)
+      delete process;
+  }
+  mProcesses.clear();
+  mListProcesses.clear();
+  delete mAbstractProcesses;
+  mAbstractProcesses = NULL;
+}
+
+Processes::Processes(const QString &host, QObject *parent) : QObject(parent), d(new Private(this))
+{
+    KGlobal::locale()->insertCatalog("processcore");  //Make sure we include the translation stuff.  This needs to be run before any i18n call here
+    if(host.isEmpty()) {
+        d->mAbstractProcesses = new ProcessesLocal();
+    } else {
+        ProcessesRemote *remote = new ProcessesRemote(host);
+        d->mAbstractProcesses = remote;
+        connect(remote, SIGNAL(runCommand(QString,int)), this, SIGNAL(runCommand(QString,int)));
+    }
+    d->mIsLocalHost = host.isEmpty();
+    connect( d->mAbstractProcesses, SIGNAL(processesUpdated()), SLOT(processesUpdated()));
+}
+Processes::~Processes()
+{
+    delete d;
+}
+
+Processes::Error Processes::lastError() const
+{
+    return d->mAbstractProcesses->errorCode;
+}
+Process *Processes::getProcess(long pid) const
+{
+    return d->mProcesses.value(pid);
+}
+
+const QList<Process *> &Processes::getAllProcesses() const
+{
+    return d->mListProcesses;
+}
+
+int Processes::processCount() const
+{
+    return d->mListProcesses.count();
+}
+
+bool Processes::updateProcess( Process *ps, long ppid)
+{
+    Process *parent = d->mProcesses.value(ppid, &d->mFakeProcess);
+    Q_ASSERT(parent);  //even init has a non-null parent - the mFakeProcess
+
+    if(ps->parent != parent) {
+        emit beginMoveProcess(ps, parent/*new parent*/);
+        //Processes has been reparented
+        Process *p = ps;
+        do {
+            p = p->parent;
+            p->numChildren--;
+        } while (p->pid!= -1);
+        Q_ASSERT(ps != parent);
+        ps->parent->children.removeAll(ps);
+        ps->parent = parent;  //the parent has changed
+        parent->children.append(ps);
+        p = ps;
+        do {
+            p = p->parent;
+            p->numChildren++;
+        } while (p->pid!= -1);
+        emit endMoveProcess();
+        Q_ASSERT(ps != parent);
+        ps->parent = parent;
+    }
+
+    ps->parent_pid = ppid;
+
+    bool success = updateProcessInfo(ps);
+    emit processChanged(ps, false);
+
+    return success;
+}
+
+bool Processes::updateProcessInfo(Process *ps) {
+    //Now we can actually get the process info
+    qlonglong oldUserTime = ps->userTime;
+    qlonglong oldSysTime = ps->sysTime;
+
+    qlonglong oldIoCharactersRead = 0;
+    qlonglong oldIoCharactersWritten = 0;
+    qlonglong oldIoReadSyscalls = 0;
+    qlonglong oldIoWriteSyscalls = 0;
+    qlonglong oldIoCharactersActuallyRead = 0;
+    qlonglong oldIoCharactersActuallyWritten = 0;
+
+    if(d->mUpdateFlags.testFlag(Processes::IOStatistics)) {
+        oldIoCharactersRead = ps->ioCharactersRead;
+        oldIoCharactersWritten = ps->ioCharactersWritten;
+        oldIoReadSyscalls = ps->ioReadSyscalls;
+        oldIoWriteSyscalls = ps->ioWriteSyscalls;
+        oldIoCharactersActuallyRead = ps->ioCharactersActuallyRead;
+        oldIoCharactersActuallyWritten = ps->ioCharactersActuallyWritten;
+    }
+
+    ps->changes = Process::Nothing;
+    bool success;
+    if(d->mUsingHistoricalData)
+        success = d->mHistoricProcesses->updateProcessInfo(ps->pid, ps);
+    else
+        success = d->mAbstractProcesses->updateProcessInfo(ps->pid, ps);
+
+    //Now we have the process info.  Calculate the cpu usage and total cpu usage for itself and all its parents
+    if(!d->mUsingHistoricalData && d->mElapsedTimeMilliSeconds != 0) {  //Update the user usage and sys usage
+#ifndef Q_OS_NETBSD
+        /* The elapsed time is the d->mElapsedTimeMilliSeconds
+         * (which is of the order 2 seconds or so) plus a small
+         * correction where we get the amount of time elapsed since
+         * we start processing. This is because the processing itself
+         * can take a non-trivial amount of time.  */
+        int elapsedTime = ps->elapsedTimeMilliSeconds;
+        ps->elapsedTimeMilliSeconds = d->mLastUpdated.elapsed();
+        elapsedTime = ps->elapsedTimeMilliSeconds - elapsedTime + d->mElapsedTimeMilliSeconds;
+        if(elapsedTime) {
+            ps->setUserUsage((int)(((ps->userTime - oldUserTime)*1000.0) / elapsedTime));
+            ps->setSysUsage((int)(((ps->sysTime - oldSysTime)*1000.0) / elapsedTime));
+        }
+#endif
+        if(d->mUpdateFlags.testFlag(Processes::IOStatistics)) {
+            if( d->mHavePreviousIoValues ) {
+                ps->setIoCharactersReadRate((ps->ioCharactersRead - oldIoCharactersRead) * 1000.0 / elapsedTime);
+                ps->setIoCharactersWrittenRate((ps->ioCharactersWritten - oldIoCharactersWritten) * 1000.0 / elapsedTime);
+                ps->setIoReadSyscallsRate((ps->ioReadSyscalls - oldIoReadSyscalls) * 1000.0 / elapsedTime);
+                ps->setIoWriteSyscallsRate((ps->ioWriteSyscalls - oldIoWriteSyscalls) * 1000.0 / elapsedTime);
+                ps->setIoCharactersActuallyReadRate((ps->ioCharactersActuallyRead - oldIoCharactersActuallyRead) * 1000.0 / elapsedTime);
+                ps->setIoCharactersActuallyWrittenRate((ps->ioCharactersActuallyWritten - oldIoCharactersActuallyWritten) * 1000.0 / elapsedTime);
+            } else
+                d->mHavePreviousIoValues = true;
+        } else if(d->mHavePreviousIoValues) {
+            d->mHavePreviousIoValues = false;
+            ps->setIoCharactersReadRate(0);
+            ps->setIoCharactersWrittenRate(0);
+            ps->setIoReadSyscallsRate(0);
+            ps->setIoWriteSyscallsRate(0);
+            ps->setIoCharactersActuallyReadRate(0);
+            ps->setIoCharactersActuallyWrittenRate(0);
+        }
+    }
+    if(d->mUsingHistoricalData || d->mElapsedTimeMilliSeconds != 0) {
+        ps->setTotalUserUsage(ps->userUsage);
+        ps->setTotalSysUsage(ps->sysUsage);
+        if(ps->userUsage != 0 || ps->sysUsage != 0) {
+            Process *p = ps->parent;
+            while(p->pid != -1) {
+                p->totalUserUsage += ps->userUsage;
+                p->totalSysUsage += ps->sysUsage;
+                emit processChanged(p, true);
+                p = p->parent;
+            }
+        }
+    }
+
+    return success;
+}
+
+bool Processes::addProcess(long pid, long ppid)
+{
+    Process *parent = d->mProcesses.value(ppid);
+    if(!parent) {
+        //Under race conditions, the parent could have already quit
+        //In this case, attach to top leaf
+        parent = &d->mFakeProcess;
+        Q_ASSERT(parent);  //even init has a non-null parent - the mFakeProcess
+    }
+    //it's a new process - we need to set it up
+    Process *ps = new Process(pid, ppid, parent);
+
+    emit beginAddProcess(ps);
+
+    d->mProcesses.insert(pid, ps);
+
+    ps->index = d->mListProcesses.count();
+    d->mListProcesses.append(ps);
+
+    ps->parent->children.append(ps);
+    Process *p = ps;
+    do {
+        Q_ASSERT(p);
+        p = p->parent;
+        p->numChildren++;
+    } while (p->pid != -1);
+    ps->parent_pid = ppid;
+
+    //Now we can actually get the process info
+    bool success = updateProcessInfo(ps);
+    emit endAddProcess();
+    return success;
+
+}
+bool Processes::updateOrAddProcess( long pid)
+{
+    long ppid;
+    if(d->mUsingHistoricalData)
+        ppid = d->mHistoricProcesses->getParentPid(pid);
+    else
+        ppid = d->mAbstractProcesses->getParentPid(pid);
+
+    if (ppid == pid) //Shouldn't ever happen
+        ppid = -1;
+
+    if(d->mToBeProcessed.contains(ppid)) {
+        //Make sure that we update the parent before we update this one.  Just makes things a bit easier.
+        d->mToBeProcessed.remove(ppid);
+        d->mProcessedLastTime.remove(ppid); //It may or may not be here - remove it if it is there
+        updateOrAddProcess(ppid);
+    }
+
+    Process *ps = d->mProcesses.value(pid);
+    if(!ps)
+        return addProcess(pid, ppid);
+    else
+        return updateProcess(ps, ppid);
+}
+
+void Processes::updateAllProcesses(long updateDurationMS, Processes::UpdateFlags updateFlags)
+{
+    d->mUpdateFlags = updateFlags;
+
+    if(d->mUsingHistoricalData || d->mLastUpdated.elapsed() >= updateDurationMS || !d->mLastUpdated.isValid())  {
+        d->mElapsedTimeMilliSeconds = d->mLastUpdated.restart();
+        if(d->mUsingHistoricalData)
+            d->mHistoricProcesses->updateAllProcesses(d->mUpdateFlags);
+        else
+            d->mAbstractProcesses->updateAllProcesses(d->mUpdateFlags);  //For a local machine, this will directly call Processes::processesUpdated()
+    }
+}
+
+void Processes::processesUpdated() {
+    //First really delete any processes that ended last time
+    long pid;
+    {
+        QSetIterator<long> i(d->mEndedProcesses);
+        while( i.hasNext() ) {
+            pid = i.next();
+            deleteProcess(pid);
+        }
+    }
+
+    if(d->mUsingHistoricalData)
+        d->mToBeProcessed = d->mHistoricProcesses->getAllPids();
+    else
+        d->mToBeProcessed = d->mAbstractProcesses->getAllPids();
+
+
+    QSet<long> beingProcessed(d->mToBeProcessed); //keep a copy so that we can replace mProcessedLastTime with this at the end of this function
+
+    {
+        QMutableSetIterator<long> i(d->mToBeProcessed);
+        while( i.hasNext()) {
+            pid = i.next();
+            i.remove();
+            d->mProcessedLastTime.remove(pid); //It may or may not be here - remove it if it is there
+            updateOrAddProcess(pid);  //This adds the process or changes an existing one
+            i.toFront(); //we can remove entries from this set elsewhere, so our iterator might be invalid.  Reset it back to the start of the set
+        }
+    }
+    {
+        QSetIterator<long> i(d->mProcessedLastTime);
+        while( i.hasNext()) {
+            //We saw these pids last time, but not this time.  That means we have to mark them for deletion now
+            pid = i.next();
+            d->markProcessesAsEnded(pid);
+        }
+        d->mEndedProcesses = d->mProcessedLastTime;
+    }
+
+    d->mProcessedLastTime = beingProcessed;  //update the set for next time this function is called
+    return;
+}
+
+void Processes::Private::markProcessesAsEnded(long pid)
+{
+    Q_ASSERT(pid >= 0);
+
+    Process *process = mProcesses.value(pid);
+    if(!process)
+        return;
+    process->status = Process::Ended;
+    emit q->processChanged(process, false);
+}
+void Processes::deleteProcess(long pid)
+{
+    Q_ASSERT(pid >= 0);
+
+    Process *process = d->mProcesses.value(pid);
+    if(!process)
+        return;
+    Q_FOREACH( Process *it, process->children) {
+        d->mProcessedLastTime.remove(it->pid);
+        deleteProcess(it->pid);
+    }
+
+    emit beginRemoveProcess(process);
+
+    d->mProcesses.remove(pid);
+    d->mListProcesses.removeAll(process);
+    process->parent->children.removeAll(process);
+    Process *p = process;
+    do {
+        Q_ASSERT(p);
+        p = p->parent;
+        p->numChildren--;
+    } while (p->pid != -1);
+#ifndef QT_NO_DEBUG
+    int i = 0;
+#endif
+    Q_FOREACH( Process *it, d->mListProcesses ) {
+        if(it->index > process->index)
+            it->index--;
+        Q_ASSERT(it->index == i++);
+    }
+
+    delete process;
+    emit endRemoveProcess();
+}
+
+
+bool Processes::killProcess(long pid) {
+    return sendSignal(pid, SIGTERM);
+}
+
+bool Processes::sendSignal(long pid, int sig) {
+    d->mAbstractProcesses->errorCode = Unknown;
+    if(d->mUsingHistoricalData) {
+        d->mAbstractProcesses->errorCode = NotSupported;
+        return false;
+    }
+    return d->mAbstractProcesses->sendSignal(pid, sig);
+}
+
+bool Processes::setNiceness(long pid, int priority) {
+    d->mAbstractProcesses->errorCode = Unknown;
+    if(d->mUsingHistoricalData) {
+        d->mAbstractProcesses->errorCode = NotSupported;
+        return false;
+    }
+    return d->mAbstractProcesses->setNiceness(pid, priority);
+}
+
+bool Processes::setScheduler(long pid, KSysGuard::Process::Scheduler priorityClass, int priority) {
+    d->mAbstractProcesses->errorCode = Unknown;
+    if(d->mUsingHistoricalData) {
+        d->mAbstractProcesses->errorCode = NotSupported;
+        return false;
+    }
+    return d->mAbstractProcesses->setScheduler(pid, priorityClass, priority);
+}
+
+bool Processes::setIoNiceness(long pid, KSysGuard::Process::IoPriorityClass priorityClass, int priority) {
+    d->mAbstractProcesses->errorCode = Unknown;
+    if(d->mUsingHistoricalData) {
+        d->mAbstractProcesses->errorCode = NotSupported;
+        return false;
+    }
+    return d->mAbstractProcesses->setIoNiceness(pid, priorityClass, priority);
+}
+
+bool Processes::supportsIoNiceness() {
+    if(d->mUsingHistoricalData)
+        return false;
+    return d->mAbstractProcesses->supportsIoNiceness();
+}
+
+long long Processes::totalPhysicalMemory() {
+    return d->mAbstractProcesses->totalPhysicalMemory();
+}
+
+long Processes::numberProcessorCores() {
+    return d->mAbstractProcesses->numberProcessorCores();
+}
+
+void Processes::answerReceived( int id, const QList<QByteArray>& answer ) {
+    KSysGuard::ProcessesRemote *processes = qobject_cast<KSysGuard::ProcessesRemote *>(d->mAbstractProcesses);
+    if(processes)
+        processes->answerReceived(id, answer);
+}
+
+QList< QPair<QDateTime,uint> > Processes::historiesAvailable() const
+{
+    if(!d->mIsLocalHost)
+        return QList< QPair<QDateTime,uint> >();
+    if(!d->mHistoricProcesses)
+        d->mHistoricProcesses = new ProcessesATop();
+
+    return d->mHistoricProcesses->historiesAvailable();
+}
+
+void Processes::useCurrentData()
+{
+    if(d->mUsingHistoricalData) {
+        delete d->mHistoricProcesses;
+        d->mHistoricProcesses = NULL;
+        connect( d->mAbstractProcesses, SIGNAL(processesUpdated()), SLOT(processesUpdated()));
+        d->mUsingHistoricalData = false;
+    }
+}
+
+bool Processes::setViewingTime(const QDateTime &when)
+{
+    d->mAbstractProcesses->errorCode = Unknown;
+    if(!d->mIsLocalHost) {
+        d->mAbstractProcesses->errorCode = NotSupported;
+        return false;
+    }
+    if(!d->mUsingHistoricalData) {
+        if(!d->mHistoricProcesses)
+            d->mHistoricProcesses = new ProcessesATop();
+        disconnect( d->mAbstractProcesses, SIGNAL(processesUpdated()), this, SLOT(processesUpdated()));
+        connect( d->mHistoricProcesses, SIGNAL(processesUpdated()), SLOT(processesUpdated()));
+        d->mUsingHistoricalData = true;
+    }
+    return d->mHistoricProcesses->setViewingTime(when);
+}
+
+bool Processes::loadHistoryFile(const QString &filename)
+{
+    d->mAbstractProcesses->errorCode = Unknown;
+    if(!d->mIsLocalHost) {
+        d->mAbstractProcesses->errorCode = NotSupported;
+        return false;
+    }
+    if(!d->mHistoricProcesses)
+        d->mHistoricProcesses = new ProcessesATop(false);
+
+    return d->mHistoricProcesses->loadHistoryFile(filename);
+}
+
+QString Processes::historyFileName() const
+{
+    if(!d->mIsLocalHost || !d->mHistoricProcesses)
+        return QString::null;
+    return d->mHistoricProcesses->historyFileName();
+}
+QDateTime Processes::viewingTime() const
+{
+    if(!d->mIsLocalHost || !d->mHistoricProcesses)
+        return QDateTime();
+    return d->mHistoricProcesses->viewingTime();
+}
+
+bool Processes::isHistoryAvailable() const
+{
+    if(!d->mIsLocalHost)
+        return false;
+    if(!d->mHistoricProcesses)
+        d->mHistoricProcesses = new ProcessesATop();
+
+    return d->mHistoricProcesses->isHistoryAvailable();
+}
+
+}
+#include "processes.moc"
+
diff --git a/debuggers/gdb/ksysguard/processes.h b/debuggers/gdb/ksysguard/processes.h
new file mode 100644
index 0000000..e9546b2
--- /dev/null
+++ b/debuggers/gdb/ksysguard/processes.h
@@ -0,0 +1,270 @@
+/*  This file is part of the KDE project
+
+    Copyright (C) 2007 John Tapsell <tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef PROCESSES_H_
+#define PROCESSES_H_
+
+#include <kdemacros.h>
+
+#include "process.h"
+#include <QtCore/QHash>
+
+namespace KSysGuard
+{
+    class AbstractProcesses;
+    /**
+     * This class retrieves the processes currently running in an OS independent way.
+     *
+     * To use, do something like:
+     *
+     * \code
+     *   #include <ksysguard/processes.h>
+     *   #include <ksysguard/process.h>
+     *
+     *   KSysGuard::Processes *processes = new KSysGuard::Processes()
+     *   QHash<long, Process *> processlist = processes->getProcesses();
+     *   foreach( Process * process, processlist) {
+     *     kDebug() << "Process with pid " << process->pid << " is called " << process->name;
+     *   }
+     *   delete processes;
+     *   processes = NULL;
+     * \endcode
+     *
+     * @author John Tapsell <tapsell@kde.org>
+     */
+#ifdef Q_WS_WIN
+    class Processes : public QObject
+#else
+    class KDE_EXPORT Processes : public QObject
+#endif
+    {
+        Q_OBJECT
+
+    public:
+
+        Processes(const QString &hostname = QString::null, QObject * parent = 0);
+        virtual ~Processes();
+        enum UpdateFlag {
+            StandardInformation = 1,
+            IOStatistics = 2,
+            XMemory = 4
+        };
+        Q_DECLARE_FLAGS(UpdateFlags, UpdateFlag)
+
+        enum Error {
+            Unknown = 0,
+            InvalidPid,
+            InvalidParameter,
+            InsufficientPermissions,
+            ProcessDoesNotExistOrZombie,
+            NotSupported
+        };
+
+        /**
+         *  Update all the process information.  After calling this, /proc or equivalent is scanned and
+         *  the signals processChanged, etc  are emitted.
+         *
+         *  Set updateDuration to whatever time period that you update, in milliseconds.
+         *  For example, if you update every 2000ms, set this to 2000.  That way it won't update
+         *  more often than needed.
+         */
+        void updateAllProcesses(long updateDurationMS = 0, Processes::UpdateFlags updateFlags = 0);
+
+        /**
+         *  Return information for one specific process.  Call getProcess(0) to get the
+         *  fake process used as the top most parent for all processes.
+         *  This doesn't fetch any new information and so returns almost instantly.
+         *  Call updateAllProcesses() to actually fetch the process information.
+         */
+        Process *getProcess(long pid) const;
+
+        /**
+         *  Get the error code for the last command that failed.
+         */
+        Error lastError() const;
+
+        /**
+         *  Kill the specified process.  You may not have the privilege to kill the process.
+         *  The process may also chose to ignore the command.  Send the SIGKILL signal to kill
+         *  the process immediately.  You may lose any unsaved data.
+         *
+         *  @returns Successful or not in killing the process
+         */
+        bool killProcess(long pid);
+
+        /**
+         *  Send the specified named POSIX signal to the process given.
+         *
+         *  For example, to indicate for process 324 to STOP do:
+         *  \code
+         *    #include <signals.h>
+         *     ...
+         *
+         *    KSysGuard::Processes::sendSignal(23, SIGSTOP);
+         *  \endcode
+         *
+         */
+        bool sendSignal(long pid, int sig);
+
+        /**
+         *  Set the priority for a process.  This is from 19 (very nice, lowest priority) to
+         *    -20 (highest priority).  The default value for a process is 0.
+         *
+         *  @return false if you do not have permission to set the priority
+         */
+        bool setNiceness(long pid, int priority);
+
+        /**
+         *  Set the scheduler for a process.  This is defined according to POSIX.1-2001
+         *  See "man sched_setscheduler" for more information.
+         *
+         *  @p priorityClass One of SCHED_FIFO, SCHED_RR, SCHED_OTHER, and SCHED_BATCH
+         *  @p priority Set to 0 for SCHED_OTHER and SCHED_BATCH.  Between 1 and 99 for SCHED_FIFO and SCHED_RR
+         *  @return false if you do not have permission to set the priority
+         */
+        bool setScheduler(long pid, KSysGuard::Process::Scheduler priorityClass, int priority);
+
+        /**
+         *  Set the io priority for a process.  This is from 7 (very nice, lowest io priority) to
+         *  0 (highest priority).  The default value is determined as: io_nice = (cpu_nice + 20) / 5.
+         *
+         *  @return false if you do not have permission to set the priority
+         */
+        bool setIoNiceness(long pid, KSysGuard::Process::IoPriorityClass priorityClass, int priority);
+
+        /**
+         *  Returns true if ionice is supported on this system
+         */
+        bool supportsIoNiceness();
+
+        /**
+         *  Return the internal pointer of all the processes.  The order of the processes
+         *  is guaranteed to never change.  Call updateAllProcesses() first to actually
+         *  update the information.
+         */
+        const QList< Process *> &getAllProcesses() const;
+
+        /**
+         *  Return the number of processes.  Call updateAllProcesses() to actually
+         *  update the information.
+         *
+         *  This is equivalent to getAllProcesses().count()
+         */
+        int processCount() const;
+
+        /**
+         *  Return the total amount of physical memory in KB.  This is fast (just a system call)
+         *  Returns 0 on error
+         */
+        long long totalPhysicalMemory();
+
+        /**
+         *  Return the number of processor cores enabled.
+         *  (A system can disable processors.  Disabled processors are not counted here).
+         *  This is fast (just a system call) */
+        long numberProcessorCores();
+
+        /** Update/add process for given pid immediately */
+        bool updateOrAddProcess( long pid);
+
+        /** Whether we can get historic process and system data */
+        bool isHistoryAvailable() const;
+
+        /** Stop using historical data and use the most recent up-to-date data */
+        void useCurrentData();
+
+        /** Return a list of end times and intervals for all the available history */
+        QList< QPair<QDateTime, uint> > historiesAvailable() const;
+
+        /** Use historical process data closest to the given date-time.
+         *  Returns false if it is outside the range available or there is a problem
+         *  getting the data. */
+        bool setViewingTime(const QDateTime &when);
+        QDateTime viewingTime() const;
+        bool loadHistoryFile(const QString &filename);
+        QString historyFileName() const;
+        
+    public Q_SLOTS:
+        /** The abstract processes has updated its list of processes */
+        void processesUpdated();
+
+    Q_SIGNALS:
+        /** The data for a process has changed.
+         *  if @p onlyTotalCpu is set, only the total cpu usage has been updated.
+         *  process->changes  contains a bit field indicating what has changed since the last time this was emitted
+         *  for this process
+         */
+        void processChanged( KSysGuard::Process *process, bool onlyTotalCpu);
+
+        /**
+         *  This indicates we are about to add a process in the model.
+         *  The process already has the pid, ppid and tree_parent set up.
+         */
+        void beginAddProcess( KSysGuard::Process *process);
+
+        /**
+         *  We have finished inserting a process
+         */
+        void endAddProcess();
+        /**
+         *  This indicates we are about to remove a process in the model.  Emit the appropriate signals
+         */
+
+        void beginRemoveProcess( KSysGuard::Process *process);
+
+        /**
+         *  We have finished removing a process
+         */
+        void endRemoveProcess();
+
+        /**
+         *  This indicates we are about move a process from one parent to another.
+         */
+        void beginMoveProcess(KSysGuard::Process *process, KSysGuard::Process *new_parent);
+
+        /**
+         *  We have finished moving the process
+         */
+        void endMoveProcess();
+    protected:
+        class Private;
+        Private *d;
+    private:
+        inline void deleteProcess(long pid);
+        bool updateProcess( Process *process, long ppid);
+        bool updateProcessInfo(Process *ps);
+        bool addProcess(long pid, long ppid);
+
+    Q_SIGNALS:
+        /** For a remote machine, we rely on being able to communicate with ksysguardd.
+         *  This must be dealt with by the program including this widget.  It must listen to our
+         *  'runCommand' signal, and run the given command, with the given id. */
+        void runCommand(const QString &command, int id);
+
+    public:
+        /** For a remote machine, we rely on being able to communicate with ksysguardd.
+         *  The programming using this must call this slot when an answer is received from ksysguardd,
+         *  in response to a runCommand request.  The id identifies the answer */
+        void answerReceived( int id, const QList<QByteArray>& answer );
+    };
+    Q_DECLARE_OPERATORS_FOR_FLAGS(Processes::UpdateFlags)
+}
+#endif
diff --git a/debuggers/gdb/ksysguard/processes_atop_p.cpp b/debuggers/gdb/ksysguard/processes_atop_p.cpp
new file mode 100644
index 0000000..369df36
--- /dev/null
+++ b/debuggers/gdb/ksysguard/processes_atop_p.cpp
@@ -0,0 +1,375 @@
+/*  This file is part of the KDE project
+
+    Copyright (C) 2007 John Tapsell <tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include "processes_atop_p.h"
+#include "process.h"
+#include "atop_p.h"
+
+#include <klocale.h>
+#include <zlib.h>
+
+#include <QFile>
+#include <QHash>
+#include <QSet>
+#include <QByteArray>
+#include <QTextStream>
+#include <QtEndian>
+
+#include <QDebug>
+
+namespace KSysGuard
+{
+
+  class ProcessesATop::Private
+  {
+    public:
+      Private();
+      ~Private();
+      QFile atopLog;
+      bool ready;
+
+      bool loadDataForHistory(int index);
+      bool loadHistoryFile(const QString &filename);
+
+      RawHeader    rh;
+      RawRecord    rr;
+//      SStat        sstats;
+      PStat        *pstats;
+      QList<long>  pids; //This is a list of process pid's, in the exact same order as pstats
+      QString lastError;
+
+      QList<long>  historyOffsets; //< The file offset where each history is stored
+      QList< QPair<QDateTime, uint> > historyTimes;  //< The end time for each history record and its interval, probably in order from oldest to newest
+      int currentlySelectedIndex;
+  };
+
+ProcessesATop::Private::Private() :
+    ready(false),
+    pstats(NULL),
+    currentlySelectedIndex(-1)
+{
+}
+
+ProcessesATop::Private::~Private()
+{
+}
+
+QString ProcessesATop::historyFileName() const {
+    return d->atopLog.fileName();
+}
+
+bool ProcessesATop::loadHistoryFile(const QString &filename)
+{
+    return d->loadHistoryFile(filename);
+}
+
+bool ProcessesATop::Private::loadHistoryFile(const QString &filename) {
+    atopLog.setFileName(filename);
+    ready = false;
+    currentlySelectedIndex = -1;
+    if(!atopLog.exists()) {
+        lastError = "File " + filename + " does not exist";
+        return false;
+    }
+
+    if(!atopLog.open(QIODevice::ReadOnly)) {
+        lastError = "Could not open file" + filename;
+        return false;
+    }
+
+    int sizeRead = atopLog.read((char*)(&rh), sizeof(RawHeader));
+    if(sizeRead != sizeof(RawHeader)) {
+        lastError = "Could not read header from file" + filename;
+        return false;
+    }
+    if(rh.magic != ATOPLOGMAGIC) {
+        lastError = "File " + filename + " does not contain raw atop/atopsar output (wrong magic number)";
+        return false;
+    }
+    if (/*rh.sstatlen   != sizeof(SStat)    ||*/
+        rh.pstatlen   != sizeof(PStat)      ||
+        rh.rawheadlen != sizeof(RawHeader)  ||
+        rh.rawreclen  != sizeof(RawRecord)  )
+    {
+        lastError = "File " + filename + " has incompatible format";
+        if (rh.aversion & 0x8000) {
+            lastError = QString("(created by version %1.%2. This program understands the format written by version 1.23")
+                        .arg((rh.aversion >> 8) & 0x7f, rh.aversion & 0xff);
+        }
+        return false;
+    }
+
+
+    /* Read the first data header */
+    int offset = atopLog.pos();
+    historyTimes.clear();
+    historyOffsets.clear();
+    while( !atopLog.atEnd() && atopLog.read((char*)(&rr), sizeof(RawRecord)) == sizeof(RawRecord) ) {
+        historyOffsets << offset;
+        historyTimes << QPair<QDateTime,uint>(QDateTime::fromTime_t(rr.curtime), rr.interval);
+        offset +=  sizeof(RawRecord) + rr.scomplen + rr.pcomplen;
+        atopLog.seek(offset);
+    }
+    if(currentlySelectedIndex >= historyOffsets.size())
+        currentlySelectedIndex = historyOffsets.size() - 1;
+
+    ready = true;
+    return true;
+}
+
+bool ProcessesATop::Private::loadDataForHistory(int index)
+{
+    delete [] pstats;
+    pstats = NULL;
+    atopLog.seek(historyOffsets.at(index));
+    /*Read the first data header */
+    if( atopLog.read((char*)(&rr), sizeof(RawRecord)) != sizeof(RawRecord) ) {
+        lastError = "Could not read data header";
+        return false;
+    }
+
+    if( historyTimes.at(index).first != QDateTime::fromTime_t(rr.curtime) ||
+           historyTimes.at(index).second != rr.interval) {
+        lastError = "INTERNAL ERROR WITH loadDataForHistory";
+        ready = false;
+        return false;
+    }
+
+    atopLog.seek(atopLog.pos() + rr.scomplen);
+    QByteArray processRecord;
+    processRecord.resize(rr.pcomplen);
+//    qToBigEndian( rr.pcomplen, (uchar*)processRecord.data() );
+    unsigned int dataRead = 0;
+    do {
+        int ret = atopLog.read( processRecord.data() + dataRead, rr.pcomplen - dataRead);
+        if(ret == -1) {
+            lastError = "Stream interrupted while being read";
+            return false;
+        }
+        dataRead += ret;
+    } while(dataRead < rr.pcomplen);
+    Q_ASSERT(dataRead == rr.pcomplen);
+    //Q_ASSERT( (index + 1 ==historyTimes.count()) || atopLog.pos() == historyTimes.at(index+1));
+
+    pstats = new PStat[ rr.nlist ];
+    unsigned long uncompressedLength= sizeof(struct PStat) * rr.nlist;
+    int ret = uncompress((Byte *)pstats, &uncompressedLength, (Byte *)processRecord.constData(), rr.pcomplen);
+    if(ret != Z_OK && ret != Z_STREAM_END && ret != Z_NEED_DICT) {
+        switch(ret) {
+            case Z_MEM_ERROR:
+                lastError = "Could not uncompress record data due to lack of memory";
+                break;
+            case Z_BUF_ERROR:
+                lastError = "Could not uncompress record data due to lack of room in buffer";
+                break;
+            case Z_DATA_ERROR:
+                lastError = "Could not uncompress record data due to corrupted data";
+                break;
+            default:
+                lastError = "Could not uncompress record data due to unexpected error: " + QString::number(ret);
+                break;
+        }
+        delete [] pstats;
+        pstats = NULL;
+        return false;
+    }
+
+    pids.clear();
+    for(uint i = 0; i < rr.nlist; i++) {
+        pids << pstats[i].gen.pid;
+    }
+    return true;
+}
+
+ProcessesATop::ProcessesATop(bool loadDefaultFile) : d(new Private())
+{
+    if(loadDefaultFile)
+        loadHistoryFile("/var/log/atop.log");
+}
+
+bool ProcessesATop::isHistoryAvailable() const
+{
+    return d->ready;
+}
+
+long ProcessesATop::getParentPid(long pid) {
+    int index = d->pids.indexOf(pid);
+    if(index < 0)
+        return 0;
+    return d->pstats[index].gen.ppid;
+}
+
+bool ProcessesATop::updateProcessInfo( long pid, Process *process)
+{
+    int index = d->pids.indexOf(pid);
+    if(index < 0)
+        return false;
+    PStat &p = d->pstats[index];
+    process->parent_pid = p.gen.ppid;
+    process->setUid(p.gen.ruid);
+    process->setEuid(p.gen.ruid);
+    process->setSuid(p.gen.ruid);
+    process->setFsuid(p.gen.ruid);
+    process->setGid(p.gen.rgid);
+    process->setEgid(p.gen.rgid);
+    process->setSgid(p.gen.rgid);
+    process->setFsgid(p.gen.rgid);
+    process->setTracerpid(-1);
+    process->setNumThreads(p.gen.nthr);
+//    process->setTty
+    process->setUserTime(p.cpu.utime * 100/d->rh.hertz);//check - divide by interval maybe?
+    process->setSysTime(p.cpu.stime * 100/d->rh.hertz); //check
+    process->setUserUsage( process->userTime / d->rr.interval );
+    process->setSysUsage( process->sysTime / d->rr.interval );
+    process->setNiceLevel(p.cpu.nice);
+//    process->setscheduler(p.cpu.policy);
+    process->setVmSize(p.mem.vmem);
+    process->setVmRSS(p.mem.rmem);
+    process->vmSizeChange = p.mem.vgrow;
+    process->vmRSSChange = p.mem.rgrow;
+    process->setVmURSS(0);
+    process->vmURSSChange = 0;
+
+    /* Fill in name and command */
+    QString name = QString::fromUtf8(p.gen.name, qstrnlen(p.gen.name,PNAMLEN));
+    QString command = QString::fromUtf8(p.gen.cmdline, qstrnlen(p.gen.cmdline,CMDLEN));
+    //cmdline separates parameters with the NULL character
+    if(!command.isEmpty()) {
+        if(command.startsWith(name)) {
+            int index = command.indexOf(QChar('\0'));
+            name = command.left(index);
+        }
+        command.replace('\0', ' ');
+    }
+    process->setName(name);
+    process->setCommand(command);
+
+
+    /* Fill in state */
+    switch(p.gen.state) {
+        case 'E':
+            process->setStatus(Process::Ended);
+            break;
+        case 'R':
+            process->setStatus(Process::Running);
+            break;
+        case 'S':
+            process->setStatus(Process::Sleeping);
+            break;
+        case 'D':
+            process->setStatus(Process::DiskSleep);
+            break;
+        case 'Z':
+            process->setStatus(Process::Zombie);
+            break;
+        case 'T':
+            process->setStatus(Process::Stopped);
+            break;
+        case 'W':
+            process->setStatus(Process::Paging);
+            break;
+        default:
+            process->setStatus(Process::OtherStatus);
+            break;
+    }
+
+
+    return true;
+}
+QDateTime ProcessesATop::viewingTime() const
+{
+    if(!d->ready)
+        return QDateTime();
+    return d->historyTimes.at(d->currentlySelectedIndex).first; 
+}
+bool ProcessesATop::setViewingTime(const QDateTime &when)
+{
+    QPair<QDateTime, uint> tmpWhen(when, 0);
+    QList< QPair<QDateTime,uint> >::iterator i = qUpperBound(d->historyTimes.begin(), d->historyTimes.end(), tmpWhen);
+
+    if(i->first == when || (i->first > when && i->first.addSecs(-i->second) <= when)) {
+        //We found the time :)
+        d->currentlySelectedIndex = i - d->historyTimes.begin();
+        bool success = d->loadDataForHistory(d->currentlySelectedIndex);
+        if(!success)
+            qWarning() << d->lastError;
+        return success;
+    }
+    return false;
+}
+QList< QPair<QDateTime, uint> > ProcessesATop::historiesAvailable() const
+{
+    return d->historyTimes;
+}
+
+QSet<long> ProcessesATop::getAllPids( )
+{
+    return d->pids.toSet();
+}
+
+bool ProcessesATop::sendSignal(long pid, int sig) {
+    Q_UNUSED(pid);
+    Q_UNUSED(sig);
+
+    errorCode = Processes::NotSupported;
+    return false;
+}
+
+bool ProcessesATop::setNiceness(long pid, int priority) {
+    Q_UNUSED(pid);
+    Q_UNUSED(priority);
+
+    errorCode = Processes::NotSupported;
+    return false;
+}
+
+bool ProcessesATop::setScheduler(long pid, int priorityClass, int priority) {
+    Q_UNUSED(pid);
+    Q_UNUSED(priorityClass);
+    Q_UNUSED(priority);
+
+    errorCode = Processes::NotSupported;
+    return false;
+}
+
+
+bool ProcessesATop::setIoNiceness(long pid, int priorityClass, int priority) {
+    Q_UNUSED(pid);
+    Q_UNUSED(priorityClass);
+    Q_UNUSED(priority);
+
+    errorCode = Processes::NotSupported;
+    return false;
+}
+
+bool ProcessesATop::supportsIoNiceness() {
+    return false;
+}
+
+long long ProcessesATop::totalPhysicalMemory() {
+    return 0;
+}
+ProcessesATop::~ProcessesATop()
+{
+  delete d;
+}
+
+}
diff --git a/debuggers/gdb/ksysguard/processes_atop_p.h b/debuggers/gdb/ksysguard/processes_atop_p.h
new file mode 100644
index 0000000..f975a20
--- /dev/null
+++ b/debuggers/gdb/ksysguard/processes_atop_p.h
@@ -0,0 +1,79 @@
+/*  This file is part of the KDE project
+
+    Copyright (C) 2007 John Tapsell <tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef PROCESSES_ATOP_H_
+#define PROCESSES_ATOP_H_
+
+#include "processes_base_p.h"
+#include <unistd.h>  //For sysconf
+
+
+#include <QSet>
+class QDateTime;
+
+namespace KSysGuard
+{
+    class Process;
+
+    /**
+     * This is the ATOP specific code to get process information for the local host.
+     */
+    class ProcessesATop : public AbstractProcesses {
+        public:
+            ProcessesATop(bool loadDefaultFile = true);
+            virtual ~ProcessesATop();
+            virtual QSet<long> getAllPids();
+            virtual long getParentPid(long pid);
+            virtual bool updateProcessInfo(long pid, Process *process);
+            virtual bool sendSignal(long pid, int sig);
+            virtual bool setNiceness(long pid, int priority);
+            virtual bool setScheduler(long pid, int priorityClass, int priority);
+            virtual long long totalPhysicalMemory();
+            virtual bool setIoNiceness(long pid, int priorityClass, int priority);
+            virtual bool supportsIoNiceness();
+            virtual long numberProcessorCores()
+#ifdef _SC_NPROCESSORS_ONLN
+            { return sysconf(_SC_NPROCESSORS_ONLN); } // Should work on any recent posix system
+#else
+            ;
+#endif
+            virtual void updateAllProcesses(Processes::UpdateFlags updateFlags) { mUpdateFlags = updateFlags; emit processesUpdated(); } //For local machine, there is no delay
+
+            bool isHistoryAvailable() const;
+            QDateTime viewingTime() const;
+            bool setViewingTime(const QDateTime &when);
+            QList< QPair<QDateTime, uint> > historiesAvailable() const;
+            bool loadHistoryFile(const QString &filename);
+            QString historyFileName() const;
+        private:
+            /**
+             * You can use this for whatever data you want.
+             * Be careful about preserving state in between getParentPid and updateProcessInfo calls
+             * if you chose to do that. getParentPid may be called several times
+             * for different pids before the relevant updateProcessInfo calls are made.
+             * This is because the tree structure has to be sorted out first.
+             */
+            class Private;
+            Private *d;
+            Processes::UpdateFlags mUpdateFlags;
+    };
+}
+#endif
diff --git a/debuggers/gdb/ksysguard/processes_base_p.cpp b/debuggers/gdb/ksysguard/processes_base_p.cpp
new file mode 100644
index 0000000..392d9d8
--- /dev/null
+++ b/debuggers/gdb/ksysguard/processes_base_p.cpp
@@ -0,0 +1,22 @@
+/*  This file is part of the KDE project
+
+    Copyright (C) 2007 John Tapsell <tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include "processes_base_p.moc"
diff --git a/debuggers/gdb/ksysguard/processes_base_p.h b/debuggers/gdb/ksysguard/processes_base_p.h
new file mode 100644
index 0000000..71b8a9c
--- /dev/null
+++ b/debuggers/gdb/ksysguard/processes_base_p.h
@@ -0,0 +1,150 @@
+/*  This file is part of the KDE project
+
+    Copyright (C) 2007 John Tapsell <tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef PROCESSES_BASE_P_H
+#define PROCESSES_BASE_P_H
+
+#include <QSet>
+#include <QObject>
+#include "processes.h"
+
+namespace KSysGuard
+{
+    class Process;
+    /**
+     * This class contains the specific code to get the processes from the given host.
+     *
+     * To port this to other operating systems you need to make a processes_(osname).cpp  file
+     * which implements all of the function below.  If you need private functions/variables etc put them in
+     * the Private class.
+     *
+     * @author John Tapsell <tapsell@kde.org>
+     */
+    class AbstractProcesses : public QObject
+    {
+        Q_OBJECT
+
+        public:
+
+            AbstractProcesses() { errorCode = Processes::Unknown; }
+            virtual ~AbstractProcesses() {}
+
+            /** \brief Get a set of the currently running process PIDs.
+             *
+             *  To get information about processes, this will be the first function called.
+             */
+            virtual QSet<long> getAllPids() = 0;
+
+            /** \brief Return the parent PID for the given process PID.
+             *
+             *  For each of the PIDs that getAllPids() returns, getParentPid will be called.
+             *  This is used to setup the tree structure.
+             *  For a particular PID, this is guaranteed to be called before updateProcessInfo for that PID.
+             *  However this may be called several times in a row before the updateProcessInfo is called, so be careful
+             *  if you want to try to preserve state in Private.
+             */
+            virtual long getParentPid(long pid) = 0;
+
+            /** \brief Fill in the given Process class with information for given PID.
+             *
+             *  This will be called for every PID, after getParentPid() has been called for the same parameter.
+             *
+             *  The process->pid process->ppid and process->parent  are all guaranteed
+             *  to be filled in correctly and process->parent will be non null.
+             */
+            virtual bool updateProcessInfo(long pid, Process *process) = 0;
+
+            /** \brief Send the specified named POSIX signal to the process given.
+             *
+             *  For example, to indicate for process 324 to STOP do:
+             *  \code
+             *    #include <signals.h>
+             *     ...
+             *
+             *    KSysGuard::Processes::sendSignal(324, SIGSTOP);
+             *  \endcode
+             *
+             */
+            virtual bool sendSignal(long pid, int sig) = 0;
+
+            /** \brief Set the priority for a process.
+             *
+             *  For the normal scheduler, this is usually from 19
+             *  (very nice, lowest priority) to -20 (highest priority).  The default value for a process is 0.
+             *
+             *  This has no effect if the scheduler is not the normal one (SCHED_OTHER in Linux).
+             *
+             *  @return false if you do not have permission to set the priority.
+             */
+            virtual bool setNiceness(long pid, int priority) = 0;
+
+            /** \brief Set the scheduler for a process.
+             *
+             * This is defined according to POSIX.1-2001
+             *  See "man sched_setscheduler" for more information.
+             *
+             *  @p priorityClass One of SCHED_FIFO, SCHED_RR, SCHED_OTHER, and SCHED_BATCH
+             *  @p priority Set to 0 for SCHED_OTHER and SCHED_BATCH.  Between 1 and 99 for SCHED_FIFO and SCHED_RR
+             *  @return false if you do not have permission to set the priority
+             */
+            virtual bool setScheduler(long pid, int priorityClass, int priority) = 0;
+
+            /** \brief Return the total amount of physical memory in KiB.
+             *
+             *  This is fast (just a system call in most OSes)
+             *  Returns 0 on error
+             */
+            virtual long long totalPhysicalMemory() = 0;
+
+            /** \brief Set the i/o priority for a process.
+             *
+             *  This is from 7 (very nice, lowest i/o priority) to
+             *  0 (highest priority).  The default value is determined as: io_nice = (cpu_nice + 20) / 5.
+             *
+             *  @return false if you do not have permission to set the priority
+             */
+            virtual bool setIoNiceness(long pid, int priorityClass, int priority) = 0;
+
+            /** \brief Returns true if ionice is supported on this system
+             */
+            virtual bool supportsIoNiceness() = 0;
+
+            /** \brief Return the number of processor cores enabled.
+             *
+             *  (A system can disable processors.  Disabled processors are not counted here).
+             *  This is fast (just a system call on most OSes) */
+            virtual long numberProcessorCores() = 0;
+
+            /** \brief Update the process information for all processes.
+             *
+             *  Get all the current process information from the machine.  When done, emit updateAllProcesses().
+             */
+            virtual void updateAllProcesses( Processes::UpdateFlags updateFlags ) = 0;
+
+            Processes::Error errorCode;
+Q_SIGNALS:
+            /** \brief This is emitted when the processes have been updated, and the view should be refreshed.
+             */
+            void processesUpdated();
+    };
+}
+
+#endif // PROCESSES_BASE_P_H
diff --git a/debuggers/gdb/ksysguard/processes_linux_p.cpp b/debuggers/gdb/ksysguard/processes_linux_p.cpp
new file mode 100644
index 0000000..65b8dfd
--- /dev/null
+++ b/debuggers/gdb/ksysguard/processes_linux_p.cpp
@@ -0,0 +1,701 @@
+/*  This file is part of the KDE project
+
+    Copyright (C) 2007 John Tapsell <tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#include "processes_local_p.h"
+#include "process.h"
+
+#include <klocale.h>
+
+#include <QFile>
+#include <QHash>
+#include <QSet>
+#include <QByteArray>
+#include <QTextStream>
+
+//for sysconf
+#include <unistd.h>
+//for kill and setNice
+#include <errno.h>
+#include <sys/types.h>
+#include <signal.h>
+#include <sys/resource.h>
+#include <dirent.h>
+#include <stdlib.h>
+//for ionice
+#include <sys/ptrace.h>
+#include <asm/unistd.h>
+//for getsched
+#include <sched.h>
+
+#define PROCESS_BUFFER_SIZE 1000
+
+/* For ionice */
+extern int sys_ioprio_set(int, int, int);
+extern int sys_ioprio_get(int, int);
+
+#define HAVE_IONICE
+/* Check if this system has ionice */
+#if !defined(SYS_ioprio_get) || !defined(SYS_ioprio_set)
+/* All new kernels have SYS_ioprio_get and _set defined, but for the few that do not, here are the definitions */
+#if defined(__i386__)
+#define __NR_ioprio_set         289
+#define __NR_ioprio_get         290
+#elif defined(__ppc__) || defined(__powerpc__)
+#define __NR_ioprio_set         273
+#define __NR_ioprio_get         274
+#elif defined(__x86_64__)
+#define __NR_ioprio_set         251
+#define __NR_ioprio_get         252
+#elif defined(__ia64__)
+#define __NR_ioprio_set         1274
+#define __NR_ioprio_get         1275
+#else
+#ifdef __GNUC__
+#warning "This architecture does not support IONICE.  Disabling ionice feature."
+#endif
+#undef HAVE_IONICE
+#endif
+/* Map these to SYS_ioprio_get */
+#define SYS_ioprio_get                __NR_ioprio_get
+#define SYS_ioprio_set                __NR_ioprio_set
+
+#endif /* !SYS_ioprio_get */
+
+/* Set up ionice functions */
+#ifdef HAVE_IONICE
+#define IOPRIO_WHO_PROCESS 1
+#define IOPRIO_CLASS_SHIFT 13
+
+/* Expose the kernel calls to userspace via syscall
+ * See man ioprio_set  and man ioprio_get   for information on these functions */
+static int ioprio_set(int which, int who, int ioprio)
+{
+  return syscall(SYS_ioprio_set, which, who, ioprio);
+}
+
+static int ioprio_get(int which, int who)
+{
+  return syscall(SYS_ioprio_get, which, who);
+}
+#endif
+
+
+
+
+namespace KSysGuard
+{
+
+  class ProcessesLocal::Private
+  {
+    public:
+      Private() { mProcDir = opendir( "/proc" );}
+      ~Private();
+      inline bool readProcStatus(const QString &dir, Process *process);
+      inline bool readProcStat(const QString &dir, Process *process);
+      inline bool readProcStatm(const QString &dir, Process *process);
+      inline bool readProcCmdline(const QString &dir, Process *process);
+      inline bool getNiceness(long pid, Process *process);
+      inline bool getIOStatistics(const QString &dir, Process *process);
+      QFile mFile;
+      char mBuffer[PROCESS_BUFFER_SIZE+1]; //used as a buffer to read data into
+      DIR* mProcDir;
+  };
+
+ProcessesLocal::Private::~Private()
+{
+    closedir(mProcDir);
+}
+
+ProcessesLocal::ProcessesLocal() : d(new Private())
+{
+
+}
+bool ProcessesLocal::Private::readProcStatus(const QString &dir, Process *process)
+{
+    mFile.setFileName(dir + "status");
+    if(!mFile.open(QIODevice::ReadOnly))
+        return false;      /* process has terminated in the meantime */
+
+    process->uid = 0;
+    process->gid = 0;
+    process->tracerpid = -1;
+    process->numThreads = 0;
+
+    int size;
+    int found = 0; //count how many fields we found
+    while( (size = mFile.readLine( mBuffer, sizeof(mBuffer))) > 0) {  //-1 indicates an error
+        switch( mBuffer[0]) {
+	  case 'N':
+	    if((unsigned int)size > sizeof("Name:") && qstrncmp(mBuffer, "Name:", sizeof("Name:")-1) == 0) {
+	        if(process->command.isEmpty())
+                process->setName(QString::fromLocal8Bit(mBuffer + sizeof("Name:")-1, size-sizeof("Name:")+1).trimmed());
+	        if(++found == 5) goto finish;
+	    }
+	    break;
+	  case 'U':
+	    if((unsigned int)size > sizeof("Uid:") && qstrncmp(mBuffer, "Uid:", sizeof("Uid:")-1) == 0) {
+            sscanf(mBuffer + sizeof("Uid:") -1, "%Ld %Ld %Ld %Ld", &process->uid, &process->euid, &process->suid, &process->fsuid );
+	        if(++found == 5) goto finish;
+	    }
+	    break;
+	  case 'G':
+	    if((unsigned int)size > sizeof("Gid:") && qstrncmp(mBuffer, "Gid:", sizeof("Gid:")-1) == 0) {
+            sscanf(mBuffer + sizeof("Gid:")-1, "%Ld %Ld %Ld %Ld", &process->gid, &process->egid, &process->sgid, &process->fsgid );
+	        if(++found == 5) goto finish;
+	    }
+	    break;
+      case 'T':
+        if((unsigned int)size > sizeof("TracerPid:") && qstrncmp(mBuffer, "TracerPid:", sizeof("TracerPid:")-1) == 0) {
+            process->tracerpid = atol(mBuffer + sizeof("TracerPid:")-1);
+            if (process->tracerpid == 0)
+                process->tracerpid = -1;
+            if(++found == 5) goto finish;
+        } else if((unsigned int)size > sizeof("Threads:") && qstrncmp(mBuffer, "Threads:", sizeof("Threads:")-1) == 0) {
+            process->setNumThreads(atol(mBuffer + sizeof("Threads:")-1));
+	        if(++found == 5) goto finish;
+	    }
+	    break;
+	  default:
+	    break;
+	}
+    }
+
+    finish:
+    mFile.close();
+    return true;
+}
+
+long ProcessesLocal::getParentPid(long pid) {
+    if (pid <= 0)
+        return -1;
+    d->mFile.setFileName("/proc/" + QString::number(pid) + "/stat");
+    if(!d->mFile.open(QIODevice::ReadOnly))
+        return -1;      /* process has terminated in the meantime */
+
+    int size; //amount of data read in
+    if( (size = d->mFile.readLine( d->mBuffer, sizeof(d->mBuffer))) <= 0) { //-1 indicates nothing read
+        d->mFile.close();
+        return -1;
+    }
+
+    d->mFile.close();
+    char *word = d->mBuffer;
+    //The command name is the second parameter, and this ends with a closing bracket.  So find the last
+    //closing bracket and start from there
+    word = strrchr(word, ')');
+    if (!word)
+        return -1;
+    word++; //Nove to the space after the last ")"
+    int current_word = 1;
+
+    while(true) {
+        if(word[0] == ' ' ) {
+            if(++current_word == 3)
+                break;
+        } else if(word[0] == 0) {
+            return -1; //end of data - serious problem
+        }
+        word++;
+    }
+    long ppid = atol(++word);
+    if (ppid == 0)
+        return -1;
+    return ppid;
+}
+
+bool ProcessesLocal::Private::readProcStat(const QString &dir, Process *ps)
+{
+    QString filename = dir + "stat";
+    // As an optimization, if the last file read in was stat, then we already have this info in memory
+    if(mFile.fileName() != filename) {
+        mFile.setFileName(filename);
+        if(!mFile.open(QIODevice::ReadOnly))
+            return false;      /* process has terminated in the meantime */
+        if( mFile.readLine( mBuffer, sizeof(mBuffer)) <= 0) { //-1 indicates nothing read
+            mFile.close();
+            return false;
+        }
+        mFile.close();
+    }
+
+    char *word = mBuffer;
+    //The command name is the second parameter, and this ends with a closing bracket.  So find the last
+    //closing bracket and start from there
+    word = strrchr(word, ')');
+    if (!word)
+        return false;
+    word++; //Nove to the space after the last ")"
+    int current_word = 1; //We've skipped the process ID and now at the end of the command name
+    char status='\0';
+    unsigned long long vmSize = 0;
+    unsigned long long vmRSS = 0;
+    while(current_word < 23) {
+        if(word[0] == ' ' ) {
+            ++current_word;
+            switch(current_word) {
+                case 2: //status
+                    status=word[1];  // Look at the first letter of the status.
+                    // We analyze this after the while loop
+                    break;
+                case 6: //ttyNo
+                    {
+                        int ttyNo = atoi(word+1);
+                        int major = ttyNo >> 8;
+                        int minor = ttyNo & 0xff;
+                        switch(major) {
+                            case 136:
+                                ps->setTty(QByteArray("pts/") + QByteArray::number(minor));
+                                break;
+                            case 5:
+                                ps->setTty(QByteArray("tty"));
+                            case 4:
+                                if(minor < 64)
+                                    ps->setTty(QByteArray("tty") + QByteArray::number(minor));
+                                else
+                                    ps->setTty(QByteArray("ttyS") + QByteArray::number(minor-64));
+                                break;
+                            default:
+                                ps->setTty(QByteArray());
+                        }
+                    }
+                    break;
+                case 13: //userTime
+                    ps->setUserTime(atoll(word+1));
+                    break;
+                case 14: //sysTime
+                    ps->setSysTime(atoll(word+1));
+                    break;
+                case 18: //niceLevel
+                    ps->setNiceLevel(atoi(word+1));  /*Or should we use getPriority instead? */
+                    break;
+                case 22: //vmSize
+                    vmSize = atoll(word+1);
+                    break;
+                case 23: //vmRSS
+                    vmRSS = atoll(word+1);
+                    break;
+                default:
+                    break;
+            }
+        } else if(word[0] == 0) {
+            return false; //end of data - serious problem
+        }
+        word++;
+    }
+
+    /* There was a "(ps->vmRss+3) * sysconf(_SC_PAGESIZE)" here in the original ksysguard code.  I have no idea why!  After comparing it to
+     *   meminfo and other tools, this means we report the RSS by 12 bytes differently compared to them.  So I'm removing the +3
+     *   to be consistent.  NEXT TIME COMMENT STRANGE THINGS LIKE THAT! :-)
+     *
+     *   Update: I think I now know why - the kernel allocates 3 pages for
+     *   tracking information about each the process. This memory isn't
+     *   included in vmRSS..*/
+    ps->setVmRSS(vmRSS * (sysconf(_SC_PAGESIZE) / 1024)); /*convert to KiB*/
+    ps->setVmSize(vmSize / 1024); /* convert to KiB */
+
+    switch( status) {
+        case 'R':
+            ps->setStatus(Process::Running);
+            break;
+        case 'S':
+            ps->setStatus(Process::Sleeping);
+            break;
+        case 'D':
+            ps->setStatus(Process::DiskSleep);
+            break;
+        case 'Z':
+            ps->setStatus(Process::Zombie);
+            break;
+        case 'T':
+            ps->setStatus(Process::Stopped);
+            break;
+        case 'W':
+            ps->setStatus(Process::Paging);
+            break;
+        default:
+            ps->setStatus(Process::OtherStatus);
+            break;
+    }
+    return true;
+}
+
+bool ProcessesLocal::Private::readProcStatm(const QString &dir, Process *process)
+{
+#ifdef _SC_PAGESIZE
+    mFile.setFileName(dir + "statm");
+    if(!mFile.open(QIODevice::ReadOnly))
+        return false;      /* process has terminated in the meantime */
+
+    if( mFile.readLine( mBuffer, sizeof(mBuffer)) <= 0) { //-1 indicates nothing read
+        mFile.close();
+        return 0;
+    }
+    mFile.close();
+
+    int current_word = 0;
+    char *word = mBuffer;
+
+    while(true) {
+	    if(word[0] == ' ' ) {
+		    if(++current_word == 2) //number of pages that are shared
+			    break;
+	    } else if(word[0] == 0) {
+	    	return false; //end of data - serious problem
+	    }
+	    word++;
+    }
+    long shared = atol(word+1);
+
+    /* we use the rss - shared  to find the amount of memory just this app uses */
+    process->vmURSS = process->vmRSS - (shared * sysconf(_SC_PAGESIZE) / 1024);
+#else
+    process->vmURSS = 0;
+#endif
+    return true;
+}
+
+
+bool ProcessesLocal::Private::readProcCmdline(const QString &dir, Process *process)
+{
+    if(!process->command.isNull()) return true; //only parse the cmdline once.  This function takes up 25% of the CPU time :-/
+    mFile.setFileName(dir + "cmdline");
+    if(!mFile.open(QIODevice::ReadOnly))
+        return false;      /* process has terminated in the meantime */
+
+    QTextStream in(&mFile);
+    process->command = in.readAll();
+
+    //cmdline separates parameters with the NULL character
+    if(!process->command.isEmpty()) {
+        //extract non-truncated name from cmdline
+        int zeroIndex = process->command.indexOf(QChar('\0'));
+        int processNameStart = process->command.lastIndexOf(QChar('/'), zeroIndex);
+        if(processNameStart == -1)
+            processNameStart = 0;
+        else
+            processNameStart++;
+        QString nameFromCmdLine = process->command.mid(processNameStart, zeroIndex - processNameStart);
+        if(nameFromCmdLine.startsWith(process->name))
+            process->setName(nameFromCmdLine);
+
+        process->command.replace('\0', ' ');
+    }
+
+    mFile.close();
+    return true;
+}
+
+bool ProcessesLocal::Private::getNiceness(long pid, Process *process) {
+  int sched = sched_getscheduler(pid);
+  switch(sched) {
+      case (SCHED_OTHER):
+	    process->scheduler = KSysGuard::Process::Other;
+            break;
+      case (SCHED_RR):
+	    process->scheduler = KSysGuard::Process::RoundRobin;
+            break;
+      case (SCHED_FIFO):
+	    process->scheduler = KSysGuard::Process::Fifo;
+            break;
+#ifdef SCHED_IDLE
+      case (SCHED_IDLE):
+	    process->scheduler = KSysGuard::Process::SchedulerIdle;
+#endif
+#ifdef SCHED_BATCH
+      case (SCHED_BATCH):
+	    process->scheduler = KSysGuard::Process::Batch;
+            break;
+#endif
+      default:
+	    process->scheduler = KSysGuard::Process::Other;
+    }
+  if(sched == SCHED_FIFO || sched == SCHED_RR) {
+    struct sched_param param;
+    if(sched_getparam(pid, &param) == 0)
+      process->setNiceLevel(param.sched_priority);
+    else
+      process->setNiceLevel(0);  //Error getting scheduler parameters.
+  }
+
+#ifdef HAVE_IONICE
+  int ioprio = ioprio_get(IOPRIO_WHO_PROCESS, pid);  /* Returns from 0 to 7 for the iopriority, and -1 if there's an error */
+  if(ioprio == -1) {
+	  process->ioniceLevel = -1;
+	  process->ioPriorityClass = KSysGuard::Process::None;
+	  return false; /* Error. Just give up. */
+  }
+  process->ioniceLevel = ioprio & 0xff;  /* Bottom few bits are the priority */
+  process->ioPriorityClass = (KSysGuard::Process::IoPriorityClass)(ioprio >> IOPRIO_CLASS_SHIFT); /* Top few bits are the class */
+  return true;
+#else
+  return false;  /* Do nothing, if we do not support this architecture */
+#endif
+}
+
+bool ProcessesLocal::Private::getIOStatistics(const QString &dir, Process *process)
+{
+    QString filename = dir + "io";
+    // As an optimization, if the last file read in was io, then we already have this info in memory
+    mFile.setFileName(filename);
+    if(!mFile.open(QIODevice::ReadOnly))
+        return false;      /* process has terminated in the meantime */
+    if( mFile.read( mBuffer, sizeof(mBuffer)) <= 0) { //-1 indicates nothing read
+        mFile.close();
+        return false;
+    }
+    mFile.close();
+
+    int current_word = 0;  //count from 0
+    char *word = mBuffer;
+    while(current_word < 6 && word[0] != 0) {
+        if(word[0] == ' ' ) {
+            qlonglong number = atoll(word+1);
+            switch(current_word++) {
+                case 0: //rchar - characters read
+                    process->setIoCharactersRead(number);
+                    break;
+                case 1: //wchar - characters written
+                    process->setIoCharactersWritten(number);
+                    break;
+                case 2: //syscr - read syscall
+                    process->setIoReadSyscalls(number);
+                    break;
+                case 3: //syscw - write syscall
+                    process->setIoWriteSyscalls(number);
+                    break;
+                case 4: //read_bytes - bytes actually read from I/O
+                    process->setIoCharactersActuallyRead(number);
+                    break;
+                case 5: //write_bytes - bytes actually written to I/O
+                    process->setIoCharactersActuallyWritten(number);
+                default:
+                    break;
+            }
+        }
+        word++;
+    }
+    return true;
+}
+bool ProcessesLocal::updateProcessInfo( long pid, Process *process)
+{
+    bool success = true;
+    QString dir = "/proc/" + QString::number(pid) + '/';
+    if(!d->readProcStat(dir, process)) success = false;
+    if(!d->readProcStatus(dir, process)) success = false;
+    if(!d->readProcStatm(dir, process)) success = false;
+    if(!d->readProcCmdline(dir, process)) success = false;
+    if(!d->getNiceness(pid, process)) success = false;
+    if(mUpdateFlags.testFlag(Processes::IOStatistics) && !d->getIOStatistics(dir, process)) success = false;
+
+    return success;
+}
+
+QSet<long> ProcessesLocal::getAllPids( )
+{
+    QSet<long> pids;
+    if(d->mProcDir==NULL) return pids; //There's not much we can do without /proc
+    struct dirent* entry;
+    rewinddir(d->mProcDir);
+    while ( ( entry = readdir( d->mProcDir ) ) )
+        if ( entry->d_name[ 0 ] >= '0' && entry->d_name[ 0 ] <= '9' )
+            pids.insert(atol( entry->d_name ));
+    return pids;
+}
+
+bool ProcessesLocal::sendSignal(long pid, int sig) {
+    errno = 0;
+    if (pid <= 0) {
+        errorCode = Processes::InvalidPid;
+        return false;
+    }
+    if (kill( (pid_t)pid, sig )) {
+        switch (errno) {
+            case ESRCH:
+                errorCode = Processes::ProcessDoesNotExistOrZombie;
+                break;
+            case EINVAL:
+                errorCode = Processes::InvalidParameter;
+                break;
+            case EPERM:
+                errorCode = Processes::InsufficientPermissions;
+                break;
+            default:
+                break;
+        }
+        //Kill failed
+        return false;
+    }
+    return true;
+}
+
+bool ProcessesLocal::setNiceness(long pid, int priority) {
+    errno = 0;
+    if (pid <= 0) {
+        errorCode = Processes::InvalidPid;
+        return false;
+    }
+    if (setpriority( PRIO_PROCESS, pid, priority )) {
+        switch (errno) {
+            case ESRCH:
+                errorCode = Processes::ProcessDoesNotExistOrZombie;
+                break;
+            case EINVAL:
+                errorCode = Processes::InvalidParameter;
+                break;
+            case EACCES:
+            case EPERM:
+                errorCode = Processes::InsufficientPermissions;
+                break;
+            default:
+                break;
+        }
+        //set niceness failed
+        return false;
+    }
+    return true;
+}
+
+bool ProcessesLocal::setScheduler(long pid, int priorityClass, int priority) {
+    errno = 0;
+    if(priorityClass == KSysGuard::Process::Other || priorityClass == KSysGuard::Process::Batch || priorityClass == KSysGuard::Process::SchedulerIdle)
+        priority = 0;
+    if (pid <= 0) {
+        errorCode = Processes::InvalidPid;
+        return false;
+    }
+    struct sched_param params;
+    params.sched_priority = priority;
+    int policy;
+    switch(priorityClass) {
+      case (KSysGuard::Process::Other):
+          policy = SCHED_OTHER;
+          break;
+      case (KSysGuard::Process::RoundRobin):
+          policy = SCHED_RR;
+          break;
+      case (KSysGuard::Process::Fifo):
+          policy = SCHED_FIFO;
+          break;
+#ifdef SCHED_IDLE
+      case (KSysGuard::Process::SchedulerIdle):
+          policy = SCHED_IDLE;
+          break;
+#endif
+#ifdef SCHED_BATCH
+      case (KSysGuard::Process::Batch):
+          policy = SCHED_BATCH;
+          break;
+#endif
+      default:
+          errorCode = Processes::NotSupported;
+          return false;
+    }
+
+    if (sched_setscheduler( pid, policy, &params) != 0) {
+        switch (errno) {
+            case ESRCH:
+                errorCode = Processes::ProcessDoesNotExistOrZombie;
+                break;
+            case EINVAL:
+                errorCode = Processes::InvalidParameter;
+                break;
+            case EPERM:
+                errorCode = Processes::InsufficientPermissions;
+                break;
+            default:
+                break;
+        }
+        return false;
+    }
+    return true;
+}
+
+
+bool ProcessesLocal::setIoNiceness(long pid, int priorityClass, int priority) {
+    errno = 0;
+    if (pid <= 0) {
+        errorCode = Processes::InvalidPid;
+        return false;
+    }
+#ifdef HAVE_IONICE
+    if (ioprio_set(IOPRIO_WHO_PROCESS, pid, priority | priorityClass << IOPRIO_CLASS_SHIFT) == -1) {
+        //set io niceness failed
+        switch (errno) {
+            case ESRCH:
+                errorCode = Processes::ProcessDoesNotExistOrZombie;
+                break;
+            case EINVAL:
+                errorCode = Processes::InvalidParameter;
+                break;
+            case EPERM:
+                errorCode = Processes::InsufficientPermissions;
+                break;
+            default:
+                break;
+        }
+        return false;
+    }
+    return true;
+#else
+    errorCode = Processes::NotSupported;
+    return false;
+#endif
+}
+
+bool ProcessesLocal::supportsIoNiceness() {
+#ifdef HAVE_IONICE
+    return true;
+#else
+    return false;
+#endif
+}
+
+long long ProcessesLocal::totalPhysicalMemory() {
+    //Try to get the memory via sysconf.  Note the cast to long long to try to avoid a long overflow
+    //Should we use sysconf(_SC_PAGESIZE)  or getpagesize()  ?
+#ifdef _SC_PHYS_PAGES
+    return ((long long)sysconf(_SC_PHYS_PAGES)) * (sysconf(_SC_PAGESIZE)/1024);
+#else
+    //This is backup code in case this is not defined.  It should never fail on a linux system.
+
+    d->mFile.setFileName("/proc/meminfo");
+    if(!d->mFile.open(QIODevice::ReadOnly))
+        return 0;
+
+    int size;
+    while( (size = d->mFile.readLine( d->mBuffer, sizeof(d->mBuffer))) > 0) {  //-1 indicates an error
+        switch( d->mBuffer[0]) {
+	  case 'M':
+            if((unsigned int)size > sizeof("MemTotal:") && qstrncmp(d->mBuffer, "MemTotal:", sizeof("MemTotal:")-1) == 0) {
+		    d->mFile.close();
+		    return atoll(d->mBuffer + sizeof("MemTotal:")-1);
+            }
+	}
+    }
+    return 0; // Not found.  Probably will never happen
+#endif
+}
+ProcessesLocal::~ProcessesLocal()
+{
+  delete d;
+}
+
+}
diff --git a/debuggers/gdb/ksysguard/processes_local_p.cpp b/debuggers/gdb/ksysguard/processes_local_p.cpp
new file mode 100644
index 0000000..cabfeb0
--- /dev/null
+++ b/debuggers/gdb/ksysguard/processes_local_p.cpp
@@ -0,0 +1,41 @@
+/*  This file is part of the KDE project
+
+    Copyright (C) 2007 John Tapsell <tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#if defined __linux__
+#include "processes_linux_p.cpp"
+#elif defined __FreeBSD__ || defined __FreeBSD_kernel__
+#include "processes_freebsd_p.cpp"
+#elif defined __DragonFly__
+#include "processes_dragonfly_p.cpp"
+#elif defined __OpenBSD__
+#include "processes_openbsd_p.cpp"
+#elif defined __NetBSD__
+#include "processes_netbsd_p.cpp"
+#elif defined __GNU__
+#include "processes_gnu_p.cpp"
+#else
+// Use Qt's OS detection
+#include <qglobal.h>
+#ifdef Q_OS_SOLARIS
+#include "processes_solaris_p.cpp"
+#endif
+#endif
+
diff --git a/debuggers/gdb/ksysguard/processes_local_p.h b/debuggers/gdb/ksysguard/processes_local_p.h
new file mode 100644
index 0000000..75cf9f5
--- /dev/null
+++ b/debuggers/gdb/ksysguard/processes_local_p.h
@@ -0,0 +1,72 @@
+/*  This file is part of the KDE project
+
+    Copyright (C) 2007 John Tapsell <tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef PROCESSES_LOCAL_H_
+#define PROCESSES_LOCAL_H_
+
+#include "processes_base_p.h"
+#include <unistd.h>  //For sysconf
+
+
+#include <QSet>
+
+namespace KSysGuard
+{
+    class Process;
+
+    /**
+     * This is the OS specific code to get process information for the local host.
+     */
+    class ProcessesLocal : public AbstractProcesses {
+        public:
+            ProcessesLocal();
+            virtual ~ProcessesLocal();
+            virtual QSet<long> getAllPids();
+            virtual long getParentPid(long pid);
+            virtual bool updateProcessInfo(long pid, Process *process);
+            virtual bool sendSignal(long pid, int sig);
+            virtual bool setNiceness(long pid, int priority);
+            virtual bool setScheduler(long pid, int priorityClass, int priority);
+            virtual long long totalPhysicalMemory();
+            virtual bool setIoNiceness(long pid, int priorityClass, int priority);
+            virtual bool supportsIoNiceness();
+            virtual long numberProcessorCores()
+#ifdef _SC_NPROCESSORS_ONLN
+            { return sysconf(_SC_NPROCESSORS_ONLN); } // Should work on any recent posix system
+#else
+            ;
+#endif
+            virtual void updateAllProcesses(Processes::UpdateFlags updateFlags) { mUpdateFlags = updateFlags; emit processesUpdated(); } //For local machine, there is no delay
+
+        private:
+            /**
+             * You can use this for whatever data you want.
+             * Be careful about preserving state in between getParentPid and updateProcessInfo calls
+             * if you chose to do that. getParentPid may be called several times
+             * for different pids before the relevant updateProcessInfo calls are made.
+             * This is because the tree structure has to be sorted out first.
+             */
+            class Private;
+            Private *d;
+            Processes::UpdateFlags mUpdateFlags;
+    };
+}
+#endif
diff --git a/debuggers/gdb/ksysguard/processes_remote_p.cpp b/debuggers/gdb/ksysguard/processes_remote_p.cpp
new file mode 100644
index 0000000..3036087
--- /dev/null
+++ b/debuggers/gdb/ksysguard/processes_remote_p.cpp
@@ -0,0 +1,274 @@
+/*  This file is part of the KDE project
+
+    Copyright (C) 2007 John Tapsell <tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "processes_remote_p.h"
+#include "process.h"
+
+#include <QString>
+#include <QSet>
+#include <QTimer>
+
+#include <klocale.h>
+#include <kdebug.h>
+
+
+
+
+
+namespace KSysGuard
+{
+
+  class ProcessesRemote::Private
+  {
+    public:
+      Private() {havePsInfo = false; pidColumn = 1;
+	      ppidColumn = nameColumn = uidColumn = gidColumn =
+	      statusColumn = userColumn = systemColumn = niceColumn =
+	      vmSizeColumn = vmRSSColumn = loginColumn = commandColumn =
+	      tracerPidColumn = ttyColumn = ioprioClassColumn = ioprioColumn =
+	      vmURSSColumn = -1;
+              usedMemory = freeMemory;}
+      ~Private() {;}
+      QString host;
+      QList<QByteArray> lastAnswer;
+      QSet<long> pids;
+      QHash<long, QList<QByteArray> > processByPid;
+
+      bool havePsInfo;
+      int pidColumn;
+      int ppidColumn;
+      int tracerPidColumn;
+      int nameColumn;
+      int uidColumn;
+      int gidColumn;
+      int statusColumn;
+      int userColumn;
+      int systemColumn;
+      int niceColumn;
+      int vmSizeColumn;
+      int vmRSSColumn;
+      int vmURSSColumn;
+      int loginColumn;
+      int commandColumn;
+      int ioprioClassColumn;
+      int ioprioColumn;
+      int ttyColumn;
+
+      int numColumns;
+
+      long freeMemory;
+      long usedMemory;
+
+      Processes::UpdateFlags updateFlags;
+    };
+ProcessesRemote::ProcessesRemote(const QString &hostname) : d(new Private())
+{
+  d->host = hostname;
+  QTimer::singleShot(0, this, SLOT(setup()));
+}
+
+void ProcessesRemote::setup() {
+  emit runCommand("mem/physical/used", (int)UsedMemory);
+  emit runCommand("mem/physical/free", (int)FreeMemory);
+  emit runCommand("ps?", (int)PsInfo);
+  emit runCommand("ps", (int)Ps);
+}
+
+
+long ProcessesRemote::getParentPid(long pid) {
+    if(!d->processByPid.contains(pid)) {
+        kDebug() << "Parent pid requested for pid that we do not have info on " << pid;
+        return 0;
+    }
+    if(d->ppidColumn == -1) {
+        kDebug() << "ppid column not known ";
+        return 0;
+    }
+    return d->processByPid[pid].at(d->ppidColumn).toLong();
+}
+bool ProcessesRemote::updateProcessInfo( long pid, Process *process)
+{
+    Q_CHECK_PTR(process);
+    if(!d->processByPid.contains(pid)) {
+	kDebug() << "update request for pid that we do not have info on " << pid;
+        return false;
+    }
+    QList<QByteArray> p = d->processByPid[pid];
+
+    if(d->nameColumn!= -1) process->setName(p.at(d->nameColumn));
+    if(d->uidColumn!= -1) process->setUid(p.at(d->uidColumn).toLong());
+    if(d->gidColumn!= -1) process->setGid(p.at(d->gidColumn).toLong());
+    if(d->statusColumn!= -1) {
+	    switch( p.at(d->statusColumn)[0] ) {
+		    case 's':
+			    process->setStatus(Process::Sleeping);
+			    break;
+		    case 'r':
+			    process->setStatus(Process::Running);
+			    break;
+	    }
+    }
+    if(d->userColumn!= -1) process->setUserTime(p.at(d->userColumn).toLong());
+    if(d->systemColumn!= -1) process->setSysTime(p.at(d->systemColumn).toLong());
+    if(d->niceColumn!= -1) process->setNiceLevel(p.at(d->niceColumn).toLong());
+    if(d->vmSizeColumn!= -1) process->setVmSize(p.at(d->vmSizeColumn).toLong());
+    if(d->vmRSSColumn!= -1) process->setVmRSS(p.at(d->vmRSSColumn).toLong());
+    if(d->vmURSSColumn!= -1) process->setVmURSS(p.at(d->vmURSSColumn).toLong());
+    if(d->loginColumn!= -1) process->setLogin(QString::fromUtf8(p.at(d->loginColumn).data()));
+    if(d->commandColumn!= -1) process->setCommand(QString::fromUtf8(p.at(d->commandColumn).data()));
+    if(d->tracerPidColumn!= -1) process->setTracerpid(p.at(d->tracerPidColumn).toLong());
+    if(d->vmURSSColumn!= -1) process->setVmURSS(p.at(d->vmURSSColumn).toLong());
+    if(d->ttyColumn!= -1) process->setTty(p.at(d->ttyColumn));
+    if(d->ioprioColumn!= -1) process->setIoniceLevel(p.at(d->ioprioColumn).toInt());
+    if(d->ioprioClassColumn!= -1) process->setIoPriorityClass((KSysGuard::Process::IoPriorityClass)(p.at(d->ioprioClassColumn).toInt()));
+
+    return true;
+}
+
+void ProcessesRemote::updateAllProcesses( Processes::UpdateFlags updateFlags )
+{
+    d->updateFlags = updateFlags;
+    if(!d->havePsInfo)
+    	emit runCommand("ps?", (int)PsInfo);
+    emit runCommand("ps", (int)Ps);
+}
+QSet<long> ProcessesRemote::getAllPids( )
+{
+    d->pids.clear();
+    d->processByPid.clear();
+    Q_FOREACH(const QByteArray &process, d->lastAnswer) {
+        QList<QByteArray> info = process.split('\t');
+	if(info.size() == d->numColumns) {
+		int pid =  info.at(d->pidColumn).toLong();
+		Q_ASSERT(! d->pids.contains(pid));
+		d->pids << pid;
+		d->processByPid[pid] = info;
+	}
+    }
+    return d->pids;
+}
+
+bool ProcessesRemote::sendSignal(long pid, int sig) {
+	//TODO run the proper command for all these functions below
+    emit runCommand("kill " + QString::number(pid) + " " + QString::number(sig), (int)Kill);
+    return true;
+}
+bool ProcessesRemote::setNiceness(long pid, int priority) {
+    emit runCommand("setpriority " + QString::number(pid) + " " + QString::number(priority), (int)Renice);
+    return true;
+}
+
+bool ProcessesRemote::setIoNiceness(long pid, int priorityClass, int priority) {
+    emit runCommand("ionice " + QString::number(pid) + " " + QString::number(priorityClass) + " " + QString::number(priority), (int)Ionice);
+    return true;
+}
+
+bool ProcessesRemote::setScheduler(long pid, int priorityClass, int priority) {
+    Q_UNUSED(pid);
+    Q_UNUSED(priorityClass);
+    Q_UNUSED(priority);
+
+    errorCode = Processes::NotSupported;
+    return false;
+}
+
+bool ProcessesRemote::supportsIoNiceness() {
+    return true;
+}
+
+long long ProcessesRemote::totalPhysicalMemory() {
+    return d->usedMemory + d->freeMemory;
+}
+long ProcessesRemote::numberProcessorCores() {
+    return 0;
+}
+
+void ProcessesRemote::answerReceived( int id, const QList<QByteArray>& answer ) {
+    switch (id) {
+        case PsInfo: {
+            if(answer.isEmpty()) return; //Invalid data
+            QList<QByteArray> info = answer.at(0).split('\t');
+	    d->numColumns = info.size();
+	    for(int i =0; i < d->numColumns; i++) {
+                if(info[i] == "Name")
+			d->nameColumn = i;
+		else if(info[i] == "PID")
+			d->pidColumn = i;
+		else if(info[i] == "PPID")
+			d->ppidColumn = i;
+		else if(info[i] == "UID")
+			d->uidColumn = i;
+		else if(info[i] == "GID")
+			d->gidColumn = i;
+		else if(info[i] == "TracerPID")
+			d->tracerPidColumn = i;
+		else if(info[i] == "Status")
+			d->statusColumn = i;
+		else if(info[i] == "User Time")
+			d->userColumn = i;
+		else if(info[i] == "System Time")
+			d->systemColumn = i;
+		else if(info[i] == "Nice")
+			d->niceColumn = i;
+		else if(info[i] == "VmSize")
+			d->vmSizeColumn = i;
+		else if(info[i] == "VmRss")
+			d->vmRSSColumn = i;
+		else if(info[i] == "VmURss")
+			d->vmURSSColumn = i;
+		else if(info[i] == "Login")
+			d->loginColumn = i;
+		else if(info[i] == "TTY")
+			d->ttyColumn = i;
+		else if(info[i] == "Command")
+			d->commandColumn = i;
+		else if(info[i] == "IO Priority Class")
+			d->ioprioClassColumn = i;
+		else if(info[i] == "IO Priority")
+			d->ioprioColumn = i;
+	    }
+	    d->havePsInfo = true;
+	    break;
+	}
+        case Ps:
+	    d->lastAnswer = answer;
+	    if(!d->havePsInfo) return;  //Not setup yet.  Should never happen
+	    emit processesUpdated();
+	case FreeMemory:
+            if(answer.isEmpty()) return; //Invalid data
+	    d->freeMemory = answer[0].toLong();
+	    break;
+	case UsedMemory:
+            if(answer.isEmpty()) return; //Invalid data
+	    d->usedMemory = answer[0].toLong();
+	    break;
+    }
+
+}
+
+ProcessesRemote::~ProcessesRemote()
+{
+    delete d;
+}
+
+}
+
+#include "processes_remote_p.moc"
+
diff --git a/debuggers/gdb/ksysguard/processes_remote_p.h b/debuggers/gdb/ksysguard/processes_remote_p.h
new file mode 100644
index 0000000..795f56b
--- /dev/null
+++ b/debuggers/gdb/ksysguard/processes_remote_p.h
@@ -0,0 +1,78 @@
+/*  This file is part of the KDE project
+
+    Copyright (C) 2007 John Tapsell <tapsell@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef PROCESSES_REMOTE_P_H_
+#define PROCESSES_REMOTE_P_H_
+
+#include "processes_base_p.h"
+#include <QSet>
+class Process;
+namespace KSysGuard
+{
+    /**
+     * This is used to connect to a remote host
+     */
+    class ProcessesRemote : public AbstractProcesses {
+      Q_OBJECT
+      public:
+	ProcessesRemote(const QString &hostname);
+	virtual ~ProcessesRemote();
+	virtual QSet<long> getAllPids();
+	virtual long getParentPid(long pid);
+	virtual bool updateProcessInfo(long pid, Process *process);
+	virtual bool sendSignal(long pid, int sig);
+        virtual bool setNiceness(long pid, int priority);
+	virtual bool setScheduler(long pid, int priorityClass, int priority);
+	virtual long long totalPhysicalMemory();
+	virtual bool setIoNiceness(long pid, int priorityClass, int priority);
+	virtual bool supportsIoNiceness();
+	virtual long numberProcessorCores();
+    virtual void updateAllProcesses( Processes::UpdateFlags updateFlags );
+
+
+      Q_SIGNALS:
+	/** For a remote machine, we rely on being able to communicate with ksysguardd.
+	 *  This must be dealt with by the program including this widget.  It must listen to our
+	 *  'runCommand' signal, and run the given command, with the given id. */
+	void runCommand(const QString &command, int id);
+
+      public Q_SLOTS:
+	/** For a remote machine, we rely on being able to communicate with ksysguardd.
+	 *  The programming using this must call this slot when an answer is received from ksysguardd,
+	 *  in response to a runCommand request.  The id identifies the answer */
+	void answerReceived( int id, const QList<QByteArray>& answer );
+	/** Called soon after */
+	void setup();
+
+      protected:
+	enum { PsInfo, Ps, UsedMemory, FreeMemory, Kill, Renice, Ionice };
+
+      private:
+	/**
+	 * You can use this for whatever data you want.  Be careful about preserving state in between getParentPid and updateProcessInfo calls
+	 * if you chose to do that. getParentPid may be called several times for different pids before the relevant updateProcessInfo calls are made.
+	 * This is because the tree structure has to be sorted out first.
+	 */
+        class Private;
+        Private *d;
+
+    };
+}
+#endif
diff --git a/debuggers/gdb/memviewdlg.cpp b/debuggers/gdb/memviewdlg.cpp
index cf9d0b4..ba88d51 100644
--- a/debuggers/gdb/memviewdlg.cpp
+++ b/debuggers/gdb/memviewdlg.cpp
@@ -153,6 +153,7 @@ namespace GDBDebugger
     void MemoryView::initWidget()
     {
         QVBoxLayout *l = new QVBoxLayout(this);
+        l->setContentsMargins(0, 0, 0, 0);
 
         khexedit2_widget = KHE::createBytesEditWidget(this);
         if (!khexedit2_widget)
@@ -236,9 +237,11 @@ namespace GDBDebugger
             KDevelop::ICore::self()->debugController()->currentSession());
         if (!session) return;
 
-        session->addCommand(new ExpressionValueCommand(
-                rangeSelector_->amountLineEdit->text(),
-                this, &MemoryView::sizeComputed));
+        QString amount = rangeSelector_->amountLineEdit->text();
+        if(amount.isEmpty())
+            amount = QString("sizeof(%1)").arg(rangeSelector_->startAddressLineEdit->text());
+
+        session->addCommand(new ExpressionValueCommand(amount, this, &MemoryView::sizeComputed));
     }
 
     void MemoryView::sizeComputed(const QString& size)
@@ -463,9 +466,7 @@ namespace GDBDebugger
     {
         bool app_started = !(debuggerState_ & s_appNotStarted);
 
-        bool enabled_ = app_started &&
-            !rangeSelector_->startAddressLineEdit->text().isEmpty() &&
-            !rangeSelector_->amountLineEdit->text().isEmpty();
+        bool enabled_ = app_started && !rangeSelector_->startAddressLineEdit->text().isEmpty();
 
         rangeSelector_->okButton->setEnabled(enabled_);
     }
@@ -486,10 +487,14 @@ namespace GDBDebugger
         addAction(newMemoryViewerAction);
 
         QVBoxLayout *l = new QVBoxLayout(this);
+        l->setContentsMargins(0, 0, 0, 0);
 
         toolBox_ = new QToolBox(this);
+        toolBox_->setContentsMargins(0, 0, 0, 0);
         l->addWidget(toolBox_);
 
+        setLayout(l);
+
         // Start with one empty memory view.
         slotAddMemoryView();
     }
diff --git a/debuggers/gdb/mi/gdbmi.h b/debuggers/gdb/mi/gdbmi.h
index d5e92b8..4a81a8a 100644
--- a/debuggers/gdb/mi/gdbmi.h
+++ b/debuggers/gdb/mi/gdbmi.h
@@ -338,7 +338,6 @@ namespace GDBMI
         const Value& operator[](int index) const;
 
         QList<Result*> results;
-
     };
 
     struct Record
@@ -346,19 +345,42 @@ namespace GDBMI
         virtual ~Record() {}
         virtual QString toString() const { Q_ASSERT( 0 ); return QString::null; }
 
-        enum { Prompt, Stream, Result } kind;
+        enum { Prompt, Stream, Result, Async } kind;
+    };
+
+    struct TupleRecord : public Record, public TupleValue
+    {
     };
 
-    struct ResultRecord : public Record, public TupleValue
+    struct ResultRecord : public TupleRecord
     {
-        ResultRecord()
-            : subkind(CommandResult)
+        ResultRecord(const QString& reason)
+            : token(0)
+            , reason(reason)
         {
             Record::kind = Result;
         }
         
-        enum { CommandResult, ExecNotification, StatusNotification, GeneralNotification } subkind;
+        uint32_t token;
+        QString reason;
+    };
 
+    struct AsyncRecord : public TupleRecord
+    {
+        enum Subkind {
+            Exec,
+            Status,
+            Notify
+        };
+
+        AsyncRecord(Subkind subkind, const QString& reason)
+            : subkind(subkind)
+            , reason(reason)
+        {
+            Record::kind = Async;
+        }
+
+        Subkind subkind;
         QString reason;
     };
 
@@ -372,9 +394,25 @@ namespace GDBMI
 
     struct StreamRecord : public Record
     {
-        inline StreamRecord() : reason(0) { Record::kind = Stream; }
+        enum Subkind {
+            /// Console stream: usual CLI output of GDB in response to non-MI commands
+            Console,
+
+            /// Target output stream (stdout/stderr of the inferior process, only in some
+            /// scenarios - usually we get stdout/stderr via other means)
+            Target,
+
+            /// Log stream: GDB internal messages that should be displayed as part of an error log
+            Log
+        };
+
+        StreamRecord(Subkind subkind)
+            : subkind(subkind)
+        {
+            Record::kind = Stream;
+        }
 
-        char reason;
+        Subkind subkind;
         QString message;
     };
 }
diff --git a/debuggers/gdb/mi/miparser.cpp b/debuggers/gdb/mi/miparser.cpp
index 123c97e..d5ba205 100644
--- a/debuggers/gdb/mi/miparser.cpp
+++ b/debuggers/gdb/mi/miparser.cpp
@@ -21,7 +21,6 @@
  ***************************************************************************/
 #include "miparser.h"
 #include "tokens.h"
-#include <memory>
 
 using namespace GDBMI;
 
@@ -37,6 +36,18 @@ using namespace GDBMI;
       m_lex->nextToken(); \
   } while (0)
 
+#define MATCH_PTR(tok) \
+  do { \
+      if (m_lex->lookAhead(0) != (tok)) \
+          return {}; \
+  } while (0)
+
+#define ADVANCE_PTR(tok) \
+  do { \
+      MATCH_PTR(tok); \
+      m_lex->nextToken(); \
+  } while (0)
+
 MIParser::MIParser()
     : m_lex(0)
 {
@@ -46,117 +57,119 @@ MIParser::~MIParser()
 {
 }
 
-Record *MIParser::parse(FileSymbol *file)
+std::unique_ptr<Record> MIParser::parse(FileSymbol *file)
 {
     m_lex = 0;
 
-    Record *record = 0;
-
     TokenStream *tokenStream = m_lexer.tokenize(file);
     if (!tokenStream)
         return 0;
 
     m_lex = file->tokenStream = tokenStream;
 
+    uint32_t token = 0;
+    if (m_lex->lookAhead() == Token_number_literal) {
+        token = QString::fromUtf8(m_lex->currentTokenText()).toUInt();
+        m_lex->nextToken();
+    }
+
+    std::unique_ptr<Record> record;
+
     switch (m_lex->lookAhead()) {
         case '~':
         case '@':
         case '&':
-            parseStreamRecord(record);
+            record = parseStreamRecord();
             break;
         case '(':
-            parsePrompt(record);
+            record = parsePrompt();
             break;
         case '^':
-            parseResultRecord(record);
-            break;
         case '*':
-            // Same as result, only differs in start
-            // marker.
-            parseResultRecord(record);
-            break;
         case '=':
-            parseResultRecord(record);
+        case '+':
+            record = parseResultOrAsyncRecord();
             break;
         default:
             break;
     }
 
+    if (record && record->kind == Record::Result) {
+        ResultRecord * result = static_cast<ResultRecord *>(record.get());
+        result->token = token;
+    } else {
+        Q_ASSERT(token == 0);
+    }
+
     return record;
 }
 
-bool MIParser::parsePrompt(Record *&record)
+std::unique_ptr<Record> MIParser::parsePrompt()
 {
-    ADVANCE('(');
-    MATCH(Token_identifier);
+    ADVANCE_PTR('(');
+    MATCH_PTR(Token_identifier);
     if (m_lex->currentTokenText() != "gdb")
-        return false;
+        return {};
     m_lex->nextToken();
-    ADVANCE(')');
+    ADVANCE_PTR(')');
 
-    record = new PromptRecord;
-    return true;
+    return std::unique_ptr<Record>(new PromptRecord);
 }
 
-bool MIParser::parseStreamRecord(Record *&record)
+std::unique_ptr<Record> MIParser::parseStreamRecord()
 {
-    std::unique_ptr<StreamRecord> stream(new StreamRecord);
+    StreamRecord::Subkind subkind;
 
     switch (m_lex->lookAhead()) {
-        case '~':
-        case '@':
-        case '&': {
-            stream->reason = m_lex->lookAhead();
-            m_lex->nextToken();
-            MATCH(Token_string_literal);
-            stream->message = parseStringLiteral();
-            record = stream.release();
-        }
-        return true;
-
-        default:
-            break;
+    case '~': subkind = StreamRecord::Console; break;
+    case '@': subkind = StreamRecord::Target; break;
+    case '&': subkind = StreamRecord::Log; break;
+    default:
+        Q_ASSERT(false);
+        return {};
     }
 
-    return false;
+    std::unique_ptr<StreamRecord> stream(new StreamRecord(subkind));
+
+    m_lex->nextToken();
+    MATCH_PTR(Token_string_literal);
+    stream->message = parseStringLiteral();
+    return std::move(stream);
 }
 
-bool MIParser::parseResultRecord(Record *&record)
+std::unique_ptr<Record> MIParser::parseResultOrAsyncRecord()
 {
+    std::unique_ptr<TupleRecord> result;
+
     char c = m_lex->lookAhead();
-    if (c != '^' && c != '*' && c != '=' && c != '+')
-        return false;
     m_lex->nextToken();
-
-    MATCH(Token_identifier);
+    MATCH_PTR(Token_identifier);
     QString reason = m_lex->currentTokenText();
     m_lex->nextToken();
 
-    std::unique_ptr<ResultRecord> res(new ResultRecord);
-    res->reason = reason;
-    if (c == '^')
-        res->subkind = ResultRecord::CommandResult;
-    else if (c == '*')
-        res->subkind = ResultRecord::ExecNotification;
-    else if (c == '+')
-        res->subkind = ResultRecord::StatusNotification;
-    else {
-        Q_ASSERT(c == '=');
-        res->subkind = ResultRecord::GeneralNotification;        
-    }
-                
-    if (m_lex->lookAhead() != ',') {
-        record = res.release();
-        return true;
+    if (c == '^') {
+        result.reset(new ResultRecord(reason));
+    } else {
+        AsyncRecord::Subkind subkind;
+        switch (c) {
+        case '*': subkind = AsyncRecord::Exec; break;
+        case '=': subkind = AsyncRecord::Notify; break;
+        case '+': subkind = AsyncRecord::Status; break;
+        default:
+            Q_ASSERT(false);
+            return {};
+        }
+        result.reset(new AsyncRecord(subkind, reason));
     }
 
-    m_lex->nextToken();
-    
-    if (!parseCSV(*res))
-        return false;
+    if (m_lex->lookAhead() == ',') {
+        m_lex->nextToken();
 
-    record = res.release();
-    return true;
+        if (!parseCSV(*result))
+            return {};
+    }
+
+    return std::move(result);
 }
 
 bool MIParser::parseResult(Result *&result)
diff --git a/debuggers/gdb/mi/miparser.h b/debuggers/gdb/mi/miparser.h
index 7096af0..e01c314 100644
--- a/debuggers/gdb/mi/miparser.h
+++ b/debuggers/gdb/mi/miparser.h
@@ -20,6 +20,8 @@
 #ifndef MIPARSER_H
 #define MIPARSER_H
 
+#include <memory>
+
 #include "milexer.h"
 #include "gdbmi.h"
 
@@ -34,12 +36,12 @@ public:
     MIParser();
     ~MIParser();
 
-    GDBMI::Record *parse(FileSymbol *file);
+    std::unique_ptr<GDBMI::Record> parse(FileSymbol *file);
 
 protected: // rules
-    bool parseResultRecord(GDBMI::Record *&record);
-    bool parsePrompt(GDBMI::Record *&record);
-    bool parseStreamRecord(GDBMI::Record *&record);
+    std::unique_ptr<GDBMI::Record> parseResultOrAsyncRecord();
+    std::unique_ptr<GDBMI::Record> parsePrompt();
+    std::unique_ptr<GDBMI::Record> parseStreamRecord();
 
     bool parseResult(GDBMI::Result *&result);
     bool parseValue(GDBMI::Value *&value);
diff --git a/debuggers/gdb/printers/CMakeLists.txt b/debuggers/gdb/printers/CMakeLists.txt
index f772c8a..cfc0b85 100644
--- a/debuggers/gdb/printers/CMakeLists.txt
+++ b/debuggers/gdb/printers/CMakeLists.txt
@@ -1,7 +1,4 @@
 add_subdirectory(tests)
 
-configure_file( gdbinit ${CMAKE_CURRENT_BINARY_DIR}/gdbinit )
-
-install( FILES helper.py qt4.py kde4.py
-    ${CMAKE_CURRENT_BINARY_DIR}/gdbinit
+install( FILES helper.py qt4.py kde4.py gdbinit
     DESTINATION ${DATA_INSTALL_DIR}/kdevgdb/printers )
diff --git a/debuggers/gdb/printers/gdbinit b/debuggers/gdb/printers/gdbinit
index c82ac97..787cad6 100644
--- a/debuggers/gdb/printers/gdbinit
+++ b/debuggers/gdb/printers/gdbinit
@@ -1,6 +1,4 @@
 python
-import sys
-sys.path.insert(0, '${DATA_INSTALL_DIR}/kdevgdb/printers')
 
 from qt4 import register_qt4_printers
 register_qt4_printers (None)
diff --git a/debuggers/gdb/unittests/gdb_script_empty b/debuggers/gdb/unittests/gdb_script_empty
new file mode 100644
index 0000000..ffa43c0
--- /dev/null
+++ b/debuggers/gdb/unittests/gdb_script_empty
@@ -0,0 +1 @@
+# Dummy script used for testing purposes
diff --git a/debuggers/gdb/unittests/gdbtest.cpp b/debuggers/gdb/unittests/gdbtest.cpp
index ef3cd42..82f080c 100644
--- a/debuggers/gdb/unittests/gdbtest.cpp
+++ b/debuggers/gdb/unittests/gdbtest.cpp
@@ -67,11 +67,35 @@ KUrl findExecutable(const QString& name)
 
 QString findSourceFile(const QString& name)
 {
-    QFileInfo info(QFileInfo(__FILE__).dir().path() + '/' + name);
+    QFileInfo info(QFileInfo(__FILE__).dir().absoluteFilePath(name));
     Q_ASSERT(info.exists());
     return info.canonicalFilePath();
 }
 
+static bool isAttachForbidden(const char * file, int line)
+{
+    // if on linux, ensure we can actually attach
+    QFile canRun("/proc/sys/kernel/yama/ptrace_scope");
+    if (canRun.exists()) {
+        if (!canRun.open(QIODevice::ReadOnly)) {
+            QTest::qFail("Something is wrong: /proc/sys/kernel/yama/ptrace_scope exists but cannot be read", file, line);
+            return true;
+        }
+        if (canRun.read(1).toInt() != 0) {
+            QTest::qSkip("ptrace attaching not allowed, skipping test. To enable it, set /proc/sys/kernel/yama/ptrace_scope to 0.", QTest::SkipSingle, file, line);
+            return true;
+        }
+    }
+
+    return false;
+}
+
+#define SKIP_IF_ATTACH_FORBIDDEN() \
+    do { \
+        if (isAttachForbidden(__FILE__, __LINE__)) \
+            return; \
+    } while(0)
+
 void GdbTest::initTestCase()
 {
     AutoTestShell::init();
@@ -159,6 +183,7 @@ public:
     {
         qRegisterMetaType<KUrl>("KUrl");
         
+        setTesting(true);
         KDevelop::ICore::self()->debugController()->addSession(this);
     }
     
@@ -175,13 +200,62 @@ public:
 
 };
 
+class TestWaiter
+{
+public:
+    TestWaiter(DebugSession * session_, const char * condition_, const char * file_, int line_)
+        : session(session_)
+        , condition(condition_)
+        , file(file_)
+        , line(line_)
+    {
+        stopWatch.start();
+    }
+
+    bool waitUnless(bool ok)
+    {
+        if (ok) {
+            qDebug() << "Condition " << condition << " reached in " << file << ':' << line;
+            return false;
+        }
+
+        if (stopWatch.elapsed() > 5000) {
+            QTest::qFail(qPrintable(QString("Timeout before reaching condition %0").arg(condition)),
+                file, line);
+            return false;
+        }
+
+        QTest::qWait(100);
+
+        if (!session) {
+            QTest::qFail(qPrintable(QString("Session ended without reaching condition %0").arg(condition)),
+                file, line);
+            return false;
+        }
+
+        return true;
+    }
+
+private:
+    QTime stopWatch;
+    QPointer<DebugSession> session;
+    const char * condition;
+    const char * file;
+    int line;
+};
 
 #define WAIT_FOR_STATE(session, state) \
     waitForState((session), (state), __FILE__, __LINE__)
 
-#define WAIT_FOR_STATE_FAIL(session, state) \
+#define WAIT_FOR_STATE_AND_IDLE(session, state) \
     waitForState((session), (state), __FILE__, __LINE__, true)
 
+#define WAIT_FOR(session, condition) \
+    do { \
+        TestWaiter w((session), #condition, __FILE__, __LINE__); \
+        while (w.waitUnless((condition))) /* nothing */ ; \
+    } while(0)
+
 #define COMPARE_DATA(index, expected) \
     compareData((index), (expected), __FILE__, __LINE__)
 void compareData(QModelIndex index, QString expected, const char *file, int line)
@@ -224,17 +298,19 @@ void GdbTest::testBreakpoint()
     TestLaunchConfiguration cfg;
 
     KDevelop::Breakpoint * b = breakpoints()->addCodeBreakpoint(debugeeFileName, 28);
-    QCOMPARE(session->breakpointController()->breakpointState(b), KDevelop::Breakpoint::NotStartedState);
+    QCOMPARE(b->state(), KDevelop::Breakpoint::NotStartedState);
 
     session->startProgram(&cfg, m_iface);
     WAIT_FOR_STATE(session, DebugSession::PausedState);
-    QCOMPARE(session->breakpointController()->breakpointState(b), KDevelop::Breakpoint::CleanState);
+    QCOMPARE(b->state(), KDevelop::Breakpoint::CleanState);
     session->stepInto();
     WAIT_FOR_STATE(session, DebugSession::PausedState);
     session->stepInto();
     WAIT_FOR_STATE(session, DebugSession::PausedState);
     session->run();
     WAIT_FOR_STATE(session, DebugSession::EndedState);
+
+    QCOMPARE(b->state(), KDevelop::Breakpoint::NotStartedState);
 }
 
 void GdbTest::testDisableBreakpoint()
@@ -267,7 +343,7 @@ void GdbTest::testDisableBreakpoint()
 
 
     session->startProgram(&cfg, m_iface);
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
 
     QCOMPARE(session->currentLine(), thirdBreak->line());
 
@@ -293,7 +369,7 @@ void GdbTest::testChangeLocationBreakpoint()
     KDevelop::Breakpoint *b = breakpoints()->addCodeBreakpoint(debugeeFileName, 27);
 
     session->startProgram(&cfg, m_iface);
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 27);
 
     QTest::qWait(100);
@@ -334,9 +410,8 @@ void GdbTest::testDeleteBreakpoint()
     breakpoints()->addCodeBreakpoint(debugeeFileName, 22);
 
     session->startProgram(&cfg, m_iface);
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     breakpoints()->removeRow(0);
-    QTest::qWait(100);
     session->run();
 
     WAIT_FOR_STATE(session, DebugSession::EndedState);
@@ -350,11 +425,11 @@ void GdbTest::testPendingBreakpoint()
     breakpoints()->addCodeBreakpoint(debugeeFileName, 28);
 
     KDevelop::Breakpoint * b = breakpoints()->addCodeBreakpoint(findSourceFile("/gdbtest.cpp"), 10);
-    QCOMPARE(session->breakpointController()->breakpointState(b), KDevelop::Breakpoint::NotStartedState);
+    QCOMPARE(b->state(), KDevelop::Breakpoint::NotStartedState);
 
     session->startProgram(&cfg, m_iface);
     WAIT_FOR_STATE(session, DebugSession::PausedState);
-    QCOMPARE(session->breakpointController()->breakpointState(b), KDevelop::Breakpoint::PendingState);
+    QCOMPARE(b->state(), KDevelop::Breakpoint::PendingState);
     session->run();
     WAIT_FOR_STATE(session, DebugSession::EndedState);
 }
@@ -389,18 +464,19 @@ void GdbTest::testIgnoreHitsBreakpoint()
     TestDebugSession *session = new TestDebugSession;
     TestLaunchConfiguration cfg;
 
-    KDevelop::Breakpoint * b = breakpoints()->addCodeBreakpoint(debugeeFileName, 21);
-    b->setIgnoreHits(1);
+    KDevelop::Breakpoint * b1 = breakpoints()->addCodeBreakpoint(debugeeFileName, 21);
+    b1->setIgnoreHits(1);
 
-    b = breakpoints()->addCodeBreakpoint(debugeeFileName, 22);
+    KDevelop::Breakpoint * b2 = breakpoints()->addCodeBreakpoint(debugeeFileName, 22);
 
     session->startProgram(&cfg, m_iface);
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
-    QTest::qWait(100);
-    b->setIgnoreHits(1);
+    //WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR(session, session->state() == DebugSession::PausedState && b2->hitCount() == 1);
+    b2->setIgnoreHits(1);
     session->run();
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    //WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR(session, session->state() == DebugSession::PausedState && b1->hitCount() == 1);
     session->run();
     WAIT_FOR_STATE(session, DebugSession::EndedState);
 }
@@ -420,8 +496,7 @@ void GdbTest::testConditionBreakpoint()
 
     session->startProgram(&cfg, m_iface);
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
-    QCOMPARE(session->line(), 24);
+    WAIT_FOR(session, session->state() == DebugSession::PausedState && session->line() == 24);
     b->setCondition("i == 0");
     QTest::qWait(100);
     session->run();
@@ -443,7 +518,7 @@ void GdbTest::testBreakOnWriteBreakpoint()
 
     session->startProgram(&cfg, m_iface);
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 24);
     
     breakpoints()->addWatchpoint("i");
@@ -468,7 +543,7 @@ void GdbTest::testBreakOnWriteWithConditionBreakpoint()
 
     session->startProgram(&cfg, m_iface);
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 24);
 
     KDevelop::Breakpoint *b = breakpoints()->addWatchpoint("i");
@@ -513,7 +588,7 @@ void GdbTest::testBreakOnReadBreakpoint2()
 
     session->startProgram(&cfg, m_iface);
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 24);
 
     breakpoints()->addReadWatchpoint("i");
@@ -539,7 +614,7 @@ void GdbTest::testBreakOnAccessBreakpoint()
 
     session->startProgram(&cfg, m_iface);
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 24);
 
     breakpoints()->addAccessWatchpoint("i");
@@ -617,7 +692,7 @@ void GdbTest::testInsertBreakpointFunctionName()
     breakpoints()->addCodeBreakpoint("main");
 
     session->startProgram(&cfg, m_iface);
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 27);
     session->run();
     WAIT_FOR_STATE(session, DebugSession::EndedState);
@@ -667,13 +742,12 @@ void GdbTest::testStack()
     
     breakpoints()->addCodeBreakpoint(debugeeFileName, 21);
     QVERIFY(session->startProgram(&cfg, m_iface));
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
 
     QModelIndex tIdx = stackModel->index(0,0);    
     QCOMPARE(stackModel->rowCount(QModelIndex()), 1);
     QCOMPARE(stackModel->columnCount(QModelIndex()), 3);
     COMPARE_DATA(tIdx, "#1 at foo");
-    
 
     QCOMPARE(stackModel->rowCount(tIdx), 2);
     QCOMPARE(stackModel->columnCount(tIdx), 3);
@@ -709,7 +783,7 @@ void GdbTest::testStackFetchMore()
 
     breakpoints()->addCodeBreakpoint(fileName, 25);
     QVERIFY(session->startProgram(&cfg, m_iface));
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->frameStackModel()->fetchFramesCalled, 1);
 
     QModelIndex tIdx = stackModel->index(0,0);
@@ -808,8 +882,7 @@ void GdbTest::testStackSwitchThread()
 
     breakpoints()->addCodeBreakpoint(fileName, 38);
     QVERIFY(session->startProgram(&cfg, m_iface));
-    QTest::qWait(500);
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
 
     QCOMPARE(stackModel->rowCount(), 4);
 
@@ -833,14 +906,7 @@ void GdbTest::testStackSwitchThread()
 
 void GdbTest::testAttach()
 {
-    // if on linux, ensure we can actually attach
-    QFile canRun("/proc/sys/kernel/yama/ptrace_scope");
-    if (canRun.exists()) {
-        QVERIFY(canRun.open(QIODevice::ReadOnly));
-        if (canRun.read(1).toInt() != 0) {
-            QSKIP("ptrace attaching not allows, skipping test. To enable it, set /proc/sys/kernel/yama/ptrace_scope to 0.", SkipAll);
-        }
-    }
+    SKIP_IF_ATTACH_FORBIDDEN();
 
     QString fileName = findSourceFile("debugeeslow.cpp");
 
@@ -867,6 +933,31 @@ void GdbTest::testAttach()
     WAIT_FOR_STATE(session, DebugSession::EndedState);
 }
 
+void GdbTest::testManualAttach()
+{
+    SKIP_IF_ATTACH_FORBIDDEN();
+
+    QString fileName = findSourceFile("debugeeslow.cpp");
+
+    KProcess debugeeProcess;
+    debugeeProcess << "nice" << findExecutable("debugeeslow").toLocalFile();
+    debugeeProcess.start();
+    QVERIFY(debugeeProcess.waitForStarted());
+
+    TestDebugSession *session = new TestDebugSession;
+
+    TestLaunchConfiguration cfg;
+    cfg.config().writeEntry(GDBDebugger::remoteGdbRunEntry, KUrl(findSourceFile("gdb_script_empty")));
+    QVERIFY(session->startProgram(&cfg, m_iface));
+
+    session->addCommand(GDBMI::NonMI, QString("attach %0").arg(debugeeProcess.pid()));
+    WAIT_FOR_STATE(session, DebugSession::PausedState);
+
+    session->run();
+    QTest::qWait(2000); // give the slow inferior some extra time to run
+    WAIT_FOR_STATE(session, DebugSession::EndedState);
+}
+
 void GdbTest::testCoreFile()
 {
     QFile f("core");
@@ -1242,7 +1333,7 @@ void GdbTest::testSegfaultDebugee()
 
     QVERIFY(session->startProgram(&cfg, m_iface));
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 23);
     session->run();
 
@@ -1263,7 +1354,7 @@ void GdbTest::testSwitchFrameGdbConsole()
 
     breakpoints()->addCodeBreakpoint(debugeeFileName, 24);
     QVERIFY(session->startProgram(&cfg, m_iface));
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(stackModel->currentFrame(), 0);
     stackModel->setCurrentFrame(1);
     QCOMPARE(stackModel->currentFrame(), 1);
@@ -1328,7 +1419,7 @@ void GdbTest::testPickupManuallyInsertedBreakpoint()
     KDevelop::Breakpoint *b = breakpoints()->breakpoint(1);
     QVERIFY(b);
     QCOMPARE(b->line(), 31); //we start with 0, gdb with 1
-    QCOMPARE(b->url().url(), QString("debugee.cpp"));
+    QCOMPARE(b->url().fileName(), QString("debugee.cpp"));
 }
 
 //Bug 270970
@@ -1356,12 +1447,12 @@ void GdbTest::testPickupManuallyInsertedBreakpointOnlyOnce()
     KDevelop::Breakpoint *b = breakpoints()->breakpoint(0);
     QVERIFY(b);
     QCOMPARE(b->line(), 31); //we start with 0, gdb with 1
-    QCOMPARE(b->url().url(), QString("debugee.cpp"));
+    QCOMPARE(b->url().fileName(), QString("debugee.cpp"));
 
     b = breakpoints()->breakpoint(1);
     QVERIFY(b);
     QCOMPARE(b->line(), 21);
-    QCOMPARE(b->url().url(), QString("debugee.cpp"));
+    QCOMPARE(b->url().fileName(), QString("debugee.cpp"));
 }
 
 void GdbTest::testRunGdbScript()
@@ -1382,7 +1473,7 @@ void GdbTest::testRunGdbScript()
 
     QVERIFY(session->startProgram(&cfg, m_iface));
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
 
     QCOMPARE(session->line(), 27);
 
@@ -1421,7 +1512,7 @@ void GdbTest::testRemoteDebug()
 
     QVERIFY(session->startProgram(&cfg, m_iface));
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
 
     QCOMPARE(session->line(), 29);
 
@@ -1465,7 +1556,7 @@ void GdbTest::testRemoteDebugInsertBreakpoint()
 
     QVERIFY(session->startProgram(&cfg, m_iface));
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
 
     QCOMPARE(session->line(), 29);
 
@@ -1516,7 +1607,7 @@ void GdbTest::testRemoteDebugInsertBreakpointPickupOnlyOnce()
 
     QVERIFY(session->startProgram(&cfg, m_iface));
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
 
     QCOMPARE(session->line(), 29);
 
@@ -1534,7 +1625,7 @@ void GdbTest::testRemoteDebugInsertBreakpointPickupOnlyOnce()
     session = new TestDebugSession;
     QVERIFY(session->startProgram(&cfg, m_iface));
 
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
 
     QCOMPARE(session->line(), 29);
 
@@ -1560,10 +1651,10 @@ void GdbTest::testBreakpointWithSpaceInPath()
     QString fileName = findSourceFile("debugee space.cpp");
 
     KDevelop::Breakpoint * b = breakpoints()->addCodeBreakpoint(fileName, 20);
-    QCOMPARE(session->breakpointController()->breakpointState(b), KDevelop::Breakpoint::NotStartedState);
+    QCOMPARE(b->state(), KDevelop::Breakpoint::NotStartedState);
 
     session->startProgram(&cfg, m_iface);
-    WAIT_FOR_STATE_FAIL(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 20);
     session->run();
     WAIT_FOR_STATE(session, DebugSession::EndedState);
@@ -1582,7 +1673,7 @@ void GdbTest::testBreakpointDisabledOnStart()
     b->setData(KDevelop::Breakpoint::EnableColumn, Qt::Unchecked);
 
     session->startProgram(&cfg, m_iface);
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 29);
     b->setData(KDevelop::Breakpoint::EnableColumn, Qt::Checked);
     session->run();
@@ -1676,8 +1767,8 @@ void GdbTest::parseBug304730()
 
     MIParser parser;
 
-    QScopedPointer<GDBMI::Record> record(parser.parse(&file));
-    QVERIFY(!record.isNull());
+    std::unique_ptr<GDBMI::Record> record(parser.parse(&file));
+    QVERIFY(record.get() != nullptr);
 }
 
 void GdbTest::testMultipleLocationsBreakpoint()
@@ -1691,7 +1782,7 @@ void GdbTest::testMultipleLocationsBreakpoint()
     //TODO check if the additional location breakpoint is added
 
     session->startProgram(&cfg, m_iface);
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QCOMPARE(session->line(), 19);
 
     session->run();
@@ -1785,8 +1876,8 @@ void GdbTest::testChangeBreakpointWhileRunning() {
     TestLaunchConfiguration c(findExecutable("debugeeslow"));
     KDevelop::Breakpoint* b = breakpoints()->addCodeBreakpoint("debugeeslow.cpp:25");
     session->startProgram(&c, m_iface);
-    
-    WAIT_FOR_STATE(session, DebugSession::PausedState);
+
+    WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
     QVERIFY(session->currentLine() >= 24 && session->currentLine() <= 26 );
     session->run();
     WAIT_FOR_STATE(session, DebugSession::ActiveState);
@@ -1823,8 +1914,8 @@ void GdbTest::testDebugInExternalTerminal()
         KDevelop::Breakpoint* b = breakpoints()->addCodeBreakpoint(debugeeFileName, 28);
 
         session->startProgram(&cfg, m_iface);
-        WAIT_FOR_STATE(session, DebugSession::PausedState);
-        QCOMPARE(session->breakpointController()->breakpointState(b), KDevelop::Breakpoint::CleanState);
+        WAIT_FOR_STATE_AND_IDLE(session, DebugSession::PausedState);
+        QCOMPARE(b->state(), KDevelop::Breakpoint::CleanState);
         session->stepInto();
         WAIT_FOR_STATE(session, DebugSession::PausedState);
         session->run();
@@ -1841,43 +1932,45 @@ void GdbTest::testPathWithSpace()
     auto debugee = findExecutable("path with space/spacedebugee");
     TestLaunchConfiguration c(debugee, debugee.upUrl());
     KDevelop::Breakpoint* b = breakpoints()->addCodeBreakpoint("spacedebugee.cpp:30");
-    QCOMPARE(session->breakpointController()->breakpointState(b), KDevelop::Breakpoint::NotStartedState);
+    QCOMPARE(b->state(), KDevelop::Breakpoint::NotStartedState);
     session->startProgram(&c, m_iface);
 
     WAIT_FOR_STATE(session, DebugSession::PausedState);
-    QCOMPARE(session->breakpointController()->breakpointState(b), KDevelop::Breakpoint::CleanState);
+    QCOMPARE(b->state(), KDevelop::Breakpoint::CleanState);
     session->run();
     WAIT_FOR_STATE(session, DebugSession::EndedState);
 #endif
 }
 
 void GdbTest::waitForState(GDBDebugger::DebugSession *session, DebugSession::DebuggerState state,
-                            const char *file, int line, bool expectFail)
+                            const char *file, int line, bool waitForIdle)
 {
     QWeakPointer<GDBDebugger::DebugSession> s(session); //session can get deleted in DebugController
-    kDebug() << "waiting for state" << state;
     QTime stopWatch;
     stopWatch.start();
-    while (s.data()->state() != state) {
+    while (s.data()->state() != state || (waitForIdle && s.data()->stateIsOn(s_dbgBusy))) {
         if (stopWatch.elapsed() > 5000) {
             kWarning() << "current state" << s.data()->state() << "waiting for" << state;
-            if (!expectFail) {
-                QFAIL(qPrintable(QString("Didn't reach state in %0:%1").arg(file).arg(line)));
-            } else {
-                break;
-            }
+            QTest::qFail(qPrintable(QString("Timeout before reaching state %0").arg(state)),
+                file, line);
+            return;
         }
         QTest::qWait(20);
         if (!s) {
-            if (state == DebugSession::EndedState) break;
-            if (!expectFail) {
-                QFAIL(qPrintable(QString("Didn't reach state; session ended in %0:%1").arg(file).arg(line)));
-            } else {
+            if (state == DebugSession::EndedState)
                 break;
-            }
+            QTest::qFail(qPrintable(QString("Session ended before reaching state %0").arg(state)),
+                file, line);
+            return;
         }
     }
-    QTest::qWait(100);
+    if (!waitForIdle && state != DebugSession::EndedState) {
+        // legacy behavior for tests that implicitly may require waiting for idle,
+        // but which were written before waitForIdle was added
+        QTest::qWait(100);
+    }
+
+    qDebug() << "Reached state " << state << " in " << file << ':' << line;
 }
 
 }
diff --git a/debuggers/gdb/unittests/gdbtest.h b/debuggers/gdb/unittests/gdbtest.h
index b9a961d..4cb0a14 100644
--- a/debuggers/gdb/unittests/gdbtest.h
+++ b/debuggers/gdb/unittests/gdbtest.h
@@ -60,6 +60,7 @@ private Q_SLOTS:
     void testStackDeactivateAndActive();
     void testStackSwitchThread();
     void testAttach();
+    void testManualAttach();
     void testCoreFile();
     void testVariablesLocals();
     void testVariablesLocalsStruct();
@@ -97,7 +98,7 @@ private:
     void waitForState(GDBDebugger::DebugSession *session,
                       KDevelop::IDebugSession::DebuggerState state,
                       const char *file, int line,
-                      bool expectFail = false);
+                      bool waitForIdle = false);
     IExecutePlugin* m_iface;
 };
 
diff --git a/debuggers/gdb/variablecontroller.cpp b/debuggers/gdb/variablecontroller.cpp
index 5198c09..5cf27f0 100644
--- a/debuggers/gdb/variablecontroller.cpp
+++ b/debuggers/gdb/variablecontroller.cpp
@@ -41,7 +41,7 @@ VariableController::VariableController(DebugSession* parent)
     : KDevelop::IVariableController(parent)
 {
     Q_ASSERT(parent);
-    connect(parent, SIGNAL(programStopped(GDBMI::ResultRecord)), SLOT(programStopped(GDBMI::ResultRecord)));
+    connect(parent, SIGNAL(programStopped(GDBMI::AsyncRecord)), SLOT(programStopped(GDBMI::AsyncRecord)));
     connect(parent, SIGNAL(stateChanged(KDevelop::IDebugSession::DebuggerState)), SLOT(stateChanged(KDevelop::IDebugSession::DebuggerState)));
 }
 
@@ -50,7 +50,7 @@ DebugSession *VariableController::debugSession() const
     return static_cast<DebugSession*>(const_cast<QObject*>(QObject::parent()));
 }
 
-void VariableController::programStopped(const GDBMI::ResultRecord& r)
+void VariableController::programStopped(const GDBMI::AsyncRecord& r)
 {
     if (debugSession()->stateIsOn(s_shuttingDown)) return;
 
diff --git a/debuggers/gdb/variablecontroller.h b/debuggers/gdb/variablecontroller.h
index f5ac8c1..924e87e 100644
--- a/debuggers/gdb/variablecontroller.h
+++ b/debuggers/gdb/variablecontroller.h
@@ -31,6 +31,7 @@
 using namespace KDevelop;
 
 namespace GDBMI {
+struct AsyncRecord;
 struct ResultRecord;
 struct Value;
 }
@@ -56,7 +57,7 @@ public:
     virtual void update();
 
 private slots:
-    void programStopped(const GDBMI::ResultRecord &r);
+    void programStopped(const GDBMI::AsyncRecord &r);
     void stateChanged(KDevelop::IDebugSession::DebuggerState);
 
 private:
diff --git a/formatters/customscript/kdevcustomscript.desktop.cmake b/formatters/customscript/kdevcustomscript.desktop.cmake
index 7b8c9f8..0569eed 100644
--- a/formatters/customscript/kdevcustomscript.desktop.cmake
+++ b/formatters/customscript/kdevcustomscript.desktop.cmake
@@ -52,7 +52,7 @@ Name[it]=Backend formattatore script personalizzato
 Name[kk]=Пайдаланушы скрипттер пішімдегіш тетігі
 Name[nb]=Bakgrunnsmotor for formattering med egne skripter
 Name[nds]=Egen Skript-Formateerhülpprogramm
-Name[nl]=Eigen script voor formatteerbackend
+Name[nl]=Backend voor formatteerprogramma met eigen scripts
 Name[pl]=Silnik formatowania przy użyciu własnych skryptów
 Name[pt]=Infra-Estrutura de Formatação Personalizada
 Name[pt_BR]=Infraestrutura de formatação de scripts personalizados
diff --git a/languages/cpp/codegen/makeimplementationprivate.h b/languages/cpp/codegen/makeimplementationprivate.h
index 1db7489..bab7be1 100644
--- a/languages/cpp/codegen/makeimplementationprivate.h
+++ b/languages/cpp/codegen/makeimplementationprivate.h
@@ -86,8 +86,8 @@ class MakeImplementationPrivate : public CodeGenerator<ParseSession>
     //DocumentChange insertConstructorInitializations(ClassFunctionDeclaration * constructor, const QList<ClassMemberDeclaration *>)
 };
 
-Q_DECLARE_OPERATORS_FOR_FLAGS(MakeImplementationPrivate::Policies)
-
 }
 
+Q_DECLARE_OPERATORS_FOR_FLAGS(KDevelop::MakeImplementationPrivate::Policies)
+
 #endif // MAKEIMPLEMENTATIONPRIVATE_H
diff --git a/languages/plugins/custom-definesandincludes/kcm_widget/kcm_kdevcustomdefinesandincludes.desktop b/languages/plugins/custom-definesandincludes/kcm_widget/kcm_kdevcustomdefinesandincludes.desktop
index e9f226e..e6708b3 100644
--- a/languages/plugins/custom-definesandincludes/kcm_widget/kcm_kdevcustomdefinesandincludes.desktop
+++ b/languages/plugins/custom-definesandincludes/kcm_widget/kcm_kdevcustomdefinesandincludes.desktop
@@ -9,6 +9,7 @@ X-KDE-ParentApp=kdevplatformproject
 X-KDE-ParentComponents=kdevplatformproject
 
 Name=Custom Defines And Includes
+Name[bs]=Vlastite definicije i uključivanja
 Name[ca]=Personalitza les definicions i inclusions
 Name[de]=Eigene Definitionen und Includes
 Name[en_GB]=Custom Defines And Includes
@@ -29,6 +30,7 @@ Name[uk]=Нетипові визначення і включення
 Name[x-test]=xxCustom Defines And Includesxx
 
 Comment=Configure which macros and include directories/files will be added to the parser during project parsing.
+Comment[bs]=Konfiguriše koji makroi i direktoriji/uključivanja će se dodati parseru tokom parsiranja projekta.
 Comment[ca]=Configura quines macros i directoris/fitxers s'afegiran a l'analitzador durant l'anàlisi del projecte.
 Comment[de]=Einstellung der Makros und Include-Ordner/-Dateien, die zum für den Parser während des Einlesens des Projekts hinzugefügt werden.
 Comment[en_GB]=Configure which macros and include directories/files will be added to the parser during project parsing.
@@ -47,3 +49,4 @@ Comment[sv]=Anpassa vilka makron och filer eller kataloger att inkludera som lä
 Comment[tr]=Proje ayrıştırılırken hangi makroların ve içerme dizinlerinin/dosyaların ayrıştırıcıya ekleneceğini yapılandırın.
 Comment[uk]=Налаштувати макроси і включені каталоги або файли, які буде додано під час обробки проекту.
 Comment[x-test]=xxConfigure which macros and include directories/files will be added to the parser during project parsing.xx
+Comment[zh_CN]=配置在解析项目时加入哪些宏、引用目录和文件。
diff --git a/languages/plugins/custom-definesandincludes/kdevdefinesandincludesmanager.desktop.cmake b/languages/plugins/custom-definesandincludes/kdevdefinesandincludesmanager.desktop.cmake
index 61472b0..2b351ec 100644
--- a/languages/plugins/custom-definesandincludes/kdevdefinesandincludesmanager.desktop.cmake
+++ b/languages/plugins/custom-definesandincludes/kdevdefinesandincludesmanager.desktop.cmake
@@ -1,6 +1,7 @@
 [Desktop Entry]
 Type=Service
 Name=Custom Defines And Includes Manager
+Name[bs]=Menadžer vlastitih definicija i uključivanja
 Name[ca]=Gestor per personalitzar les definicions i inclusions
 Name[de]=Verwaltung eigener Definitionen und Includes
 Name[en_GB]=Custom Defines And Includes Manager
@@ -20,6 +21,7 @@ Name[tr]=Özel Tanımlama ve İçerme Yöneticisi
 Name[uk]=Керування нетиповими визначеннями і включеннями
 Name[x-test]=xxCustom Defines And Includes Managerxx
 GenericName=Custom Defines And Includes Manager
+GenericName[bs]=Menadžer vlastitih definicija i uključivanja
 GenericName[ca]=Gestor per personalitzar les definicions i inclusions
 GenericName[de]=Verwaltung eigener Definitionen und Includes
 GenericName[en_GB]=Custom Defines And Includes Manager
@@ -39,6 +41,7 @@ GenericName[tr]=Özel Tanımlama ve İçerme Yöneticisi
 GenericName[uk]=Керування нетиповими визначеннями і включеннями
 GenericName[x-test]=xxCustom Defines And Includes Managerxx
 Comment=Configure which macros and include directories/files will be added to the parser during project parsing.
+Comment[bs]=Konfiguriše koji makroi i direktoriji/uključivanja će se dodati parseru tokom parsiranja projekta.
 Comment[ca]=Configura quines macros i directoris/fitxers s'afegiran a l'analitzador durant l'anàlisi del projecte.
 Comment[de]=Einstellung der Makros und Include-Ordner/-Dateien, die zum für den Parser während des Einlesens des Projekts hinzugefügt werden.
 Comment[en_GB]=Configure which macros and include directories/files will be added to the parser during project parsing.
@@ -57,6 +60,7 @@ Comment[sv]=Anpassa vilka makron och filer eller kataloger att inkludera som lä
 Comment[tr]=Proje ayrıştırılırken hangi makroların ve içerme dizinlerinin/dosyaların ayrıştırıcıya ekleneceğini yapılandırın.
 Comment[uk]=Налаштувати макроси і включені каталоги або файли, які буде додано під час обробки проекту.
 Comment[x-test]=xxConfigure which macros and include directories/files will be added to the parser during project parsing.xx
+Comment[zh_CN]=配置在解析项目时加入哪些宏、引用目录和文件。
 Icon=kdevelop
 ServiceTypes=KDevelop/Plugin
 X-KDE-Library=kdevdefinesandincludesmanager
